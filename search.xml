<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AZFT实习</title>
    <url>/2019/08/23/AZFT%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<p>今年暑假参加了浙大软院夏令营，即在AZFT实验室实习了一个月，学到的东西还是很多很杂的。回上海一礼拜了，总结一下，以免觉得好像在这宝贵的一段时间里啥也没做。<br>我接到的任务是盲道分割。</p>
<span id="more"></span>
<h2 id="阅读应用型的论文"><a href="#阅读应用型的论文" class="headerlink" title="阅读应用型的论文"></a>阅读应用型的论文</h2><h3 id="论文1（针对盲道识别）"><a href="#论文1（针对盲道识别）" class="headerlink" title="论文1（针对盲道识别）"></a>论文1（针对盲道识别）</h3><p> <strong>主要思想</strong></p>
<ul>
<li>盲道识别率、实时性；</li>
<li>提取盲道边界：对初始帧采取精确识别（灰度共生矩阵、模糊C均值聚类分割、Hough变换）</li>
<li>后续帧采取跟踪识别（图像灰度梯度特征、判断前后帧盲道边界两侧颜色分布一致性</li>
</ul>
<p> <strong>盲道精确识别</strong></p>
<ul>
<li>预处理：去阴影（区域补偿、深度膨胀）</li>
<li>盲道精确识别：<ol>
<li>灰度化、直方图均衡化：较大的灰度动态范围和较高的对比度，细节更加丰富；</li>
<li>灰度共生矩阵：空间分布关系包含图像纹理信息—&gt;联合特征矩阵</li>
<li>模糊C均值聚类分割—&gt;盲道区域的分割</li>
<li>轮廓提取及Hough变换</li>
</ol>
</li>
</ul>
<h3 id="论文2（针对纹理提取）"><a href="#论文2（针对纹理提取）" class="headerlink" title="论文2（针对纹理提取）"></a>论文2（针对纹理提取）</h3><p> <strong>主要思想</strong></p>
<ul>
<li><p>Gabor变换：Gabor核函数作为小波函数的基函数，实现方向和尺度不变的特征提取，具有较高的精度；</p>
</li>
<li><p>ICA、PCA与Gabor小波融合：提高识别率；</p>
</li>
<li><p>Relief算法：权值搜索的特征子集选择方法，提高识别效率；</p>
</li>
<li><p>K-means：DE（差分进化）求解最优聚类中心，优化K-means算法；</p>
<h2 id="python-opencv基础学习"><a href="#python-opencv基础学习" class="headerlink" title="python-opencv基础学习"></a>python-opencv基础学习</h2><p><img src="/img/opencv.jpg" alt="OpenCV模块"></p>
</li>
<li><p>滤波：信号有各种频率的成分，滤掉不想要的成分；</p>
</li>
<li><p>图像平滑：区域增强，减小缺陷；</p>
</li>
<li><p>图像金字塔：pyrDown()：平滑滤波+降采样；pyrUp():升采样+高斯平滑</p>
</li>
<li><p>低通滤波（均值模糊）：blur；高斯模糊GaussianBlur()</p>
</li>
<li><p>中值滤波（中值模糊,去除椒盐噪声）：medianblur;</p>
</li>
<li><p>双边滤波：bilateralFilter();空间邻近度和像素相似度，空域信息和灰度相似性-&gt;保证边缘附近像素值的保存；</p>
</li>
<li><p>均值迁移：pyrMeanShiftFiltering();</p>
</li>
<li><p>直方图均衡化：cv.equalizeHist();</p>
</li>
<li><p>归一化：normalize();</p>
</li>
<li><p>反向投影：calcBackProject()定位模板图像出现在输入图像的位置；</p>
</li>
<li><p>模板匹配：methods = [cv.TM_SQDIFF_NORMED, cv.TM_CCORR_NORMED, cv.TM_CCOEFF_NORMED]<br>matchTemplate()得到匹配结果图形矩阵result：尺寸（W-w+1）*(H-h+1)?</p>
</li>
<li><p>minMaxLoc()在给定矩阵中找最大和最小值</p>
</li>
<li><p>rectangle(target,tl,br,color,thickness)绘制矩形；</p>
</li>
</ul>
<p>全局阈值：threshold<br>局部阈值：adaptiveThreshold</p>
<h2 id="基础概念学习"><a href="#基础概念学习" class="headerlink" title="基础概念学习"></a>基础概念学习</h2><h3 id="gabor滤波"><a href="#gabor滤波" class="headerlink" title="gabor滤波"></a>gabor滤波</h3><p>gabor提取纹理特征的思路：<br>不同纹理一般具有不同的<strong>频率和带宽</strong>，根据他们设计一组Gabor滤波器对纹理图像进行滤波；<br>gabor滤波器：用于边缘提取的线性滤波器；波长，方向，相位偏移，长宽比，带宽；<br><a href="https://www.cnblogs.com/DOMLX/p/8989836.html">概念学习</a><br><a href="https://blog.csdn.net/zqx951102/article/details/89716358">例子</a><br><a href="https://blog.csdn.net/chenaiyanmie/article/details/80246108">详细介绍</a></p>
<h3 id="DE差分进化算法"><a href="#DE差分进化算法" class="headerlink" title="DE差分进化算法"></a>DE差分进化算法</h3><p>演化算法，随机模型，反复迭代；<br>求解连续变量的全局优化问题；<br>交叉-&gt;变异(试验个体)-&gt;选择（与目标个体）</p>
<h3 id="Relief特征权重算法"><a href="#Relief特征权重算法" class="headerlink" title="Relief特征权重算法"></a>Relief特征权重算法</h3><p>特征和类别的相关性</p>
<h3 id="灰度共生矩阵"><a href="#灰度共生矩阵" class="headerlink" title="灰度共生矩阵"></a>灰度共生矩阵</h3><p> <strong>Gray-level Co-occurrence Matrix</strong><br>假定图像各像素间的空间分布关系包含图像纹理的纹理分析方法；<br>两个灰阶值在指定的空间分布上出现的频率分布；<br>像素灰度在空间位置上的反复出现形成图像的纹理，GLCM是描述具有某种空间位置关系两个像素灰度的联合分布;<br><a href="http://www.dididongdong.com/archives/4327">概念学习</a></p>
<h3 id="方向梯度直方图（HOG）"><a href="#方向梯度直方图（HOG）" class="headerlink" title="方向梯度直方图（HOG）"></a>方向梯度直方图（HOG）</h3><p><a href="https://blog.csdn.net/liulina603/article/details/8291093">概念学习1</a><br><a href="https://www.learnopencv.com/histogram-of-oriented-gradients/">概念学习2</a><br><a href="https://blog.csdn.net/ppp8300885/article/details/71078555">代码实现</a></p>
<h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><p>简单接触了一下CNN的概念理解</p>
<ul>
<li>局部感受野：一个隐藏层的神经元与局部区域输入层的神经元相连（与DNN每个都连有所不同）<br>（参数：窗口大小w、步数b）</li>
<li>权值共享：权值和偏移值，一个窗口只能学到一种特征；</li>
<li>池化：简化卷积层的输出；</li>
</ul>
<p>输入层学到的特征反映在卷积层，池化层检测特征是否在窗口覆盖范围的区域里<br><a href="https://blog.csdn.net/liangchunjiang/article/details/79030681">详解</a></p>
<h3 id="RCNN"><a href="#RCNN" class="headerlink" title="RCNN"></a>RCNN</h3><p><a href="https://blog.csdn.net/u011534057/article/details/51218250">论文理解1</a><br><a href="https://blog.csdn.net/bryant_meng/article/details/78613881#commentBox">论文理解2</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要还是去看报告吧，靠论文和伟大的互联网写出了基于图像处理的盲道识别的基本算法，后面发现局限性太大了，为何学姐一开始不让我学语义分割，我琢磨这更有用，更有意思，更能学到东西，而不是写出几个乱七八糟，并且不能应用的算法？<br>本次夏令营有点运气加成，还让我发现自己在接触不懂的东西还是太浮躁了，答辩怪紧张的，认识的新朋友都很不错，还有大佬处处有，可惜不是我，总体体验一般般。</p>
]]></content>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>My first Post</title>
    <url>/2019/08/21/My-first-Post/</url>
    <content><![CDATA[<p>回来实习的第三天了，同样是摸鱼的不知道第几天。</p>
<span id="more"></span>
<p>之前在实验室看到学姐的个人博客真好看，摸鱼期间浏览了好多大神的博客，感觉大神就是大神，记录东西的都花里胡哨的，闲着也闲着，那我也搞个花里胡哨的东西。</p>
<p>希望能够坚持维护，坚持记录，坚持花里胡哨。</p>
<p>搭建博客用的是hexo+yilia：<br><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">参考网址</a><br><a href="http://litten.me/">参考博客</a></p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>git-note</title>
    <url>/2019/10/17/git-note/</url>
    <content><![CDATA[<p><strong>分布式版本控制系统</strong>：不必联网，强大的分支管理；<br>通过跟踪版本库中所有文件（文本文件的改动情况）；</p>
<ul>
<li>git add file 修改内容放到暂存区（stage）</li>
<li>git commit -m “des” 暂存区内容提交到当前分支</li>
<li>git status </li>
<li>git diff file / git diff HEAD – file 工作区与版本库里最新版本的区别</li>
</ul>
<h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><ul>
<li>git log 显示从近到远的提交日志 / git reflog 记录每一次命令日志</li>
<li><strong>版本回退</strong>：git reset –hard HEAD^|[commit_id]，HEAD为指向当前版本的指针，完全回到上一个版本</li>
</ul>
<p>–hard 撤销commit add 并且删除工作区代码<br>–mixed 撤销commit add 工作区代码不变<br>–soft 撤销commit 不撤销add 工作区代码不变 </p>
<ul>
<li>git reset HEAD file 把暂存区修改撤销掉(unstage，add撤销)</li>
<li>git checkout – file 撤销工作区修改,一键还原</li>
</ul>
<hr>
<p><img src="/img/git-note/revert.jpg" alt="回退场景"></p>
<ul>
<li>git rm file 删除版本库中文件</li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>使用ssh与github远程仓库关联<br>ssh安全机制，基于密钥的安全验证：<br>创建一对密钥，公钥放在服务器</p>
<ol>
<li>客户端发送链接请求，将公钥传送给服务器</li>
<li>服务器收到密钥，与自身公钥进行比较</li>
<li>一致则使用公钥加密“质询”发送给客户端</li>
<li>客户端私钥解密，发送给服务器</li>
<li>完成登录</li>
</ol>
<ul>
<li>git remote add origin <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#109;</a>:username/repo-name.git 本地库与远程仓库做关联</li>
<li>git push -u origin master 将本地库所有内容推送到远程库中(-u 关联分支)</li>
<li>git clone url 准备好远程库，克隆到本地库</li>
</ul>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>HEAD指针指向当前分支；</p>
<ul>
<li>git checkout -b dev 创建分支(-b 并切换)：增加一个dev指针，HEAD指向dev;</li>
<li>git add . / git commit -m “des”</li>
<li>git checkout master 切换到master分支;</li>
<li>git merge dev 将dev分支合并到master上：将master指针改为dev;</li>
<li>git merge –no-ff dev 合并，不使用fast forward模式，master为新的指针</li>
</ul>
<hr>
<p><img src="/img/git-note/branch.jpg" alt="分支策略"></p>
<ul>
<li>git stash 将工作现场存储起来</li>
<li>git stash list 查看暂存列表</li>
<li>git stash pop 恢复</li>
<li>git stash apply stash@{0} 应用</li>
<li>git cherry-pick <commit> 把bug提交的修改“复制”到当前分支，避免重复劳动</li>
</ul>
<p><strong>多人协同开发：</strong></p>
<ul>
<li>git checkout -b dev origin/dev 创建远程origin的dev分支到本地</li>
<li>git branch –set-upstream-to=origin/<branch> dev 本地与远程origin/<branch>的链接</li>
</ul>
<hr>
<p><img src="/img/git-note/origin-dev.jpg" alt="多人协作"></p>
]]></content>
  </entry>
  <entry>
    <title>html</title>
    <url>/2020/03/24/html/</url>
    <content><![CDATA[<h1 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h2><p>属性：class，id，name…</p>
<h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><p>行内&gt;内部(style)&gt;外部样式优先级(link)</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;图片位置&quot; alt=&quot;无图片时的替代文字&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;th colspan=&quot;2&quot;&gt;Head&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;th&gt;Head1&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Head2&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;row1,cell1&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;row1,cell2&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;row2,cell1&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;row2,cell2&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>有序：<code>&lt;ol type=&#39;A/a/I/i/&#39;&gt;</code><br>无序：<code>&lt;ul style=&#39;list-style-type:disc/circle/square/&#39;&gt;</code><br>自定义:<code>&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;</code></p>
<h2 id="块级元素与行内元素"><a href="#块级元素与行内元素" class="headerlink" title="块级元素与行内元素"></a>块级元素与行内元素</h2><p><b>块级元素</b></p>
<ul>
<li>霸占一行，不能与其他任何元素并列</li>
<li>接受宽高，不设置则为父级元素的100%</li>
<li>div,p,h1,table</li>
</ul>
<p><b>行内元素</b></p>
<ul>
<li>与其他行内元素并列</li>
<li>不设置宽高，默认宽度为文字的宽度</li>
<li>在垂直方向的padding和margin会失效</li>
<li>img,b,a,td,span</li>
</ul>
<h2 id="HTML表单和输入"><a href="#HTML表单和输入" class="headerlink" title="HTML表单和输入"></a>HTML表单和输入</h2><h2 id="HTML框架"><a href="#HTML框架" class="headerlink" title="HTML框架"></a>HTML框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; frameborder=&quot;0&quot; name=&quot;framename&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;www.baidu.com&quot; target=&quot;&quot;&gt;Baidu&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>在浏览器窗口内显示嵌套窗口；</p>
<h2 id="HTML脚本"><a href="#HTML脚本" class="headerlink" title="HTML脚本"></a>HTML脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;定义客户端脚本；</span><br><span class="line">document.write可以直接在html输出，但是必须在html输出流中，以防覆盖整个文本；</span><br><span class="line">定义函数可触发事件响应，可处理HTML样式；</span><br><span class="line">&lt;noscript&gt;定义不支持脚本浏览器输出的文本；</span><br></pre></td></tr></table></figure>
<h2 id="HTML实体"><a href="#HTML实体" class="headerlink" title="HTML实体"></a>HTML实体</h2><p>&amp;entity_name 或 &amp;#entity_number<br>&amp;lt 或 &amp;#60<br>&amp;nbsp</p>
<h2 id="HTML-URL"><a href="#HTML-URL" class="headerlink" title="HTML URL"></a>HTML URL</h2><p>因特网服务类型：//域主机.因特网域名:port/服务器路径/资源名称<br>字符编码后通过因特网发送：ASCll字符集编码，非ASCll字符使用%后跟2位十六进制数；+表示空格；</p>
<h2 id="XHTML-正确标记，格式良好"><a href="#XHTML-正确标记，格式良好" class="headerlink" title="XHTML 正确标记，格式良好"></a>XHTML 正确标记，格式良好</h2><p><strong>结构：</strong> DOCTYPE强制；html xmlns属性规定命名空间；必须有<code>&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;body&gt;</code>;<br><strong>元素语法：</strong> 元素名小写，元素闭合，嵌套，一定有个根元素；<br><strong>属性语法：</strong> 属性名小写，属性值引号，不允许属性简写；</p>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="Canvas画布"><a href="#Canvas画布" class="headerlink" title="Canvas画布"></a>Canvas画布</h2><p><code>&lt;canvas&gt;</code><br>使用JS绘制图像：<br>c=document.getElementById(“myCanvas”);<br>创建context对象：ctx=c.getContext(“2d”);<br>绘制红色矩形：ctx.fillStyle=”#FF0000”;<br>             ctx.fillRect(0,0,150,75);<br>画线： ctx.moveTo(0,0);<br>      ctx.lineTo(200,100);<br>      ctx.stroke();<br>画圆：ctx.beginPath();<br>      ctx.arc(95,50,40,0,2*Math.PI);<br>      ctx.stroke();<br>文本：ctx.font=”30px Arial”;<br>      ctx.fillText(“Hello World”,10,50);<br>      /ctx.strokeText(“Hello World”,10,50);//空心<br>渐变： // 创建渐变<br>        var grd=ctx.createLinearGradient(0,0,200,0);/<br>        var grd=ctx.createRadialGradient(75,50,5,90,60,100);//圆渐变<br>        grd.addColorStop(0,”red”);<br>        grd.addColorStop(1,”white”);</p>
<pre><code>    // 填充渐变
    ctx.fillStyle=grd;
    ctx.fillRect(10,10,150,80);
</code></pre>
<p>图像：drawImage(image,x,y)；</p>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><p>拖放物：draggable=”true”,ondragstart(setData存放拖放物id)；<br>拖放目的地：ondragover(允许防止preventDefault)ondrop(getData获取拖放物id，加入到当前DOM中)</p>
<h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p>navigator.geolocation.getCurrentPosition(showPosition,showError);</p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;</span><br><span class="line">  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class="line">您的浏览器不支持Video标签。</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<p>方法：paused(),play()；<br>属性：width</p>
<h2 id="新的Input类型"><a href="#新的Input类型" class="headerlink" title="新的Input类型"></a>新的Input类型</h2><p>color<br>date<br>datetime<br>datetime-local<br>email<br>month<br>number<br>range<br>search<br>tel<br>time<br>url<br>week</p>
<h2 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h2><p>datalist:与input元素配合，定义选项列表；<br>keygen：用于表单密钥对生成器字段；<br>output：特殊输出计算name相同的值；</p>
<h2 id="新的表单属性"><a href="#新的表单属性" class="headerlink" title="新的表单属性"></a>新的表单属性</h2><p>form 新属性：<br>autocomplete<br>novalidate<br>input 新属性：<br>autocomplete<br>autofocus<br>form<br>formaction<br>formenctype<br>formmethod<br>formnovalidate<br>formtarget<br>height 与 width<br>list<br>min 与 max<br>multiple<br>pattern (regexp)<br>placeholder<br>required<br>step</p>
<h2 id="添加语义元素"><a href="#添加语义元素" class="headerlink" title="添加语义元素"></a>添加语义元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">&lt;nav&gt;</span><br><span class="line">&lt;section&gt;</span><br><span class="line">&lt;article&gt;</span><br><span class="line">&lt;aside&gt;</span><br><span class="line">&lt;figcaption&gt;</span><br><span class="line">&lt;figure&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<h2 id="web存储"><a href="#web存储" class="headerlink" title="web存储"></a>web存储</h2><p><strong>localStorage</strong> - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。<br><strong>sessionStorage</strong> - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。<br>setItem(key,value);<br>getItem(key);<br>removeItem(key);<br>clear();<br>key(index);<br>length;</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>TCP协议；<br>两次握手：客户端发送包含建立websocket的HTTP请求头，服务端解析请求头，往回发送应答信息，则建立websocket连接；<br>双方可通过该连接通道自由传递信息；<br>直到一方主动关闭；<br>websocket属性：readyState,bufferedAmount;<br>webSocket事件：onopen,onmessage,onerror,onclose;<br>webSocket方法：send(),close();</p>
]]></content>
  </entry>
  <entry>
    <title>javascript</title>
    <url>/2020/05/07/javascript/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2020/04/14/vue/</url>
    <content><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p><strong>v-html</strong>:用于输出html代码；<br><strong>v-bind</strong>:绑定属性，用以响应更新属性值；<br>    1. 样式class————v-bind:class={‘class1’:use}/v-bind:class=’activeClassName’];<br>    2. 样式id；<br>    3. href；<br>    4. 内联样式；<br><strong>v-if</strong>、<strong>v-else</strong>、<strong>v-else-if</strong>；<br><strong>v-model</strong>：双向数据绑定，view绑定model值，model监听view变化；<br><strong>v-on</strong>：事件处理器；<br><strong>v-show</strong>：根据条件展示元素；<br><strong>v-for</strong>：循环迭代对象、整数；</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><p><strong>与methods区别</strong>：methods在页面重新渲染时运行，computed依赖缓存，只有相关依赖值发生变化时重新获取；<br>可设置set函数，在获得值时设置其他值；get函数得到值的格式；</p>
<h2 id="监听属性watch"><a href="#监听属性watch" class="headerlink" title="监听属性watch"></a>监听属性watch</h2><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>全局组件：Vue.component(‘tagName’,options)；<br>局部组件：components:{<br>            ‘tagName’:componentName<br>        }<br>组件间传值：父-&gt;子：props属性设置；<br>           子-&gt;父：自定义事件;<br>                   在子组件中定义childMethod，其中调用this.$emit(‘toParent’);<br>                   在父组件中模板v-on绑定toParent方法；<br>                   即能实现在子组件中调用方法时，父组件能够接收到消息；</p>
<h2 id="directives注册指令"><a href="#directives注册指令" class="headerlink" title="directives注册指令"></a>directives注册指令</h2><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>定义路由组件；</li>
<li>定义路由；</li>
<li>创建router实例；</li>
<li>创建和挂载；<h2 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h2></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>小点</title>
    <url>/2020/09/09/%E5%B0%8F%E7%82%B9/</url>
    <content><![CDATA[<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>用法：不重复、自动排序的集合；<br>my_set.insert(sth); // 插入<br>my_set.find(sth) == my_set.end(); // 判断在集合中不存在S</p>
<h1 id="拓扑建图"><a href="#拓扑建图" class="headerlink" title="拓扑建图"></a>拓扑建图</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> struct GraphNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;GraphNode*&gt; courses;</span><br><span class="line">    GraphNode(int x) : val(x) &#123;&#125; // 构造函数</span><br><span class="line">&#125;;</span><br><span class="line">// vector&lt;GraphNode*&gt; graph;</span><br></pre></td></tr></table></figure>
<h1 id="vector作栈"><a href="#vector作栈" class="headerlink" title="vector作栈"></a>vector作栈</h1><p>vec.push_back(x);<br>vec[vec.size() - 1]; // vec.back() (首部元素引用可用 vec.front())<br>vec.pop_back();<br>*max_element(vec.begin(), vec.end()); // 求数组中的最大值</p>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>priority_queue<int> q; // 大顶堆 从大到小降序<br>priority_queue&lt;int, vector<int>, greater<int> &gt; q; // 小顶堆 从小到大升序<br>priority_queue&lt;pair&lt;int, int&gt; &gt; q; // pair中先比较第1个降序 再比较第2个降序<br>如果要遍历的话，只能够pop push<br>访问队首元素 q.top()</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>无序 没有重复的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;int&gt; num_set;</span><br><span class="line">for (const int&amp; num : nums) &#123; // 去重</span><br><span class="line">    num_set.insert(num);</span><br><span class="line">&#125;</span><br><span class="line">num_set.count(num - 1) // 判断集合中是否存在</span><br></pre></td></tr></table></figure>

<h1 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h1><p>75：荷兰国旗问题</p>
<h1 id="9-24"><a href="#9-24" class="headerlink" title="9.24"></a>9.24</h1><p>146：优先队列、双向链表<br>169：投票算法</p>
<h1 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h1><p>152：动态规划<br>215：随机快排、堆排序<br>234：反转链表</p>
<h1 id="9-27"><a href="#9-27" class="headerlink" title="9.27"></a>9.27</h1><p>动态规划简单题</p>
<h1 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h1><p>贪心简单题（模拟）  </p>
<h1 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h1><p>秋叶收藏集 叶子 dp<br>739 单调栈</p>
<h1 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h1><p>647 马拉车算法[<a href="https://www.jianshu.com/p/392172762e55]">https://www.jianshu.com/p/392172762e55]</a></p>
<h1 id="10-19"><a href="#10-19" class="headerlink" title="10.19"></a>10.19</h1><p>239 滑动窗口最大值<br>单调栈 动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 双向队列</span><br><span class="line">ArrayDeque&lt;Integer&gt;deq;</span><br><span class="line">deq.isEmpty();</span><br><span class="line">deq.getLast();</span><br><span class="line">deq.getFirst();</span><br><span class="line">deq.addLast();</span><br><span class="line">deq.removeLast();</span><br></pre></td></tr></table></figure>
<h1 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h1><p>84 柱状图中的最大矩形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 栈</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack();</span><br><span class="line">stack.empty();</span><br><span class="line">stack.peek();</span><br><span class="line">stack.push(new Integer(i));</span><br></pre></td></tr></table></figure>
<h1 id="10-26"><a href="#10-26" class="headerlink" title="10.26"></a>10.26</h1><p>回溯 有点不懂</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">StringBuilder s;</span><br><span class="line">s.add(); // 可改变大小</span><br><span class="line">hashSet 哈希表</span><br><span class="line">append()</span><br></pre></td></tr></table></figure>
<h1 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h1><p>二叉树序列化与反序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java 队列</span><br><span class="line">Queue&lt;String&gt; q = new LinkedList&lt;String&gt;(); </span><br><span class="line">q.offer(&quot;a&quot;); // add</span><br><span class="line">q.poll(); // remove抛出异常 poll返回null</span><br><span class="line">q.peek(); // 第一个元素q.element()</span><br><span class="line">for(String s:q) // 遍历</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>css</title>
    <url>/2019/11/23/css/</url>
    <content><![CDATA[<h1 id="css：层叠样式表"><a href="#css：层叠样式表" class="headerlink" title="css：层叠样式表"></a>css：层叠样式表</h1><p>定义如何显示HTML元素；</p>
<h2 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h2><p>(!important覆盖任何声明)<br>内联样式1000<br>id选择器100<br>伪类选择器<br>属性选择器<br>class类选择器10<br>元素选择器1<br>通用选择器*</p>
<h2 id="链接样式"><a href="#链接样式" class="headerlink" title="链接样式"></a>链接样式</h2><p>a.link-未访问过正常链接；<br>a.visited-访问过后的链接；<br>a.hover-鼠标悬浮；<br>a.active-鼠标点击；<br><strong>注意：</strong><br>a:hover 必须跟在 a:link 和 a:visited后面<br>a:active 必须跟在 a:hover后面</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>用于封装html元素，由内到外分为content、padding、border、margin四部分；<br><strong>标准盒子模型：</strong> width仅为content宽度大小；<br>总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距<br>总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距<br><strong>IE盒子模型：</strong> width为内容、内边距和边框的宽度的总和；</p>
<h2 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h2><p>visible、hidden、scroll、auto、inherit；</p>
<h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h2><p>后代选择器：(div p)div的所有后代p元素；<br>子元素选择器：(div&gt;p)div后的直接子元素p;<br>相邻兄弟选择器：(div+p)在div之后与div相邻的p兄弟元素；<br>后续兄弟选择器：(div~p)在div之后的所有p兄弟元素；</p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p><strong>anchor:</strong> visited,link…;<br><strong>first-child:</strong><br>  p&gt;i:first-child p元素的直接后代i子元素，必须是第一个；<br>  p:first-child i 作为第一个p元素的所有后代i元素；<br><strong>lang伪类：</strong><br>q:lang(no) {quotes: “<del>“ “</del>“;} 为lang属性名为“no”的q元素定义引号类型；</p>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>first-letter<br>first-line<br>before<br>after</p>
<h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><p><strong>竖直导航栏：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    width: 25%;</span><br><span class="line">    background-color: #f1f1f1;</span><br><span class="line">    position: fixed;</span><br><span class="line">    height: 100%;</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li a &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    color: #000;</span><br><span class="line">    padding: 8px 16px;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li a.active &#123;</span><br><span class="line">    background-color: #4CAF50;</span><br><span class="line">    color: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li a:hover:not(.active) &#123;</span><br><span class="line">    background-color: #555;</span><br><span class="line">    color: white;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;margin-left:25%;padding:1px 16px;height:1000px;&quot;&gt;</span><br><span class="line">  &lt;h2&gt;Fixed Full-height Side Nav&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;Try to scroll this area, and see how the sidenav sticks to the page&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;Notice that this div element has a left margin of 25%. This is because the side navigation is set to 25% width. If you remove the margin, the sidenav will overlay/sit on top of this div.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Also notice that we have set overflow:auto to sidenav. This will add a scrollbar when the sidenav is too long (for example if it has over 50 links inside of it).&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some text..&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some text..&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some text..&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some text..&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some text..&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some text..&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some text..&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>水平导航栏：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body &#123;margin:0;&#125;</span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background-color: #333;</span><br><span class="line">    position: fixed;</span><br><span class="line">	top:0;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li &#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li a &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    color: white;</span><br><span class="line">    text-align: center;</span><br><span class="line">    padding: 14px 16px;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li a:hover:not(.active) &#123;</span><br><span class="line">    background-color: #111;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.active &#123;</span><br><span class="line">    background-color: #4CAF50;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;padding:20px;margin-top:30px;background-color:#1abc9c;height:1500px;&quot;&gt;</span><br><span class="line">&lt;h1&gt;Fixed Top Navigation Bar&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;Scroll this page to see the effect&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;The navigation bar will stay at the top of the page while scrolling&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Some text some text some text some text..&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>下拉菜单：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;下拉菜单实例|菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  ul&#123;</span><br><span class="line">    list-style-type:none;</span><br><span class="line">    margin:0;</span><br><span class="line">    padding:0;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">    background-color:#333;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  li&#123;</span><br><span class="line">    float:left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  li a, .dropbtn</span><br><span class="line">  &#123;</span><br><span class="line">    display:inline-block;</span><br><span class="line">    color:white;</span><br><span class="line">    text-align:center;</span><br><span class="line">    padding:14px 16px;</span><br><span class="line">    text-decoration:none;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  li a:hover, .dropdown:hover, .dropbtn</span><br><span class="line">  &#123;</span><br><span class="line">    background-color:#111;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .dropdown</span><br><span class="line">  &#123;</span><br><span class="line">    display:inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .dropdown-content</span><br><span class="line">  &#123;</span><br><span class="line">    display:none;</span><br><span class="line">    position:absolute;</span><br><span class="line">    background-color:#f9f9f9;</span><br><span class="line">    min-width:160px;</span><br><span class="line">    box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .dropdown-content a</span><br><span class="line">  &#123;</span><br><span class="line">    color:black;</span><br><span class="line">    padding:12px 16px;</span><br><span class="line">    text-decoration:none;</span><br><span class="line">    display:block;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .dropdown-content a:hover &#123;background-color: #f1f1f1&#125;</span><br><span class="line">  </span><br><span class="line">  .dropdown:hover .dropdown-content</span><br><span class="line">  &#123;</span><br><span class="line">    display:block;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;div class=&quot;dropdown&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot; class=&quot;dropbtn&quot;&gt;下拉菜单&lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-content&quot;&gt;</span><br><span class="line">      &lt;a href=&quot;#&quot;&gt;链接 1&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;#&quot;&gt;链接 2&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;#&quot;&gt;链接 3&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;导航栏上的下拉菜单&lt;/h3&gt;</span><br><span class="line">&lt;p&gt;鼠标移动到 &quot;下拉菜单&quot; 链接先显示下拉菜单。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="悬浮提示框"><a href="#悬浮提示框" class="headerlink" title="悬浮提示框"></a>悬浮提示框</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.tooltip &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    border-bottom: 1px dotted black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tooltip .tooltiptext &#123;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">    width: 120px;</span><br><span class="line">    background-color: black;</span><br><span class="line">    color: #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding: 5px 0;</span><br><span class="line"></span><br><span class="line">    /* 定位 */</span><br><span class="line">    position: absolute;</span><br><span class="line">    z-index: 1;</span><br><span class="line">    /* 居中上/下方</span><br><span class="line">    left:50%;</span><br><span class="line">    margin-left:-60px;</span><br><span class="line">    bottom:100%;</span><br><span class="line">    // top:100%;</span><br><span class="line">    */</span><br><span class="line">    /*居中左右方</span><br><span class="line">    left:105%;</span><br><span class="line">    //right:105%;</span><br><span class="line">    top:-5px;//padding值</span><br><span class="line">    */</span><br><span class="line">    /*初始位置</span><br><span class="line">    top:50%:</span><br><span class="line">    left:50%;</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tooltip:hover .tooltiptext &#123;</span><br><span class="line">    visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body style=&quot;text-align:center;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;tooltip&quot;&gt;鼠标移动到这</span><br><span class="line">  &lt;span class=&quot;tooltiptext&quot;&gt;提示文本&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="图片廊"><a href="#图片廊" class="headerlink" title="图片廊"></a>图片廊</h2><ol>
<li>div.img类设置width，并且向左浮动(div盒子的宽度设置);</li>
<li>img标签中引入图片大小设置(在下一步存在的情况下没啥用);</li>
<li>div.img img设置标签内宽度width=100%，height=auto，表示图片适应div大小显示；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;  </span><br><span class="line">&lt;style&gt;</span><br><span class="line">div.img &#123;</span><br><span class="line">    margin: 5px;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 180px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.img:hover &#123;</span><br><span class="line">    border: 1px solid #777;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.img img &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.desc &#123;</span><br><span class="line">    padding: 15px;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;responsive&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;img&quot;&gt;</span><br><span class="line">    &lt;a target=&quot;_blank&quot; href=&quot;//static.runoob.com/images/demo/demo1.jpg&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;//static.runoob.com/images/demo/demo1.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div class=&quot;responsive&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;img&quot;&gt;</span><br><span class="line">    &lt;a target=&quot;_blank&quot; href=&quot;//static.runoob.com/images/demo/demo2.jpg&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;//static.runoob.com/images/demo/demo2.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div class=&quot;responsive&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;img&quot;&gt;</span><br><span class="line">    &lt;a target=&quot;_blank&quot; href=&quot;//static.runoob.com/images/demo/demo3.jpg&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;//static.runoob.com/images/demo/demo3.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div class=&quot;responsive&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;img&quot;&gt;</span><br><span class="line">    &lt;a target=&quot;_blank&quot; href=&quot;//static.runoob.com/images/demo/demo4.jpg&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;//static.runoob.com/images/demo/demo4.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="图像拼合-导航列表"><a href="#图像拼合-导航列表" class="headerlink" title="图像拼合 导航列表"></a>图像拼合 导航列表</h2>设置背景位置，使用同一张图片的不同部分；<br>img标签src引入透明图片，在img类中定义background，引入图片url，定义初始位置；</li>
</ol>
<p><strong>导航：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;  </span><br><span class="line">&lt;style&gt;</span><br><span class="line">#navlist&#123;position:relative;&#125;</span><br><span class="line">#navlist li&#123;margin:0;padding:0;list-style:none;position:absolute;top:0;&#125;</span><br><span class="line">#navlist li, #navlist a&#123;height:44px;display:block;&#125;</span><br><span class="line"></span><br><span class="line">#home&#123;left:0px;width:46px;&#125;</span><br><span class="line">#home&#123;background:url(&#x27;/images/img_navsprites.gif&#x27;) 0 0;&#125;</span><br><span class="line"></span><br><span class="line">#prev&#123;left:63px;width:43px;&#125;</span><br><span class="line">#prev&#123;background:url(&#x27;/images/img_navsprites.gif&#x27;) -47px 0;&#125;</span><br><span class="line"></span><br><span class="line">#next&#123;left:129px;width:43px;&#125;</span><br><span class="line">#next&#123;background:url(&#x27;/images/img_navsprites.gif&#x27;) -91px 0;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul id=&quot;navlist&quot;&gt;</span><br><span class="line">  &lt;li id=&quot;home&quot;&gt;&lt;a href=&quot;/&quot;&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;prev&quot;&gt;&lt;a href=&quot;/css/&quot;&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;next&quot;&gt;&lt;a href=&quot;/css/&quot;&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>选取具有特定属性名的HTML元素<br>[title=abc] title与abc相等；<br>[title~=abc] title中包含abc单词；<br>[title|=abc] title以abc开头，或有“-”连接，必须唯一；<br>[title*=abc] title中可拆分出abc单词；<br>[title$=abc] title以abc为结尾；</p>
<h2 id="表单渲染"><a href="#表单渲染" class="headerlink" title="表单渲染"></a>表单渲染</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">input[type=text], select &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  padding: 12px 20px;</span><br><span class="line">  margin: 8px 0;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  box-sizing: border-box; </span><br><span class="line">  //确保浏览器呈现出带有指定宽度和高度的输入框是把边框和内边距一起计算进去的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input[type=submit] &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background-color: #4CAF50;</span><br><span class="line">  color: white;</span><br><span class="line">  padding: 14px 20px;</span><br><span class="line">  margin: 8px 0;</span><br><span class="line">  border: none;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input[type=submit]:hover &#123;</span><br><span class="line">  background-color: #45a049;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  background-color: #f2f2f2;</span><br><span class="line">  padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;使用 CSS 来渲染 HTML 的表单元素&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;form action=&quot;/action_page.php&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;fname&quot;&gt;First Name&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;fname&quot; name=&quot;firstname&quot; placeholder=&quot;Your name..&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;label for=&quot;lname&quot;&gt;Last Name&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;lname&quot; name=&quot;lastname&quot; placeholder=&quot;Your last name..&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;label for=&quot;country&quot;&gt;Country&lt;/label&gt;</span><br><span class="line">    &lt;select id=&quot;country&quot; name=&quot;country&quot;&gt;</span><br><span class="line">      &lt;option value=&quot;australia&quot;&gt;Australia&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;canada&quot;&gt;Canada&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;usa&quot;&gt;USA&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>一般background-color都只包括padding以内的部分，而body为最外层框架，包括了margin，设置margin的时候是内部的margin？</strong></p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body&#123; // 父级</span><br><span class="line">  counter-reset:section;</span><br><span class="line">&#125;</span><br><span class="line">h2:before &#123; //在标题前插入计数</span><br><span class="line">  counter-increment:section; //命名成组</span><br><span class="line">  content: &quot;Section &quot; counter(section) &quot;: &quot;; // 计数内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><p><strong>border-radius 圆角半径:</strong><br>4个值：从左上角开始顺时针；<br>3个值：左上角 右上角和左下角 右下角；<br>2个值：左上和右下 右上和左下；<br>椭圆角：长半径/短半径；<br><strong>box-shadow 边框阴影:</strong><br>(阴影框距离原div的左相对距离 上相对距离 透明度 颜色)<br><strong>border-image 边框背景:</strong><br>url() 缩放程度(数值越小图案越大) round/stretch</p>
<h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p><strong>background-image 背景图片：</strong><br>url(),url();<br><strong>background-size 背景大小：</strong><br>100% 100%; 全覆盖<br><strong>background-origin 背景定位覆盖区域：</strong><br>content-box;padding-box;border-box;<br><strong>background-position 背景图片位置：</strong><br>left bottom;<br><strong>background-clip 背景裁剪属性：</strong><br>content-box;padding-box;border-box;</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p><strong>background-image:</strong><br><strong>linear-gradient 线性渐变</strong><br>linear-gradient(to derection,color1,color2); // 角度<br>linear-gradient(0-360deg,color1,color2); // 方向<br>linear-gradient(to derection,rgba(255,0,0,0),rgba(255,0,0,1)) // 0-1 完全透明-不透明<br><strong>radial-gradient 径向渐变</strong><br>radial-gradient (circle/ellipse, color1, color2, color3);</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>text-shadow:水平阴影 垂直阴影 模糊距离 阴影颜色；<br>box-shadow 可叠加；<br>text-overflow:clip/ellipsis; 文本溢出表现形式…/直接裁剪;<br>word-wrap:break-word; 强制文本换行;<br>word-break:keep-all/break-all; 单词拆分；</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>@font-face<br>{<br>  font-family:font-name;<br>  src:url();<br>  font-weight:bold;<br>  …<br>}</p>
<h2 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h2><p><strong>transform:</strong><br>rotate(angle) : 绕中心点旋转angle角度；<br>translate(x,y) : 沿着x和y轴移动元素；<br>scale(x,y) : 宽度高度缩放x,y倍；<br>skew(x-angle,y-angle) : 绕x轴，y轴倾斜角度；<br>matrix() 旋转，缩放，移动（平移）和倾斜</p>
<h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><p><strong>transform:</strong><br>rotateX(angle) : 绕x轴朝页面内旋转度数；<br>rotateY(angle) : 绕y轴朝页面内旋转度数；<br>…</p>
<h2 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h2><p>transition:变化属性1 时间1，变化属性2 时间2；<br>div 与 div:hover 需定义变化属性1 变化属性2</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>@keyframes animation-name{<br>  from {} //0%<br>  to {} //100%<br>}<br>在元素上定义animation属性：animation-name 时间；</p>
<h2 id="多列属性"><a href="#多列属性" class="headerlink" title="多列属性"></a>多列属性</h2><p>将div内的内容分为多列；<br>column-count:列数；<br>column-gap：列间隙；<br>column-rule-*：width style color 两列间边框样式；<br>column-span：指定样式跨多少行(1|all)；<br>cloumn-width：指定列宽；</p>
<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><p>resize:both;<br>overflow:auto; // 用户可自定义元素大小<br>box-sizing:border-box;<br>outline:2px solid red;<br>outline-offset:15px; // 外形修饰</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>对img标签进行css设置：<br><strong>缩略图：</strong><br>border: 1px solid #ddd; // 加边框<br>border-radius: 4px; // 边框圆角<br>padding: 5px;<br><strong>圆角图片：</strong><br>border-radius: 5%; // 图片圆角<br><strong>响应式图片：</strong><br>img {<br>    max-width: 100%;<br>    height: auto;<br>}</p>
<h2 id="按钮动画"><a href="#按钮动画" class="headerlink" title="按钮动画"></a>按钮动画</h2><p><strong>波纹：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.button:after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    background: #90EE90;</span><br><span class="line">    display: block;</span><br><span class="line">    position: absolute;</span><br><span class="line">    padding-top: 300%;</span><br><span class="line">    padding-left: 350%;</span><br><span class="line">    margin-left: -20px!important;</span><br><span class="line">    margin-top: -120%;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transition: all 0.8s // 设置buttom:after的动画时限是0.8s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button:active:after &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">    opacity: 1;</span><br><span class="line">    transition: 0s // 将buttom:active:after的动画时限设为0，即直接变换到当前状态；</span><br><span class="line">                   // 当active消失，再以0.8的时限返回原始状态；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h2><p>display:flex | -webkit-flex;<br><strong>flex-direction: row|row-reverse|column|column-reverse 排列方向（自适应）：</strong><br>设为row则限制width在flex容器内，不限制height;<br>设为column则限制height在flex容器内，不限制width;<br><strong>justify-content: flex-start|flex-end|center|space-between|space-around 内容沿排列主轴线的对齐方法：</strong><br>紧挨头，尾，居中，平均分割头尾不留间隔，头尾留相同间隔；<br><strong>align-items: flex-start|flex-end|center|baseline|stretch 弹性元素沿纵轴线的对齐方法：</strong><br>baseline基线：除特殊情况外与flex-start相同；<br>当弹性元素高度不受限制时，默认为stretch，与容器大小近似；<br>当flex-direction设为列排列时，主轴为竖直方向，则纵轴为水平；<br><strong>flex-wrap: nowrap|wrap|wrap-reverse 是否换行：</strong><br>默认nowrap不换行；<br><strong>align-content: flex-start | flex-end | center | space-between | space-around | stretch 各行沿纵轴线的对齐方法</strong><br><strong>弹性子元素属性：</strong><br>order：用int值来定义排列顺序，从小到大‘<br>margin:auto自动获取弹性容器中剩余空间，可居中；<br>align-self:弹性元素自身的algin-items属性；<br>flex：int值用于指定弹性子元素如何分配空间；</p>
<hr>
<p>以下记录在CSS中老混淆的属性；</p>
<h1 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h1><p>position主要有4个值：static,fixed,relative,absolute;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line">...</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">Hello World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;ok&lt;div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>默认属性，表示没有定位，出现在正常流中，忽略top,bottom,left,right的影响;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.wrap</span><br><span class="line">&#123;</span><br><span class="line">height: 200px;width: 200px;background-color: #ddd;</span><br><span class="line">&#125;</span><br><span class="line">.content</span><br><span class="line">&#123;</span><br><span class="line">height: 80px;width: 80px;background-color:yellow;left:20px;position:static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../public/img/css/position-static.jpg" alt="static"></p>
<h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p>以浏览器窗口为父参考元素，脱离文档流，不会随着浏览器窗口的滚动而滚动，不占据空间，会覆盖其他元素；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.wrap</span><br><span class="line">&#123;</span><br><span class="line">height: 200px;width: 200px;background-color: #ddd;</span><br><span class="line">&#125;</span><br><span class="line">.content</span><br><span class="line">&#123;</span><br><span class="line">height: 80px;width: 80px;background-color:yellow;top:20px;left:20px;position:fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/css/position-fixed.jpg" alt="fixed"></p>
<h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><p>以自身在static情况下的标准位置为参考，top,bottom,left,right为-值则往相应方向移动，例如top为-向上，bottom为-向下，没有脱离文档流,仍占据原来的空间，会覆盖其他元素；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.wrap</span><br><span class="line">&#123;</span><br><span class="line">height: 200px;width: 200px;background-color: #ddd;</span><br><span class="line">&#125;</span><br><span class="line">.content</span><br><span class="line">&#123;</span><br><span class="line">height: 80px;width: 80px;background-color:yellow;left:-20px;top:20px;position:relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/css/position-relative.jpg" alt="relative"></p>
<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><p>以最近的父结点为父参考元素（最外层参考html），相对定位，脱离文档流,会覆盖其他元素；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.wrap</span><br><span class="line">&#123;</span><br><span class="line">height: 200px;width: 200px;background-color: #ddd;left:20px;top:20px;position:absolute</span><br><span class="line">&#125;</span><br><span class="line">.content</span><br><span class="line">&#123;</span><br><span class="line">height: 80px;width: 80px;background-color:yellow;left:10px;top:10px;position:absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/css/position-absolute.jpg" alt="absolute"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>fixed,absolute脱离文档流;除默认static外都会覆盖其他元素；</p>
<h1 id="display"><a href="#display" class="headerlink" title="display"></a>display</h1><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><ul>
<li>弹性布局，用盒状模型提供最大的灵活性；Webkit内核浏览器为-webkit-flex;</li>
<li>有main axis主轴与cross axis交叉轴；</li>
<li>flex的6个属性：<br>flex-direction:主轴方向，即排列方向；<br>flex-wrap:如果一条轴线排列不下，如何换行；<br>flex-flow:(flex-direction)||(flex-wrap)<br>justify-content:项目在主轴上的对齐方式；<br>align-items:项目在交叉轴上的对其方式；<br>align-content:多根轴线的对齐方式；</li>
<li>项目的6个属性：<br>order：排列顺序;<br>flex-grow：相对于其他灵活的项目的放大比例,0;<br>flex-shrink:相对于其他的灵活项目的缩小比例,1；<br>flex-basis:项目的长度，在分配多余空间占据的主轴空间，auto；<br>flex:auto,none;<br>flex 属性是 flex-grow、flex-shrink 和 flex-basis;<br>align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性;<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2></li>
</ul>
<hr>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>float：left|right|none<br>浮动溢出：元素设置float属性则脱离了文档流，父级元素不能随float元素扩展，导致元素溢出到容器外；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.news &#123;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.left &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.right&#123;</span><br><span class="line">  float: right;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;span class=&quot;left&quot;&gt;left text&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;right&quot;&gt;right text&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/img/css/float.jpg" alt="float"></p>
<h2 id="加一个空白的clear元素"><a href="#加一个空白的clear元素" class="headerlink" title="加一个空白的clear元素"></a>加一个空白的clear元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// style加入</span><br><span class="line">.clear&#123;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line">// div class=“news”中加入子元素</span><br><span class="line">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>优点：简单，兼容性好；缺点：无用元素；</p>
<h2 id="父级元素自身设置float"><a href="#父级元素自身设置float" class="headerlink" title="父级元素自身设置float"></a>父级元素自身设置float</h2><p>可消除内部浮动，但是会破坏整体布局，不推荐；</p>
<h2 id="父级元素设置属性overflow-hidden"><a href="#父级元素设置属性overflow-hidden" class="headerlink" title="父级元素设置属性overflow:hidden"></a>父级元素设置属性overflow:hidden</h2><p>将父级元素设置为BFC 会将内部float的盒子高度计算进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.news &#123;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">  border: solid 1px black;</span><br><span class="line">  overflow:hidden;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用邻接元素处理"><a href="#使用邻接元素处理" class="headerlink" title="使用邻接元素处理"></a>使用邻接元素处理</h2><p>在邻接元素的样式加入clear:both；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;news&quot;&gt;</span><br><span class="line">&lt;span class=&quot;left&quot;&gt;left text&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;right&quot;&gt;right text&lt;/span&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="加入伪类-after"><a href="#加入伪类-after" class="headerlink" title="加入伪类:after"></a>加入伪类:after</h2><p>在父元素末尾加入一个看不见的块元素;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// style加入</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">  content: &quot;020&quot;; </span><br><span class="line">  display: block; </span><br><span class="line">  height: 0; </span><br><span class="line">  clear: both; </span><br><span class="line">  visibility: hidden;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&lt;div class=&quot;news clearfix&quot;&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="实现元素的垂直居中"><a href="#实现元素的垂直居中" class="headerlink" title="实现元素的垂直居中"></a>实现元素的垂直居中</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;index&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html, body &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">			background-color:yellow;</span><br><span class="line">			padding:0;</span><br><span class="line">			margin:0;</span><br><span class="line">        &#125;</span><br><span class="line">        .content &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">			border:2px solid black;</span><br><span class="line">            background-color: orange;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/img/css/cross-center.jpg" alt="cross-center"></p>
<h2 id="父元素display设置为flex布局"><a href="#父元素display设置为flex布局" class="headerlink" title="父元素display设置为flex布局"></a>父元素display设置为flex布局</h2><p>align-items:center表示交叉轴上的项目居中显示；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">            background-color:yellow;</span><br><span class="line">            padding:0;</span><br><span class="line">            margin:0;</span><br><span class="line">            display:flex;</span><br><span class="line">            align-items:center;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="将该元素绝对定位"><a href="#将该元素绝对定位" class="headerlink" title="将该元素绝对定位"></a>将该元素绝对定位</h2><p>margin-top设置的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            border:2px solid black;</span><br><span class="line">            background-color: orange;</span><br><span class="line">            margin:0 auto;</span><br><span class="line">            position:relative;</span><br><span class="line">            top:50%;</span><br><span class="line">            margin-top:-150px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用transform-translateY-50"><a href="#使用transform-translateY-50" class="headerlink" title="使用transform: translateY(-50%)"></a>使用transform: translateY(-50%)</h2><h2 id="与上面方法类似，仅仅将margin-top方法改成translateY，意思是上移自身高度的一半；"><a href="#与上面方法类似，仅仅将margin-top方法改成translateY，意思是上移自身高度的一半；" class="headerlink" title="与上面方法类似，仅仅将margin-top方法改成translateY，意思是上移自身高度的一半；"></a>与上面方法类似，仅仅将margin-top方法改成translateY，意思是上移自身高度的一半；</h2><h2 id="html，body设置height为100-，margin-0-padding-0"><a href="#html，body设置height为100-，margin-0-padding-0" class="headerlink" title="html，body设置height为100%，margin:0,padding:0"></a>html，body设置height为100%，margin:0,padding:0</h2><p>css元素width若未设置，自动分配浏览器最大宽度，而height是由内容元素撑起的，此时父元素的高度依赖于子元素的高度；而当高度设置为百分比，则依赖于父元素，向上查找定高，如中途有一个高度未设置，或者为auto，则该元素的height百分比无效；设置最高层html，body的height为100%，即获取浏览器定高，后面的子元素也就有了依赖。</p>
<hr>
<h2 id="css外边距合并"><a href="#css外边距合并" class="headerlink" title="css外边距合并"></a>css外边距合并</h2><p><a href="https://www.w3school.com.cn/css/css_margin_collapsing.asp">外边距合并</a><br>垂直方向上，外部div未设置border或padding，使margin与内div的margin之间没有界限，因此合并选取较大的。</p>
<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>是一个JavaScript库，可用以选取与操作HTML元素，css操作，DOM的遍历和修改；</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>元素，id，.class,属性….；<br>$(“p”),$(“#idname”),$(“.classname”),$(“[href]”)….</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>鼠标：click,dbclick,mouseenter,mouseleave,hover;<br>键盘：keypress,keydown,keyup;<br>表单：submit,change,focus,blur;<br>文档/窗口事件：load,resize,scroll,upload;</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><strong>隐藏/显示：</strong>hide(),show(),toggle();<br><strong>淡入/淡出：</strong>fadeIn(),fadeOut(),fadeToggle(),fadeTo();<br><strong>滑动：</strong>slideDown(),slideUp(),slideToggle();<br><strong>动画：</strong>animate({params},speed,callback);<br><strong>停止动画</strong>：stop(stopAll,goToEnd)，默认(false,false)<br>stopAll=true表示清除动画队列，直接停止，再次点击开始则从当前位置开始；<br>            为false则会完成队列中下一个动画；<br>goToEnd=true表示完成当前动画到结尾，<br>            为false则停止不动；</p>
<h2 id="与HTML相关"><a href="#与HTML相关" class="headerlink" title="与HTML相关"></a>与HTML相关</h2><p>可获取和设置以下值：<br>text()文本内容；<br>html()元素HTML标记；<br>val()表单字段；<br>attr()属性值；<br><strong>添加元素：</strong><br>append()<br>prepend()所选元素内增加子元素；<br>after()<br>before()所选元素前后添加子元素；<br><strong>删除元素：</strong><br>remove()移除所选元素（包括该元素的子元素）；<br>empty()删除所选元素的所有子元素；<br><strong>css操作：</strong><br>addClass()<br>removeClass()<br>toggleClass()增加/删除某样式类；<br>css()设置或获取某样式属性值；</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><strong>祖先：</strong><br>parent()直接父元素；<br>parents()所有祖先元素；<br>parentUntil()介于某孩子到某祖先间的所有元素（不包括本身）；<br><strong>后代：</strong><br>children()直接子元素；<br>find()所有后代元素；<br><strong>同胞：</strong><br>siblings()所有同胞；<br>next()下一个同胞；<br>nextAll()接下来的所有同胞；<br>nextUntil()介于某个元素到另一个元素之间的所有同胞元素；</p>
]]></content>
  </entry>
  <entry>
    <title>2020暑假刷题笔记</title>
    <url>/2020/08/01/2020%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="一-leetcode-113-路径总和2"><a href="#一-leetcode-113-路径总和2" class="headerlink" title="一. leetcode 113 路径总和2"></a>一. <a href="https://leetcode-cn.com/problems/path-sum-ii/">leetcode 113 路径总和2</a></h2><p><strong>前序遍历：</strong></p>
<ol>
<li>先处理当前结点（将该结点push到路径数组中，并且累加其结点值）；</li>
<li>再进行下一步的遍历；</li>
<li>完成当前结点的遍历后，回溯（将该结点pop出路径数组，并且更新结点值和）。<br>一般代码结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void preOrder(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; path, int sum, int cur_sum) &#123;</span><br><span class="line">        if (root == NULL) return;</span><br><span class="line">        path.push_back(root-&gt;val); // 更新路径</span><br><span class="line">        cur_sum += root-&gt;val; // 更新当前和</span><br><span class="line">        // 当前和与要求和相同，并且为叶子结点</span><br><span class="line">        if (cur_sum == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        preOrder(root-&gt;left, result, path, sum, cur_sum);</span><br><span class="line">        preOrder(root-&gt;right, result, path, sum, cur_sum);</span><br><span class="line">        // 左右子树都遍历完成后，在路径中删除当前值</span><br><span class="line">        path.pop_back();</span><br><span class="line">        cur_sum -= root-&gt;val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-leetcode-236-二叉树的最近公共祖先"><a href="#二-leetcode-236-二叉树的最近公共祖先" class="headerlink" title="二. leetcode 236 二叉树的最近公共祖先"></a>二. <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode 236 二叉树的最近公共祖先</a></h2></li>
<li>分别以题目给出的两个结点为目标，对二叉树进行前序遍历，直到找到该目标，并且记录路径；</li>
<li>从头到尾对比两个路径，遇到的最后一个相同的即为最近公共祖先。</li>
</ol>
<h2 id="三-leetcode-114-二叉树展开为链表"><a href="#三-leetcode-114-二叉树展开为链表" class="headerlink" title="三. leetcode 114 二叉树展开为链表"></a>三. <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">leetcode 114 二叉树展开为链表</a></h2><p>递归主要讨论的是左子树与右子树都拉直后的连接过程，忽略具体拉直过程，每个递归返回的有用信息是该树右子树的最后一个结点指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void preOrder(TreeNode* node, TreeNode* &amp;last) &#123;</span><br><span class="line">        if (!node) return;</span><br><span class="line">        // 判断该结点是否为叶子结点</span><br><span class="line">        // 是则为该子树的最后一个结点</span><br><span class="line">        // 返回</span><br><span class="line">        if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">            last = node;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = node-&gt;left;</span><br><span class="line">        TreeNode* right = node-&gt;right;</span><br><span class="line">        TreeNode* left_last = NULL;</span><br><span class="line">        TreeNode* right_last = NULL; // 左右子树的最后一个结点</span><br><span class="line">        // 前序遍历左子树</span><br><span class="line">        if (left) &#123;</span><br><span class="line">            preOrder(left, left_last);</span><br><span class="line">            node-&gt;left = NULL;</span><br><span class="line">            node-&gt;right = left;</span><br><span class="line">            last = left_last;</span><br><span class="line">        &#125;</span><br><span class="line">        // 前序遍历右子树</span><br><span class="line">        if (right) &#123;</span><br><span class="line">            preOrder(right, right_last);</span><br><span class="line">            if (left_last) // 没有该判断 报错！last没有初始化，为空</span><br><span class="line">                last-&gt;right = right;</span><br><span class="line">            last = right_last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        TreeNode * last;</span><br><span class="line">        preOrder(root, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="一-leetcode-199-二叉树的右视图"><a href="#一-leetcode-199-二叉树的右视图" class="headerlink" title="一. leetcode 199 二叉树的右视图"></a>一. <a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/submissions/">leetcode 199 二叉树的右视图</a></h2><p>图的宽度搜索（BFS）：</p>
<ol>
<li>使用队列queue，pair存储结点与层数；</li>
<li>将当前结点的左右结点分别push到队列中，同时记录层数；</li>
<li>按先进先出的顺序访问结点；</li>
<li>不断更新该层的最后一个结点；</li>
<li>得到结果数组。<br>一般代码结构为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans; // 按层遍历的最后一个结点</span><br><span class="line">        queue&lt;pair&lt;TreeNode*, int&gt; &gt; myQueue;</span><br><span class="line">        if (!root)return ans;</span><br><span class="line">        myQueue.push(make_pair(root, 0));</span><br><span class="line">        while (!myQueue.empty()) &#123;</span><br><span class="line">            TreeNode* cur_node = myQueue.front().first;</span><br><span class="line">            int cur_depth = myQueue.front().second;</span><br><span class="line">            myQueue.pop();</span><br><span class="line">            if (ans.size() == cur_depth) &#123; // 首次遇到在cur_depth层的结点 将结点值push到数组中</span><br><span class="line">                ans.push_back(cur_node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // 更新ans[cur_depth]的值</span><br><span class="line">                ans[cur_depth] = cur_node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur_node-&gt;left) &#123; // 存在左子树</span><br><span class="line">                myQueue.push(make_pair(cur_node-&gt;left, cur_depth + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur_node-&gt;right) &#123; // 存在左子树</span><br><span class="line">                myQueue.push(make_pair(cur_node-&gt;right, cur_depth + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二-leetcode-207-课程表"><a href="#二-leetcode-207-课程表" class="headerlink" title="二. leetcode 207 课程表"></a>二. <a href="https://leetcode-cn.com/problems/course-schedule/">leetcode 207 课程表</a></h2><p>两种方法：</p>
<ol>
<li>DFS遍历过程中，没有重复访问正在访问的结点（即存在从该结点返回到初始位置的路径）。<br>DFS的一般代码结构:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool DFS(GraphNode *node, vector&lt;int&gt; &amp;visit) &#123;</span><br><span class="line">       // 标记当前结点值正在访问</span><br><span class="line">       visit[node-&gt;label] = 0; </span><br><span class="line">       // 访问器邻接结点</span><br><span class="line">       for (int i = 0; i &lt; node-&gt;neighbors.size(); i++) &#123;</span><br><span class="line">           // 当前结点未被访问则继续深度遍历</span><br><span class="line">           if (visit[node-&gt;neighbors[i]-&gt;label] == -1) &#123;</span><br><span class="line">               if (!DFS(node-&gt;neighbors[i], visit))</span><br><span class="line">                   return false;</span><br><span class="line">           &#125;</span><br><span class="line">           // 当前结点出现环:访问正在访问的结点</span><br><span class="line">           else if (visit[node-&gt;neighbors[i]-&gt;label] == 0) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        // 标记当前结点值访问过</span><br><span class="line">       visit[node-&gt;label] = 1;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>BFS遍历后，无环：所有入度减少为0；有环：存在不为0的入度。</li>
</ol>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="一-leetcode-35-搜索插入位置"><a href="#一-leetcode-35-搜索插入位置" class="headerlink" title="一. leetcode 35 搜索插入位置"></a>一. <a href="https://leetcode-cn.com/problems/search-insert-position/">leetcode 35 搜索插入位置</a></h2><p>标准二分查找法(重点：分析出未找到target值时，插入位置索引总是begin);<br>一般模板:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int begin = 0, end = nums.size() - 1;</span><br><span class="line">        int mid = 0;</span><br><span class="line">        while (begin &lt;= end) &#123;</span><br><span class="line">            mid = (begin + end) / 2;</span><br><span class="line">            if (target &lt; nums[mid]) &#123;</span><br><span class="line">                end = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (target &gt; nums[mid]) &#123;</span><br><span class="line">                begin = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#二、leetcode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="二、leetcode 34 在排序数组中查找元素的第一个和最后一个位置"></a>二、<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode 34 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>分别找左右边界，二分查找加入相等的处理判断;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 找左边界</span><br><span class="line">        while (begin &lt;= end) &#123;</span><br><span class="line">            mid = (begin + end) / 2;</span><br><span class="line">            // 前半部分</span><br><span class="line">            if (nums[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 后半部分</span><br><span class="line">            else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                begin = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 相等的情况</span><br><span class="line">            // 左边界要么就是mid，要么在前半部分</span><br><span class="line">            else &#123;</span><br><span class="line">                // mid为左边界</span><br><span class="line">                if (mid == 0 || nums[mid - 1] &lt; target) &#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 前半部分还有target值，继续二分查找</span><br><span class="line">                else &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、leetcode-33-搜索旋转排序数组"><a href="#三、leetcode-33-搜索旋转排序数组" class="headerlink" title="三、leetcode 33 搜索旋转排序数组"></a>三、<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">leetcode 33 搜索旋转排序数组</a></h2><p>有点窒息的分类,二分查找的框架，每种情况都要清晰地讨论。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int begin = 0, end = nums.size() - 1;</span><br><span class="line">        int mid = 0;</span><br><span class="line">        while (begin &lt;= end) &#123;</span><br><span class="line">            mid = (begin + end ) / 2;</span><br><span class="line">            // 目标小于中间值</span><br><span class="line">            if (target &lt; nums[mid]) &#123;</span><br><span class="line">                // 前半部分为顺序区间，后半部分为旋转区间</span><br><span class="line">                if (nums[begin] &lt;= nums[mid]) &#123; // 注意！！等号表示mid与begin值相同时</span><br><span class="line">                    // 在顺序区间中找</span><br><span class="line">                    // 顺序区间内的最小值&lt;=target，则在顺序区间中找</span><br><span class="line">                    if (nums[begin] &lt;= target) end = mid - 1;</span><br><span class="line">                    // 在旋转区间中找</span><br><span class="line">                    else &#123;</span><br><span class="line">                        begin = mid + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 后半部分为顺序区间，前半部分为旋转区间</span><br><span class="line">                // 后半部分所有值都大于nums[mid] 即大于target</span><br><span class="line">                // target一定在前半部分</span><br><span class="line">                else &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 目标大于中间值</span><br><span class="line">            else if (target &gt; nums[mid]) &#123;</span><br><span class="line">                // 前半部分为顺序区间，后半部分为旋转区间</span><br><span class="line">                // 前半部分所有值都小于nums[mid] 即小于target</span><br><span class="line">                // target一定在后半部分</span><br><span class="line">                if (nums[begin] &lt; nums[mid]) &#123;</span><br><span class="line">                    begin = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                // 后半部分为顺序区间，前半部分为旋转区间</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 在旋转区间中找</span><br><span class="line">                    // nums[end]是顺序区间中最大元素</span><br><span class="line">                    // 该最大元素都比target小的话</span><br><span class="line">                    // 则直接在旋转区间中找</span><br><span class="line">                    if (nums[end] &lt; target) end = mid - 1;</span><br><span class="line">                    // 否则在该顺序区间中找</span><br><span class="line">                    else &#123;</span><br><span class="line">                        begin = mid + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>插入结点代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void BST_insert(TreeNode* root, TreeNode* insert_node) &#123;</span><br><span class="line">        if (root-&gt;val &gt; insert_node-&gt;val) &#123;</span><br><span class="line">            if (root-&gt;left) BST_insert(root-&gt;left, insert_node);</span><br><span class="line">            else root-&gt;left = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (root-&gt;right) BST_insert(root-&gt;right, insert_node);</span><br><span class="line">            else root-&gt;right = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查找结点代码</p>
<h2 id="一、leetcode-449-序列化和反序列化二叉搜索树"><a href="#一、leetcode-449-序列化和反序列化二叉搜索树" class="headerlink" title="一、leetcode 449 序列化和反序列化二叉搜索树"></a>一、<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">leetcode 449 序列化和反序列化二叉搜索树</a></h2><h2 id="二、leetcode-315-计算右侧小于当前元素的个数"><a href="#二、leetcode-315-计算右侧小于当前元素的个数" class="headerlink" title="二、leetcode 315 计算右侧小于当前元素的个数"></a>二、<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">leetcode 315 计算右侧小于当前元素的个数</a></h2><p>在插入的过程中计算小于当前结点值的结点数,不是获取当前结点的count_small值（记录的是整棵树中小于当前结点的值，而不是在插入他之前）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 计算右侧小于当前元素的个数</span><br><span class="line">    // 反转数组</span><br><span class="line">    // 将问题转换为：计算左侧小于当前元素的个数</span><br><span class="line">    // 建立二叉搜索树,在建立的过程中，记录</span><br><span class="line">    struct TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode *left;</span><br><span class="line">        TreeNode *right;</span><br><span class="line">        int count_small;</span><br><span class="line">        TreeNode(int x) : val(x), left(NULL), right(NULL), count_small(0) &#123;&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">    </span><br><span class="line">    void BST_insert(TreeNode* node, TreeNode* insert_node, int &amp; count) &#123;</span><br><span class="line">        if (node-&gt;val &gt;= insert_node-&gt;val) &#123;</span><br><span class="line">            node-&gt;count_small++;</span><br><span class="line">            if (node-&gt;left) BST_insert(node-&gt;left, insert_node, count);</span><br><span class="line">            else node-&gt;left = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            count += node-&gt;count_small + 1;</span><br><span class="line">            if (node-&gt;right) BST_insert(node-&gt;right, insert_node, count);</span><br><span class="line">            else node-&gt;right = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if (nums.size() == 0) return ans;</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        TreeNode* root = new TreeNode(nums[0]);</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            TreeNode * newNode =  new TreeNode(nums[i]);</span><br><span class="line">            int count_small = 0;</span><br><span class="line">            BST_insert(root, newNode, count_small);</span><br><span class="line">            ans.push_back(count_small);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="一、-leetcode-409-最长回文串"><a href="#一、-leetcode-409-最长回文串" class="headerlink" title="一、 leetcode 409 最长回文串"></a>一、 <a href="https://leetcode-cn.com/problems/longest-palindrome/">leetcode 409 最长回文串</a></h2><ol>
<li>哈希表存放字符串s中各个不同的字母出现的次数；</li>
<li>遍历哈希表,根据出现次数的偶数/奇数，结合回文串的性质，得出最长回文串。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestPalindrome(string s) &#123;</span><br><span class="line">        map&lt;char, int&gt; mp;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            mp[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;char, int&gt;::iterator it;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        for (it = mp.begin(); it != mp.end(); it++) &#123;</span><br><span class="line">            if (it-&gt;second % 2 == 0) &#123; // 该字母出现次数为偶数次</span><br><span class="line">                sum += it-&gt;second; // 可构成回文</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // 该字母出现次数为奇数次</span><br><span class="line">                if (flag) &#123; // 已存在中间值</span><br><span class="line">                    sum += it-&gt;second - 1; // 除掉中间值外 其他可构成回文</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    sum += it-&gt;second;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、leetcode-290-单词规律"><a href="#二、leetcode-290-单词规律" class="headerlink" title="二、leetcode 290 单词规律"></a>二、<a href="https://leetcode-cn.com/problems/word-pattern/">leetcode 290 单词规律</a></h2><p>分析字符串与模式字母的正确匹配情况与错误情况：</p>
<ol>
<li>map&lt;string, char&gt; mp; // 存储字符串对应的模式字母<br>bool used[128] = {0}; // 标记模式字母是否出现过</li>
<li>模式字母未出现过：当前字符串却曾经出现过，则有字符串对应了多个模式字母，错误；<br>模式字母出现过：当前字符串不曾出现，或者当前字符串不对应相应模式字母，错误；</li>
</ol>
<h2 id="三、leetcode-49-字母异位词分组"><a href="#三、leetcode-49-字母异位词分组" class="headerlink" title="三、leetcode 49 字母异位词分组"></a>三、<a href="https://leetcode-cn.com/problems/group-anagrams/">leetcode 49 字母异位词分组</a></h2><ol>
<li>map&lt;string, int&gt; mp; // 哈希表：基础字符串，对应在结果中的索引<br>vector&lt;vector<string> &gt; res; // 结果数组</li>
<li>字符串排序,作为map的key.</li>
</ol>
<h2 id="四、leetcode-3-无重复字符的最长子串"><a href="#四、leetcode-3-无重复字符的最长子串" class="headerlink" title="四、leetcode 3 无重复字符的最长子串"></a>四、<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">leetcode 3 无重复字符的最长子串</a></h2><p>滑动窗口法：</p>
<ol>
<li>确定左边界，遍历右边界，数组存储字母在该窗口中是否出现过；</li>
<li>当遍历过程中遇到出现过的字母，则右移左边界，直到找到该字母的位置;</li>
<li>当遍历过程中遇到出现过的字母，更新最大无重复子串长度。<h2 id="五、leetcode-187-重复的DNA序列"><a href="#五、leetcode-187-重复的DNA序列" class="headerlink" title="五、leetcode 187 重复的DNA序列"></a>五、<a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">leetcode 187 重复的DNA序列</a></h2>ACGT四种情况，即二进制两位数可表示这4种不同的字母；<br>不同的DNA序列可转化为对应不同的二进制数;<br>使用哈希表存储出现的次数。<h2 id="六、leetcode-76-最小覆盖子串"><a href="#六、leetcode-76-最小覆盖子串" class="headerlink" title="六、leetcode 76 最小覆盖子串"></a>六、<a href="https://leetcode-cn.com/problems/minimum-window-substring/">leetcode 76 最小覆盖子串</a></h2>滑动窗口法+哈希表:<br>根据条件更新左边界：当前S窗口s_map[begin_str] &lt; T字符串中的t_map[begin_str]；或出现T字符串中没有的字母；<br>遍历右边界，在每次遍历完成后，判断该窗口是否符合要求。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool is_window_ok(int x[], int y[], vector&lt;int&gt; vec) &#123;</span><br><span class="line">        for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            if (x[vec[i]] &gt; y[vec[i]]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        int t_map[128] = &#123;0&#125;; // 记录t字符串中各字母出现的次数</span><br><span class="line">        int s_map[128] = &#123;0&#125;; // 记录s字符串窗口中各字母出现的次数</span><br><span class="line">        vector&lt;int&gt; charvec; // 记录t中出现过的字母</span><br><span class="line">        for (int i = 0; i &lt; t.length(); i++) &#123;</span><br><span class="line">            if (t_map[t[i]] == 0) charvec.push_back(t[i]);</span><br><span class="line">            t_map[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int begini = 0; // 窗口左边界</span><br><span class="line">        int min_len = s.length() + 1; // 结果字符串长度</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        // 遍历右边界</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            s_map[s[i]]++;</span><br><span class="line">            while (begini &lt; i) &#123;</span><br><span class="line">                if (t_map[s[begini]] == 0) &#123; // 窗口首字母在t字符串中不存在</span><br><span class="line">                    begini++;</span><br><span class="line">                &#125;// 窗口首字母在窗口字符串中出现次数&gt;在t字符串出现次数</span><br><span class="line">                else if (s_map[s[begini]] &gt; t_map[s[begini]]) &#123;</span><br><span class="line">                    s_map[s[begini]]--;</span><br><span class="line">                    begini++;</span><br><span class="line">                &#125;</span><br><span class="line">                else break;</span><br><span class="line">            &#125;</span><br><span class="line">            // cout&lt;&lt;s.substr(begini, i - begini + 1)&lt;&lt;endl;</span><br><span class="line">            if (is_window_ok(t_map, s_map, charvec)) &#123;</span><br><span class="line">                int cur_len = i - begini + 1;</span><br><span class="line">                if (res == &quot;&quot; || cur_len &lt; min_len) &#123;</span><br><span class="line">                    min_len = cur_len;</span><br><span class="line">                    res = s.substr(begini, cur_len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="一、-leetcode-78-子集"><a href="#一、-leetcode-78-子集" class="headerlink" title="一、 leetcode 78 子集"></a>一、 <a href="https://leetcode-cn.com/problems/subsets/">leetcode 78 子集</a></h2>不考虑递归过程，直接根据结果来实现程序。<br>求子集：</li>
<li>考虑当前元素是否应该加到子集中：加或不加，分别递归；</li>
<li>递归结束条件是：index&gt;=nums.size()。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void generate (int i, vector&lt;int&gt; nums, vector&lt;int&gt; items, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123;</span><br><span class="line">        if (i &gt;= nums.size()) &#123; // 当索引超出nums边界</span><br><span class="line">            res.push_back(items);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        items.push_back(nums[i]); // 当前子集选择nums[i]</span><br><span class="line">        generate (i + 1, nums, items, res); // 进行下一步递归</span><br><span class="line">        items.pop_back(); // 当前子集不选择nums[i]</span><br><span class="line">        generate (i + 1, nums, items, res); // 进行下一步递归</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        vector&lt;int&gt; items;</span><br><span class="line">        generate (0, nums, items, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-90-子集-II"><a href="#二、leetcode-90-子集-II" class="headerlink" title="二、leetcode 90 子集 II"></a>二、<a href="https://leetcode-cn.com/problems/subsets-ii/">leetcode 90 子集 II</a></h2>先对nums排序，使用set&lt;vector<int>&gt;对一致的子集去重。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (res_set.find(items) == res_set.end()) &#123;</span><br><span class="line">                res.push_back(items);</span><br><span class="line">                res_set.insert(items);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、leetcode-40-组合总和-II"><a href="#三、leetcode-40-组合总和-II" class="headerlink" title="三、leetcode 40 组合总和 II"></a>三、<a href="https://leetcode-cn.com/problems/combination-sum-ii/">leetcode 40 组合总和 II</a></h2>典型的递归题：</li>
<li>以开始位置start索引遍历候选数组，当当前索引未加入到路径中，并且加入候选值不会大于target值，则选择该索引位置的值，并进行下一步的递归；</li>
<li>递归结束条件是path值==target值，并且当前path首次出现(排序 set约束)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 递归函数</span><br><span class="line">    // 候选数组，开始位置，目标数值，结果数组，当前子集</span><br><span class="line">    void backtracking(vector&lt;int&gt; candidates, int start, int target, vector&lt;vector&lt;int&gt; &gt;&amp; res, vector&lt;int&gt;&amp; path, bool help[], set&lt;vector&lt;int&gt; &gt;&amp; res_set) &#123;</span><br><span class="line">        // 达到目标</span><br><span class="line">        if ( target == 0 &amp;&amp; res_set.find(path) == res_set.end()) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            res_set.insert(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; candidates.size() &amp;&amp; target-candidates[i] &gt;= 0; i++)&#123;</span><br><span class="line">            // 满足条件：当前值未使用 并且 子集和仍然小于target</span><br><span class="line">            if (!help[i] &amp;&amp; target - candidates[i] &gt;= 0) &#123;</span><br><span class="line">                path.push_back(candidates[i]); // 将当前值放入子集中</span><br><span class="line">                help[i] = true;</span><br><span class="line">                backtracking(candidates, i+1, target - candidates[i], res, path, help, res_set);</span><br><span class="line">                path.pop_back(); // 取出该值，进行新一轮选择</span><br><span class="line">                help[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    sort(candidates.begin(),candidates.end()); // 将数组排序</span><br><span class="line">    backtracking(candidates, 0, target, res, path, help, res_set);</span><br><span class="line">    */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四、leetcode-22-括号生成"><a href="#四、leetcode-22-括号生成" class="headerlink" title="四、leetcode 22. 括号生成"></a>四、<a href="https://leetcode-cn.com/problems/generate-parentheses/">leetcode 22. 括号生成</a></h2>典型递归题：<br>给出n对左右括号的合理摆放顺序。</li>
<li>每一步有2种选择：’(‘或’)’，对两种选择分别进行下一步递归；</li>
<li>递归结束条件为：目标字符串长度到达2*n；</li>
<li>剪枝：去除不必要的递归步骤：只有n个左括号与n个右括号，超出的直接不做处理；左括号数不大于右括号数的，不可再选择’)’。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void generate(string item, int left, int right, vector&lt;string&gt;&amp; res) &#123;</span><br><span class="line">        if (left == 0 &amp;&amp; right == 0) &#123; // 当字符串成功放置n个左括号与n个右括号</span><br><span class="line">            res.push_back(item);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &gt; 0) // 当左括号尚未完成</span><br><span class="line">            generate(item + &#x27;(&#x27;, left - 1, right, res);</span><br><span class="line">        if (left &lt; right) // 当左括号数&gt;右括号数</span><br><span class="line">            generate(item + &#x27;)&#x27;, left, right - 1, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        generate(&quot;&quot;, n, n, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="五、leetcode-51-N皇后"><a href="#五、leetcode-51-N皇后" class="headerlink" title="五、leetcode 51. N皇后"></a>五、<a href="https://leetcode-cn.com/problems/n-queens/">leetcode 51. N皇后</a></h2>N皇后问题，典型的递归回溯法：<br>关键点在于在递归之前，对当前mark标记数组与location结果状态的保存，以便在回溯阶段对状态进行复原，以进行下一步的递归。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dir[8][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, // 上下左右</span><br><span class="line">                    &#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;; // 左上 右上 左下 右下</span><br><span class="line">    // 在(x,y)位置放置queue</span><br><span class="line">    // 在(x,y)位置的八个方向延伸出去 都标志为-1 表示不可放置queue</span><br><span class="line">    void put_down_the_queue(int x, int y, vector&lt;vector&lt;int&gt; &gt;&amp; mark) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; mark.size(); j++) &#123;</span><br><span class="line">                int index_x = x + dir[i][0] * j;</span><br><span class="line">                int index_y = y + dir[i][1] * j;</span><br><span class="line">                if (index_x &lt; 0 || index_x &gt;= mark.size()) continue;</span><br><span class="line">                if (index_y &lt; 0 || index_y &gt;= mark[0].size()) continue;</span><br><span class="line">                mark[index_x][index_y] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递归函数</span><br><span class="line">    // k：完成k个皇后的放置</span><br><span class="line">    // n：共n个皇后</span><br><span class="line">    // location：当前摆放结果</span><br><span class="line">    // res：最终结果</span><br><span class="line">    // mark：标记数组</span><br><span class="line">    void generate(int k, int n, vector&lt;string&gt;&amp; location, vector&lt;vector&lt;string&gt; &gt;&amp; res, vector&lt;vector&lt;int&gt; &gt;&amp; mark) &#123;</span><br><span class="line">        if (k == n) &#123;</span><br><span class="line">            res.push_back(location);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (mark[k][i] == 0) &#123;</span><br><span class="line">                vector&lt;vector&lt;int&gt; &gt; temp_mark = mark; // 存储当前的mark数组(在递归过程中会改变)</span><br><span class="line">                put_down_the_queue(k, i, mark);</span><br><span class="line">                location[k][i] = &#x27;Q&#x27;;</span><br><span class="line">                generate(k + 1, n, location, res, mark); // 递归</span><br><span class="line">                mark = temp_mark; // 返回原本mark数组</span><br><span class="line">                location[k][i] = &#x27;.&#x27;;  // 返回原本的location</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; res; // 存储最终结果</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; mark; // 标记棋盘是否可以放置皇后的二维数组</span><br><span class="line">        vector&lt;string&gt; location; // 存储某个摆放结果</span><br><span class="line">        // 初始化</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            mark.push_back((vector&lt;int&gt;()));</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                mark[i].push_back(0);</span><br><span class="line">            &#125;</span><br><span class="line">            location.push_back(&quot;&quot;);</span><br><span class="line">            location[i].append(n, &#x27;.&#x27;); // location初始化为n个&quot;.&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        generate(0, n, location, res, mark);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="六、leetcode-315-计算右侧小于当前元素的个数"><a href="#六、leetcode-315-计算右侧小于当前元素的个数" class="headerlink" title="六、leetcode 315 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">六、leetcode 315 计算右侧小于当前元素的个数</a></h2>归并排序思想：<br>在merge两个子数组的同时，更新counts数组：<br>当插入前半部分区间值sub_vec1[x]时，表示后半部分 y之前的所有值都已放置在vec中，<br>则证明y之前都小于sub_vec1[x],因此对应值索引位置更新+y。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge_two_vec(vector&lt;pair&lt;int, int&gt; &gt; sub_vec1, vector&lt;pair&lt;int, int&gt; &gt; sub_vec2, vector&lt;pair&lt;int, int&gt; &gt;&amp; vec, vector&lt;int&gt;&amp; ans) &#123;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        while (x &lt; sub_vec1.size() &amp;&amp; y &lt; sub_vec2.size()) &#123;</span><br><span class="line">            // 此时插入前半部分区间值sub_vec1[x]</span><br><span class="line">            // y之前的所有值都已放置在vec中</span><br><span class="line">            // 证明都小于sub_vec1[x]</span><br><span class="line">            // 因此更新+y</span><br><span class="line">            if (sub_vec1[x].first &lt;= sub_vec2[y].first) &#123;</span><br><span class="line">                ans[sub_vec1[x].second] += y; // 对应索引位置更新</span><br><span class="line">                vec.push_back(sub_vec1[x]);</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 此时插入后半部分区间值sub_vec2[x]</span><br><span class="line">            else &#123;</span><br><span class="line">                vec.push_back(sub_vec2[y]);</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理剩余元素</span><br><span class="line">        while (x &lt; sub_vec1.size()) &#123;</span><br><span class="line">            ans[sub_vec1[x].second] += y; // 对应索引位置更新</span><br><span class="line">            vec.push_back(sub_vec1[x]);</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (y &lt; sub_vec2.size()) &#123;</span><br><span class="line">            vec.push_back(sub_vec2[y]);</span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void merge_sort(vector&lt;pair&lt;int, int&gt; &gt;&amp; vec, vector&lt;int&gt;&amp; ans) &#123;</span><br><span class="line">        if (vec.size() &lt; 2) return; // 当拆分后的数组大小&lt;=1，则直接返回</span><br><span class="line">        // 拆分为2个数组</span><br><span class="line">        int mid = vec.size() / 2;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; sub_vec1;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; sub_vec2;</span><br><span class="line">        for (int i = 0; i &lt; mid; i++) &#123;</span><br><span class="line">            sub_vec1.push_back(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = mid; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            sub_vec2.push_back(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        merge_sort(sub_vec1, ans);</span><br><span class="line">        merge_sort(sub_vec2, ans);</span><br><span class="line">        vec.clear(); // 清空 以存放归并后的数组</span><br><span class="line">        merge_two_vec(sub_vec1, sub_vec2, vec, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if (nums.size() == 0) return ans;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; vec;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            ans.push_back(0); // 初始化结果数组</span><br><span class="line">            vec.push_back(make_pair(nums[i], i)); // 存储nums[i]与对应索引i</span><br><span class="line">        &#125;</span><br><span class="line">        merge_sort(vec, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="一、-leetcode-200-岛屿数量"><a href="#一、-leetcode-200-岛屿数量" class="headerlink" title="一、 leetcode 200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">一、 leetcode 200. 岛屿数量</a></h2>基础DFS解法:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// DFS找到从（x,y）出发连接的&#x27;1&#x27;，即一个岛屿</span><br><span class="line">void DFS(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt; &gt;&amp; seen, int x, int y) &#123;</span><br><span class="line">    seen[x][y] = 1;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int next_x = x + dirs[i][0];</span><br><span class="line">        int next_y = y + dirs[i][1];</span><br><span class="line">        // 超出边界</span><br><span class="line">        if (next_x &lt; 0 || next_x &gt;= grid.size() || next_y &lt; 0 || next_y &gt;= grid[0].size()) </span><br><span class="line">            continue;</span><br><span class="line">        // 已访问过</span><br><span class="line">        if (seen[next_x][next_y]) continue;</span><br><span class="line">        // 是岛屿 继续DFS</span><br><span class="line">        if (grid[next_x][next_y] == &#x27;1&#x27;) &#123;</span><br><span class="line">            DFS(grid, seen, next_x, next_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
基础BFS解法:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// BFS找到从（x,y）出发连接的&#x27;1&#x27;，即一个岛屿</span><br><span class="line">    void BFS(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt; &gt;&amp; seen, int x, int y) &#123;</span><br><span class="line">    queue&lt;pair&lt;int, int&gt; &gt; mq;</span><br><span class="line">    mq.push(make_pair(x, y));</span><br><span class="line">    seen[x][y] = 1; // 入队标志</span><br><span class="line">    while (!mq.empty()) &#123;</span><br><span class="line">        int cur_x = mq.front().first;</span><br><span class="line">        int cur_y = mq.front().second;</span><br><span class="line">        mq.pop();</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int next_x = cur_x + dirs[i][0];</span><br><span class="line">            int next_y = cur_y + dirs[i][1];</span><br><span class="line">            // 超出边界</span><br><span class="line">            if (next_x &lt; 0 || next_x &gt;= grid.size() || next_y &lt; 0 || next_y &gt;= grid[0].size()) </span><br><span class="line">                continue;</span><br><span class="line">            // 是岛屿 继续DFS</span><br><span class="line">            if (!seen[next_x][next_y] &amp;&amp; grid[next_x][next_y] == &#x27;1&#x27;) &#123;</span><br><span class="line">                mq.push(make_pair(next_x, next_y)); // 入队</span><br><span class="line">                seen[next_x][next_y] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-127-单词接龙"><a href="#二、leetcode-127-单词接龙" class="headerlink" title="二、leetcode 127. 单词接龙"></a>二、<a href="https://leetcode-cn.com/problems/word-ladder/">leetcode 127. 单词接龙</a></h2></li>
<li>建立图关系：差一个字母的单词有关系；</li>
<li>BFS<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 建立单词间关系图：相差一个字母的单词为一组</span><br><span class="line">    void construct_graph(map&lt;string, vector&lt;string&gt; &gt;&amp; graph, vector&lt;string&gt;&amp; wordList, int len) &#123;</span><br><span class="line">        // 初始化graph</span><br><span class="line">        for (int i = 0; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                string temp = wordList[i];</span><br><span class="line">                temp[j] = &#x27;*&#x27;; // 替换为‘*’,作为key</span><br><span class="line">                if (graph.count(temp) == 0) &#123;</span><br><span class="line">                    vector&lt;string&gt; vec;</span><br><span class="line">                    vec.push_back(wordList[i]);</span><br><span class="line">                    graph[temp] = vec;</span><br><span class="line">                &#125;</span><br><span class="line">                else graph[temp].push_back(wordList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        int len = beginWord.length();</span><br><span class="line">        map&lt;string, vector&lt;string&gt; &gt; graph; // 单词，相差一个字母的其他单词表</span><br><span class="line">        wordList.push_back(beginWord); // 也需考虑beginWord</span><br><span class="line">        construct_graph(graph, wordList, len);</span><br><span class="line">        // 进行BFS</span><br><span class="line">        queue&lt;pair&lt;string, int&gt; &gt; q; // 队列(单词，当前步数)</span><br><span class="line">        set&lt;string&gt; visit; // 是否访问过</span><br><span class="line">        q.push(make_pair(beginWord, 1));</span><br><span class="line">        visit.insert(beginWord);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            string cur_s = q.front().first;</span><br><span class="line">            int cur_step = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            if (cur_s == endWord) &#123;</span><br><span class="line">                return cur_step;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123; // 替换每个字母为&#x27;*&#x27;, 都存在路径</span><br><span class="line">                string temp_s = cur_s;</span><br><span class="line">                temp_s[i] = &#x27;*&#x27;;</span><br><span class="line">                vector&lt;string&gt; neighbors = graph[temp_s];</span><br><span class="line">                for (int j = 0; j &lt; neighbors.size(); j++) &#123;</span><br><span class="line">                    if (visit.find(neighbors[j]) == visit.end()) &#123;</span><br><span class="line">                        q.push(make_pair(neighbors[j], cur_step + 1));</span><br><span class="line">                        visit.insert(neighbors[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="升级leetcode-126-单词接龙-II"><a href="#升级leetcode-126-单词接龙-II" class="headerlink" title="升级leetcode 126. 单词接龙 II"></a>升级<a href="https://leetcode-cn.com/problems/word-ladder-ii/">leetcode 126. 单词接龙 II</a></h3>记录单词接龙的路径：</li>
<li>使用vector<Qitem>作为BFS数组，建立Qitem数据结构，同时存储(word, step, parent_pos);</li>
<li>map&lt;string, int&gt; visit 记录到某单词的最短路径;</li>
</ol>
<h2 id="三、leetcode-473-火柴拼正方形"><a href="#三、leetcode-473-火柴拼正方形" class="headerlink" title="三、leetcode 473. 火柴拼正方形"></a>三、<a href="https://leetcode-cn.com/problems/matchsticks-to-square/">leetcode 473. 火柴拼正方形</a></h2><p>DFS会超时，可使用二进制法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() &lt; 4) return false; // 个数不足4</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 4 != 0) return false; // 和不为4的倍数</span><br><span class="line">        int target = sum / 4;</span><br><span class="line">        vector&lt;int&gt; ok_subset;</span><br><span class="line">        vector&lt;int&gt; ok_half;</span><br><span class="line">        int all = 1 &lt;&lt; nums.size();</span><br><span class="line">        for (int i = 0; i &lt; all; i++) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = 0; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                if (i &amp; (1 &lt;&lt; j)) &#123; // i代表的集合中存在第j个元素</span><br><span class="line">                    sum += nums[j]; // 求该集合的和</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sum == target) ok_subset.push_back(i); // 和 = target，保存i集合</span><br><span class="line">        &#125;</span><br><span class="line">        // 使4条边两两结合</span><br><span class="line">        for (int i = 0; i &lt; ok_subset.size(); i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; ok_subset.size(); j++) &#123;</span><br><span class="line">                if ((ok_subset[i] &amp; ok_subset[j]) == 0) &#123; // 子集中存在的值不重合</span><br><span class="line">                    ok_half.push_back((ok_subset[i] | ok_subset[j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 使两部分两两结合 组成正方形</span><br><span class="line">        for (int i = 0; i &lt; ok_half.size(); i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; ok_half.size(); j++) &#123;</span><br><span class="line">                if ((ok_half[i] &amp; ok_half[j]) == 0) &#123; // 子集中存在的值不重合</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="一、leetcode-70-爬楼梯"><a href="#一、leetcode-70-爬楼梯" class="headerlink" title="一、leetcode 70. 爬楼梯"></a>一、<a href="https://leetcode-cn.com/problems/climbing-stairs/">leetcode 70. 爬楼梯</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        // dp状态数组：dp[i]表示到达i级阶梯有多少方法</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        // 初始化</span><br><span class="line">        dp[0] = 1; // 爬一个台阶</span><br><span class="line">        dp[1] = 2; // 爬2个台阶或分别爬1个台阶</span><br><span class="line">        // 状态转移</span><br><span class="line">        // dp[i]的值为dp[i - 1]再爬1个 + dp[i - 2]爬2个</span><br><span class="line">        for (int i = 2; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - 2] + dp[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-198-打家劫舍"><a href="#二、leetcode-198-打家劫舍" class="headerlink" title="二、leetcode 198. 打家劫舍"></a>二、<a href="https://leetcode-cn.com/problems/house-robber/">leetcode 198. 打家劫舍</a></h2><p>dp[i]表示 <strong>[0, i]范围内</strong>的最高金额;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return 0;</span><br><span class="line">        if (nums.size() == 1) return nums[0];</span><br><span class="line">        // dp状态数组</span><br><span class="line">        // dp[i]表示[0, i]的最高金额</span><br><span class="line">        vector&lt;int&gt; dp(nums.size());</span><br><span class="line">        // 初始化</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        // 状态转移</span><br><span class="line">        // i-1被偷，则不能偷i</span><br><span class="line">        // i-2被偷，可以偷i</span><br><span class="line">        for (int i = 2; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[nums.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三-leetcode-53-最大子序和"><a href="#三-leetcode-53-最大子序和" class="headerlink" title="三 leetcode 53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">三 leetcode 53. 最大子序和</a></h2><p>dp[i]:<strong>以nums[i]为结尾</strong>的最大子序和;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return 0;</span><br><span class="line">        // dp状态数组</span><br><span class="line">        // dp[i]:以nums[i]为结尾的最大子序和</span><br><span class="line">        vector&lt;int&gt; dp(nums.size());</span><br><span class="line">        // 初始化</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int res = dp[0];</span><br><span class="line">        // 状态转移</span><br><span class="line">        // dp[i]的值是以i-1为结尾的最大子序和+当前nums[i] 或者 以当前nums[i]开头</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 1] + nums[i], nums[i]);</span><br><span class="line">            if (res &lt; dp[i]) &#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四、leetcode-322-零钱兑换"><a href="#四、leetcode-322-零钱兑换" class="headerlink" title="四、leetcode 322. 零钱兑换"></a>四、<a href="https://leetcode-cn.com/problems/coin-change/">leetcode 322. 零钱兑换</a></h2><p>dp[i]:i元时需要的最少硬币数</p>
<h2 id="五、120-三角形最小路径和"><a href="#五、120-三角形最小路径和" class="headerlink" title="五、120. 三角形最小路径和"></a>五、<a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h2><p><strong>自底向上</strong>；<br>triangle直接作为状态数组，triangle[i][j]表示从底部到当前位置的最短路径长度；<br>状态转移方程为triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);<br>最终结果为triangle[0][0].</p>
<h2 id="六、300-最长上升子序列"><a href="#六、300-最长上升子序列" class="headerlink" title="六、300. 最长上升子序列"></a>六、<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></h2><p>dp[i]:<strong>以nums[i]为结尾</strong>的最长上升子序列，结尾需要遍历dp，得出最大长度.</p>
<h2 id="七、64-最小路径和"><a href="#七、64-最小路径和" class="headerlink" title="七、64. 最小路径和"></a>七、<a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h2><p><strong>自底向上</strong>；<br>grid[i][j]只可能从右侧或者下方回来，<br>状态转移方程：grid[i][j] += min(grid[i][j + 1], grid[i + 1][j]);</p>
<h2 id="八、leetcode-174-地下城游戏"><a href="#八、leetcode-174-地下城游戏" class="headerlink" title="八、leetcode 174. 地下城游戏"></a>八、<a href="https://leetcode-cn.com/problems/dungeon-game/">leetcode 174. 地下城游戏</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;</span><br><span class="line">        int m = dungeon.size();</span><br><span class="line">        if (m == 0) return 0;</span><br><span class="line">        int n = dungeon[0].size();</span><br><span class="line">        // dp[i][j]：从该位置到P 所需的初始点数</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));</span><br><span class="line">        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);</span><br><span class="line">        // 初始化</span><br><span class="line">        // 最后一列</span><br><span class="line">        for (int i = m - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 当后一个所需血量可以被当前房间内抵消时，初始血量设置为1</span><br><span class="line">            // 否则计算出相差血量，作为该位置的初始血量(dp[i][n - 1])</span><br><span class="line">            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后一行</span><br><span class="line">        for (int j = n - 2; j &gt;= 0; j--) &#123;</span><br><span class="line">            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = m - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = n - 2; j &gt;= 0; j--) &#123;</span><br><span class="line">                int dp_min = min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">                dp[i][j] = max(1, dp_min - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Trie树-字典树"><a href="#Trie树-字典树" class="headerlink" title="Trie树(字典树)"></a>Trie树(字典树)</h1><p>模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># define TRIE_MAX_CHAR_NUM 26</span><br><span class="line">struct TrieNode &#123;</span><br><span class="line">    TrieNode * child[TRIE_MAX_CHAR_NUM]; // 孩子数组 后续26个字母</span><br><span class="line">    bool is_end; // 单词结束标志</span><br><span class="line">    TrieNode(): is_end(false) &#123; // 构造函数 初始化</span><br><span class="line">        for (int i = 0; i &lt; TRIE_MAX_CHAR_NUM; i++) &#123;</span><br><span class="line">            child[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class TrieTree &#123;</span><br><span class="line">private:</span><br><span class="line">    TrieNode _root;</span><br><span class="line">    vector&lt;TrieNode *&gt; _node_vec; // 为了析构</span><br><span class="line">    TrieNode * new_node() &#123;</span><br><span class="line">        TrieNode * node = new TrieNode();</span><br><span class="line">        _node_vec.push_back(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TrieTree() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~TrieTree() &#123;</span><br><span class="line">        for (int i = 0; i &lt; _node_Vec.size(); i++) &#123;</span><br><span class="line">            delete _node_vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入一个单词</span><br><span class="line">    void insert(const char *word) &#123;</span><br><span class="line">        TrieNode *ptr = &amp;_root; // 获取Trie树根节点</span><br><span class="line">        while (*word) &#123; // 直到到达单词尾部</span><br><span class="line">            int pos = *word - &#x27;a&#x27;;</span><br><span class="line">            if (!ptr-&gt;child[pos]) &#123; // 空 新建</span><br><span class="line">                ptr-&gt;child[pos] = new_node();</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;child[pos]; // 到达子节点位置</span><br><span class="line">            word++; // word位置递增</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;is_end = true; // 标记单词结束</span><br><span class="line">    &#125;</span><br><span class="line">    // 搜索单词是否存在</span><br><span class="line">    bool search(const char *word) &#123;</span><br><span class="line">        TrieNode* ptr = &amp;_root;</span><br><span class="line">        while (*word) &#123;</span><br><span class="line">            if (!ptr-&gt;child[*word - &#x27;a&#x27;]) return false;</span><br><span class="line">            ptr = ptr-&gt;child[*word - &#x27;a&#x27;];</span><br><span class="line">            word++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ptr-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断是否存在该前缀</span><br><span class="line">    bool startsWith(const char *prefix) &#123;</span><br><span class="line">        TrieNode* ptr = &amp;_root;</span><br><span class="line">        while (*prefix) &#123;</span><br><span class="line">            if (!ptr-&gt;child[*prefix - &#x27;a&#x27;]) return false;</span><br><span class="line">            ptr = ptr-&gt;child[*prefix - &#x27;a&#x27;];</span><br><span class="line">            prefix++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、leetcode-208-实现-Trie-前缀树"><a href="#一、leetcode-208-实现-Trie-前缀树" class="headerlink" title="一、leetcode 208. 实现 Trie (前缀树)"></a>一、<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">leetcode 208. 实现 Trie (前缀树)</a></h2><p>经典insert、search、startswith</p>
<h2 id="二、leetcode-211-添加与搜索单词-数据结构设计"><a href="#二、leetcode-211-添加与搜索单词-数据结构设计" class="headerlink" title="二、leetcode 211. 添加与搜索单词 - 数据结构设计"></a>二、<a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">leetcode 211. 添加与搜索单词 - 数据结构设计</a></h2><p>DFS查找带有“.”的字符串在字典树中是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool dfs_search(TrieNode* ptr, string word, int i) &#123;</span><br><span class="line">        if (i &gt;= word.length()) &#123;</span><br><span class="line">            if (ptr-&gt;is_end) return true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (word[i] != &#x27;.&#x27;) &#123;  </span><br><span class="line">            if (ptr-&gt;child[word[i] - &#x27;a&#x27;]) &#123; // 匹配并且下一步为true</span><br><span class="line">                if (dfs_search(ptr-&gt;child[word[i] - &#x27;a&#x27;], word, i + 1)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 点字符 可匹配任意后续字母</span><br><span class="line">            // 遍历后续字母 dfs</span><br><span class="line">            for (int j = 0; j &lt; TRIE_MAX_CHAR_NUM; j++) &#123;</span><br><span class="line">                if (ptr-&gt;child[j]) &#123;  // 每一个可能的后续字符</span><br><span class="line">                    if (dfs_search(ptr-&gt;child[j], word, i + 1)) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="一、leetcode-547-朋友圈"><a href="#一、leetcode-547-朋友圈" class="headerlink" title="一、leetcode 547. 朋友圈"></a>一、<a href="https://leetcode-cn.com/problems/friend-circles/">leetcode 547. 朋友圈</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; friends;</span><br><span class="line">    vector&lt;int&gt; _size; // 各子树规模</span><br><span class="line">    int findfather(int x) &#123;</span><br><span class="line">        while (friends[x] != x) &#123;</span><br><span class="line">            friends[x] = friends[friends[x]]; // 路径压缩</span><br><span class="line">            x = friends[x];</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    void union_two(int a, int b) &#123;</span><br><span class="line">        int a_father = findfather(a);</span><br><span class="line">        int b_father = findfather(b);</span><br><span class="line">        if (a_father == b_father) return;</span><br><span class="line">        if (_size[a_father] &lt; _size[b_father]) &#123; // 小的向大的合并 以减小查询复杂度</span><br><span class="line">            friends[a_father] = b_father;</span><br><span class="line">            _size[b_father] += _size[a_father];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            friends[b_father] = a_father;</span><br><span class="line">            _size[a_father] += _size[b_father];</span><br><span class="line">        &#125;</span><br><span class="line">        /*for (int i = 0; i &lt; friends.size(); i++) &#123; // 更新所有以b_father为父母的friends值</span><br><span class="line">            if (friends[i] == b_father) &#123;</span><br><span class="line">                friends[i] = a_father; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line">    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123;</span><br><span class="line">        int n = M.size();</span><br><span class="line">        // 并查集初始化</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            friends.push_back(i);</span><br><span class="line">            _size.push_back(1); // 本身大小1</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (M[i][j]) &#123;</span><br><span class="line">                    union_two(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找不同father总数</span><br><span class="line">        map&lt;int, int&gt; mp;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (mp.find(findfather(friends[i])) == mp.end()) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                mp[findfather(friends[i])] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><a href="https://oi-wiki.org/ds/seg/#_4">参考链接</a></p>
<h2 id="leetcode-307-区域和检索-数组可修改"><a href="#leetcode-307-区域和检索-数组可修改" class="headerlink" title="leetcode 307. 区域和检索 - 数组可修改"></a><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">leetcode 307. 区域和检索 - 数组可修改</a></h2><p>求数组区间和：建立/更新/查询线段树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NumArray &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; _values; // 线段树数组</span><br><span class="line">    int _right_end; // 保存右边界</span><br><span class="line">public:</span><br><span class="line">    /// 构建线段树</span><br><span class="line">    // value：线段树数组(存储区间和)</span><br><span class="line">    // nums：用来构建线段树的数组(已知)</span><br><span class="line">    // pos：在线段树数组value中的当前位置</span><br><span class="line">    // left,right：nums数组中的区间左右边界</span><br><span class="line">    void build_segment_tree(vector&lt;int&gt;&amp; value, vector&lt;int&gt;&amp; nums, int pos, int left, int right) &#123;</span><br><span class="line">        if (left == right) &#123;</span><br><span class="line">            value[pos] = nums[left];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        build_segment_tree(value, nums, 2 * pos + 1, left, mid); // 构建左子树</span><br><span class="line">        build_segment_tree(value, nums, 2 * pos + 2, mid + 1, right); // 构建右子树</span><br><span class="line">        value[pos] = value[2 * pos + 1] + value[2 * pos + 2]; // 合并</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 线段树求和</span><br><span class="line">    // value:线段树数组</span><br><span class="line">    // pos：在value中的下标位置</span><br><span class="line">    // left,right：nums数组的当前区间范围</span><br><span class="line">    // qleft,qright：待查询区间</span><br><span class="line">    // [left,right]因递归不断在缩小，[qleft,qright]不变</span><br><span class="line">    int sum_range_segment_tree(vector&lt;int&gt;&amp; value, int pos, int left, int right, int qleft, int qright) &#123;</span><br><span class="line">        if (qleft &gt; right || qright &lt; left) &#123; // 区间不相交</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (qleft &lt;= left &amp;&amp; qright &gt;= right) &#123; // 区间有重叠部分</span><br><span class="line">            return value[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        return sum_range_segment_tree(value, 2 * pos + 1, left, mid, qleft, qright) + sum_range_segment_tree(value, 2 * pos + 2, mid + 1, right, qleft, qright);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    /// 线段树更新</span><br><span class="line">    // value:线段树数组</span><br><span class="line">    // pos：在value中的下标位置</span><br><span class="line">    // left,right：nums数组的当前区间范围</span><br><span class="line">    // index：nums更新的下标值</span><br><span class="line">    // new_val</span><br><span class="line">    void updata_segment_tree(vector&lt;int&gt;&amp; value, int pos, int left, int right, int index, int new_value) &#123;</span><br><span class="line">        if (index == left &amp;&amp; index == right) &#123; // 当前区间为待更新点</span><br><span class="line">            value[pos] = new_value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (mid &gt;= index) updata_segment_tree(value, 2 * pos + 1, left, mid, index, new_value);</span><br><span class="line">        else updata_segment_tree(value, 2 * pos + 2, mid + 1, right, index, new_value);</span><br><span class="line">        value[pos] = value[2 * pos + 1] + value[2 * pos + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return;</span><br><span class="line">        int n = nums.size() * 4; // 一般线段树大小是原数组大小长度的4倍</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            _values.push_back(0);</span><br><span class="line">        &#125;</span><br><span class="line">        _right_end = nums.size() - 1;</span><br><span class="line">        build_segment_tree(_values, nums, 0, 0, _right_end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void update(int i, int val) &#123;</span><br><span class="line">        updata_segment_tree(_values, 0, 0, _right_end, i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sumRange(int i, int j) &#123;</span><br><span class="line">        return sum_range_segment_tree(_values, 0, 0, _right_end, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your NumArray object will be instantiated and called as such:</span><br><span class="line"> * NumArray* obj = new NumArray(nums);</span><br><span class="line"> * obj-&gt;update(i,val);</span><br><span class="line"> * int param_2 = obj-&gt;sumRange(i,j);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-1157-子数组中占绝大多数的元素"><a href="#二、leetcode-1157-子数组中占绝大多数的元素" class="headerlink" title="二、leetcode 1157. 子数组中占绝大多数的元素"></a>二、<a href="https://leetcode-cn.com/problems/online-majority-element-in-subarray/">leetcode 1157. 子数组中占绝大多数的元素</a></h2><p>线段树中存储 在当前区间中，通过打擂法胜出的值；<br>在query过程中，找到查询区间中，出现次数最多的值x；<br>哈希表indices_map存储值与对应的索引数组；<br>在索引数组中找到在[left, right]区间内的个数，判断是否符合要求即可。</p>
<h2 id="三、leetcode-218-天际线问题"><a href="#三、leetcode-218-天际线问题" class="headerlink" title="三、leetcode 218. 天际线问题"></a>三、<a href="https://leetcode-cn.com/problems/the-skyline-problem/">leetcode 218. 天际线问题</a></h2><p>tree线段树数组存储 离散化x值数组各区间内的高度最大值;<br>使用懒下传。</p>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>在每一步做出在当前来看的最优选择。</p>
<h2 id="一、leetcode-455-分发饼干"><a href="#一、leetcode-455-分发饼干" class="headerlink" title="一、leetcode 455. 分发饼干"></a>一、<a href="https://leetcode-cn.com/problems/assign-cookies/">leetcode 455. 分发饼干</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // g:需求因子数组</span><br><span class="line">    // s:糖果数组</span><br><span class="line">    // 贪心思想：用最小的饼干量满足需求</span><br><span class="line">    // 双指针：child cookie</span><br><span class="line">    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        int child = 0, cookie = 0;</span><br><span class="line">        while (child &lt; g.size() &amp;&amp; cookie &lt; s.size()) &#123;</span><br><span class="line">            if (g[child] &lt;= s[cookie]) &#123; // 当前饼干量满足孩子需求</span><br><span class="line">                child++;</span><br><span class="line">                cookie++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前饼干量无法满足孩子需求 则也无法满足后续孩子需求</span><br><span class="line">            // 是个废饼干</span><br><span class="line">            else &#123;</span><br><span class="line">                cookie++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-376-摆动序列"><a href="#二、leetcode-376-摆动序列" class="headerlink" title="二、leetcode 376. 摆动序列"></a>二、<a href="https://leetcode-cn.com/problems/wiggle-subsequence/">leetcode 376. 摆动序列</a></h2><p>状态机 + 贪心：从左到右的遍历过程中，若持续下降/上升，选取最右边界作为摆动序列的一部分，以使摆动序列最长；</p>
<h2 id="三、leetcode-402-移掉K位数字"><a href="#三、leetcode-402-移掉K位数字" class="headerlink" title="三、leetcode 402. 移掉K位数字"></a>三、<a href="https://leetcode-cn.com/problems/remove-k-digits/">leetcode 402. 移掉K位数字</a></h2><p>栈 + 贪心：从左到右遍历（高位到低位）,如果对应数字大于下一位数字，则应该把该数字去掉，以取得最小数</p>
<h2 id="四、leetcode-55-跳跃游戏"><a href="#四、leetcode-55-跳跃游戏" class="headerlink" title="四、leetcode 55. 跳跃游戏"></a>四、<a href="https://leetcode-cn.com/problems/jump-game/">leetcode 55. 跳跃游戏</a></h2><p>当前位置cur_pos,当前可以到达的范围nums[cur_pos] + cur_pos,找到该范围中可以到达最远位置的下标值，作为跳跃目标。<br>升级题:<a href="https://leetcode-cn.com/problems/jump-game-ii/">leetcode 45. 跳跃游戏 II</a></p>
<h2 id="五、leetcode-452-用最少数量的箭引爆气球"><a href="#五、leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="五、leetcode 452. 用最少数量的箭引爆气球"></a>五、<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">leetcode 452. 用最少数量的箭引爆气球</a></h2><h2 id="六、leetcode-871-最低加油次数"><a href="#六、leetcode-871-最低加油次数" class="headerlink" title="六、leetcode 871. 最低加油次数"></a>六、<a href="https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/">leetcode 871. 最低加油次数</a></h2><p>贪心+最大堆（有点跳跃游戏的思想：你尽管走，不够了就加）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 贪心：在不得不加的时候加最多的油，使加油次数最少</span><br><span class="line">    // station:0:距离起点的位置；1:油站所拥有的油量</span><br><span class="line">    int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; Q; // 存储油量的最大堆</span><br><span class="line">        int res = 0; </span><br><span class="line">        vector&lt;int&gt; temp(2);</span><br><span class="line">        temp[0] = 0;</span><br><span class="line">        temp[1] = startFuel;</span><br><span class="line">        stations.push_back(temp);</span><br><span class="line">        temp[0] = target;</span><br><span class="line">        temp[1] = 0;</span><br><span class="line">        stations.push_back(temp);</span><br><span class="line">        sort(stations.begin(), stations.end()); // 从起点到终点</span><br><span class="line">        int fuel = startFuel;</span><br><span class="line">        for (int i = 1; i &lt; stations.size(); i++) &#123;</span><br><span class="line">            int dis = stations[i][0] - stations[i - 1][0]; // 此次需要走的距离</span><br><span class="line">            while (!Q.empty() &amp;&amp; fuel &lt; dis) &#123; // 当前油量无法满足 则从最大堆中选取最大油量来加</span><br><span class="line">                fuel += Q.top();</span><br><span class="line">                Q.pop();</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Q.empty() &amp;&amp; fuel &lt; dis) return -1; // 加满油也无法前进dis</span><br><span class="line">            fuel -= dis;</span><br><span class="line">            Q.push(stations[i][1]); // 将油量放入最大堆</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode 122 买卖股票的最佳时机 II</a><br><a href="https://leetcode-cn.com/problems/boats-to-save-people/">leetcode 881 救生艇</a><br><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">leetcode 316. 去除重复字母</a><br><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">leetcode 435. 无重叠区间</a><br>贪心(区间调度):优先选择end小的(首先根据end升序排序)，使剩下的区间最多，则移除区间最少，与452类似.<br><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/">leetcode 659. 分割数组为连续子序列</a><br><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">leetcode 861. 翻转矩阵后的得分</a><br>（难）321/330/757</p>
]]></content>
  </entry>
  <entry>
    <title>JAVA基础</title>
    <url>/2020/12/19/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p> 一些JAVA基础知识</p>
<span id="more"></span>

<h1 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h1><h2 id="1-1-创建与初始化"><a href="#1-1-创建与初始化" class="headerlink" title="1.1 创建与初始化"></a>1.1 创建与初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">55</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h2 id="1-2-复制数组"><a href="#1-2-复制数组" class="headerlink" title="1.2 复制数组"></a>1.2 复制数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(a, <span class="number">0</span>, b, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从a数组的0下标复制1个到b数组的1下标</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-二维数组"><a href="#1-3-二维数组" class="headerlink" title="1.3 二维数组"></a>1.3 二维数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErWeiShuZu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [][] x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];</span><br><span class="line">		x[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">		System.out.println(x[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-数组作为方法参数"><a href="#1-4-数组作为方法参数" class="headerlink" title="1.4 数组作为方法参数"></a>1.4 数组作为方法参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayUse</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">		<span class="comment">// 转换为string</span></span><br><span class="line">		System.out.println(Arrays.toString(a)); </span><br><span class="line">		<span class="comment">// 复制一定区域</span></span><br><span class="line">		System.out.println(Arrays.toString(Arrays.copyOfRange(a, <span class="number">0</span>, <span class="number">3</span>)));</span><br><span class="line">		<span class="comment">// 排序</span></span><br><span class="line">		Arrays.sort(a);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">		<span class="comment">// 搜索(先进行sort)</span></span><br><span class="line">		System.out.println(Arrays.binarySearch(a, <span class="number">8</span>));</span><br><span class="line">		<span class="comment">// 相同</span></span><br><span class="line">		<span class="keyword">int</span> []b = Arrays.copyOfRange(a, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(Arrays.equals(a, b)); <span class="comment">// true</span></span><br><span class="line">		b[<span class="number">2</span>] = <span class="number">555</span>;</span><br><span class="line">		System.out.println(Arrays.equals(a, b)); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">55</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">new</span> ArrayUse().method(a2);</span><br><span class="line"><span class="keyword">new</span> ShuZu().outputArr(a2); <span class="comment">// 输出，a2作为方法参数，已被改变</span></span><br></pre></td></tr></table></figure>
<h2 id="1-5-排序"><a href="#1-5-排序" class="headerlink" title="1.5 排序"></a>1.5 排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortFun</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[];</span><br><span class="line">	<span class="keyword">int</span> arrsize = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inputArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> num = sc.nextInt(); <span class="comment">// 数量</span></span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">		arrsize = num;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">			arr[i] = sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">()</span> </span>&#123; <span class="comment">// 选择排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrsize; i++) &#123;</span><br><span class="line">			<span class="comment">// 比较后续是否有比arr[i]小的</span></span><br><span class="line">			<span class="comment">// 有则交换</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arrsize; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">					arr[i] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrsize - <span class="number">1</span>; i++) &#123; <span class="comment">// arrsize - 1次冒泡泡</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrsize - i - <span class="number">1</span>; j++) &#123; <span class="comment">// arrsize - i - 1次交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">					arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outputArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> arri : arr) &#123; <span class="comment">// 增强型for循环</span></span><br><span class="line">			System.out.print(arri);</span><br><span class="line">			System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SortFun sf = <span class="keyword">new</span> SortFun();</span><br><span class="line">		sf.inputArr();</span><br><span class="line"><span class="comment">//		sf.selectSort();</span></span><br><span class="line">		sf.bubbleSort();</span><br><span class="line">		sf.outputArr();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2、类与对象"><a href="#2、类与对象" class="headerlink" title="2、类与对象"></a>2、类与对象</h1><h2 id="2-1-命名规范"><a href="#2-1-命名规范" class="headerlink" title="2.1  命名规范"></a>2.1  命名规范</h2><ol>
<li>类的第一个字母大写；</li>
<li>方法addSpeed().</li>
<li>属性一般小写.<h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h2><h3 id="引用与指向"><a href="#引用与指向" class="headerlink" title="引用与指向"></a>引用与指向</h3>new一个对象仅仅代表新建一个对象，没有办法访问它；而使用=给引用赋对象值，代表该对象，又叫“指向”；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用一个引用来指向这个对象</span></span><br><span class="line">Lei h1 = <span class="keyword">new</span> Lei();</span><br></pre></td></tr></table></figure>
<h3 id="多个引用，一个对象"><a href="#多个引用，一个对象" class="headerlink" title="多个引用，一个对象"></a>多个引用，一个对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用一个引用来指向这个对象</span></span><br><span class="line">Lei h1 = <span class="keyword">new</span> Lei();</span><br><span class="line">System.out.println(h1.name);</span><br><span class="line">h1.name = <span class="string">&quot;Cct&quot;</span>;</span><br><span class="line">Lei h2 = h1;  <span class="comment">//h2指向h1所指向的对象</span></span><br><span class="line">Lei h3 = h1;</span><br><span class="line">Lei h4 = h1;</span><br><span class="line">Lei h5 = h4;</span><br><span class="line">System.out.println(h5.name);</span><br><span class="line">h4.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(h1.name);</span><br><span class="line"><span class="comment">//h1,h2,h3,h4,h5 五个引用，都指向同一个对象</span></span><br></pre></td></tr></table></figure>
<h3 id="一个引用，多个对象"><a href="#一个引用，多个对象" class="headerlink" title="一个引用，多个对象"></a>一个引用，多个对象</h3>当某个对象没有任何引用指向，就会被垃圾回收。</li>
</ol>
<h2 id="2-3-this的指向"><a href="#2-3-this的指向" class="headerlink" title="2.3 this的指向"></a>2.3 this的指向</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name; <span class="comment">//姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//参数名和属性名一样</span></span><br><span class="line">	<span class="comment">//在方法体中，只能访问到参数name</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;方法参数与属性名称相同时：%s\n&quot;</span>,name);</span><br><span class="line">		name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了避免setName1中的问题，参数名不得不使用其他变量名</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName2</span><span class="params">(String heroName)</span></span>&#123;</span><br><span class="line">		name = heroName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过this访问属性</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName3</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="comment">//name代表的是参数name</span></span><br><span class="line">		<span class="comment">//this.name代表的是属性name</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Hero  h =<span class="keyword">new</span> Hero();</span><br><span class="line">		Hero  h2 =<span class="keyword">new</span> Hero();</span><br><span class="line">		h.setName1(<span class="string">&quot;teemo&quot;</span>);</span><br><span class="line">		System.out.println(h.name); <span class="comment">// null</span></span><br><span class="line">		</span><br><span class="line">		h.setName2(<span class="string">&quot;garen&quot;</span>);</span><br><span class="line">		System.out.println(h.name);	<span class="comment">// garen	</span></span><br><span class="line"></span><br><span class="line">		System.out.println(h2.name);	</span><br><span class="line">		h2.setName3(<span class="string">&quot;死歌&quot;</span>);</span><br><span class="line">		System.out.println(h2.name);</span><br><span class="line">        <span class="comment">// 死歌</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-函数对象参数改变不影响实参"><a href="#2-4-函数对象参数改变不影响实参" class="headerlink" title="2.4 函数对象参数改变不影响实参"></a>2.4 函数对象参数改变不影响实参</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero2</span><span class="params">(String name,<span class="keyword">float</span> hp)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复活</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">(Hero2 h)</span></span>&#123;</span><br><span class="line">    	h = <span class="keyword">new</span> Hero2(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>); <span class="comment">// 指向新的引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Hero2 teemo =  <span class="keyword">new</span> Hero2(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//受到400伤害，挂了</span></span><br><span class="line">        teemo.hp = teemo.hp - <span class="number">400</span>;</span><br><span class="line">        </span><br><span class="line">        teemo.revive(teemo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//问题： System.out.println(teemo.hp); 输出多少？ 怎么理解</span></span><br><span class="line">        <span class="comment">//  -17</span></span><br><span class="line">        System.out.println(teemo.hp);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-对象属性初始化顺序"><a href="#2-5-对象属性初始化顺序" class="headerlink" title="2.5 对象属性初始化顺序"></a>2.5 对象属性初始化顺序</h2><p>声明函数初始化 -&gt; 初始化块 -&gt; 构造函数初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero3</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name = <span class="string">&quot;hero1&quot;</span>; <span class="comment">// 声明函数初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Hero3</span><span class="params">()</span> </span>&#123; <span class="comment">// 构造函数初始化(最终结果)</span></span><br><span class="line">		name = <span class="string">&quot;hero2&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		name = <span class="string">&quot;hero3&quot;</span>; <span class="comment">// 初始化块</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(name); <span class="comment">// hero2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-枚举类"><a href="#2-6-枚举类" class="headerlink" title="2.6 枚举类"></a>2.6 枚举类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumLei</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">HeroType</span> </span>&#123;</span><br><span class="line">		TANK, WIZARD, ASSASSIN, ASSIST, WARRIOR, RANGED, PUSH, FRAMING</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (HeroType h: HeroType.values()) &#123;</span><br><span class="line">			System.out.println(h);</span><br><span class="line">		&#125;</span><br><span class="line">		HeroType h = HeroType.RANGED;</span><br><span class="line">		<span class="keyword">switch</span>(h) &#123;</span><br><span class="line">		<span class="keyword">case</span> TANK:</span><br><span class="line">			System.out.println(<span class="string">&quot;坦克&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WIZARD:</span><br><span class="line">			System.out.println(<span class="string">&quot;法师&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ASSASSIN:</span><br><span class="line">			System.out.println(<span class="string">&quot;辅助&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;okkkk&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-单例模式"><a href="#2-7-单例模式" class="headerlink" title="2.7 单例模式"></a>2.7 单例模式</h2><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p><strong>立即加载</strong></p>
<ol>
<li>将构造函数私有化，使在外部不能通过new新建一个对象，只能使用公有的getInstance方法；</li>
<li>一个实例化对象作为类属性（static）；</li>
<li>每次获取都得到同一个实例对象，即该类属性。<h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3></li>
</ol>
<p><strong>延时加载</strong><br>与上面不同的是，类属性先不指向一个对象，而是在getInstance()中判断该引用是否为null，若是再new一个，否则直接返回。</p>
<h1 id="3、接口与继承"><a href="#3、接口与继承" class="headerlink" title="3、接口与继承"></a>3、接口与继承</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> animalUML;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> animalUML;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> legs;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		legs = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;用&quot;</span>+legs+<span class="string">&quot;只脚走路&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> animalUML;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllAnimals</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal spider = <span class="keyword">new</span> Spider();</span><br><span class="line">		spider.eat(); <span class="comment">// 调用在子类中定义的抽象方法</span></span><br><span class="line">		spider.walk(); <span class="comment">// 抽象类自带方法</span></span><br><span class="line">		</span><br><span class="line">		Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;mimi&quot;</span>);</span><br><span class="line">		cat.eat();</span><br><span class="line">		cat.walk(); <span class="comment">// 抽象类方法</span></span><br><span class="line">		cat.setName(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">		cat.play(); <span class="comment">// 接口方法</span></span><br><span class="line">		</span><br><span class="line">		Fish fish = <span class="keyword">new</span> Fish(<span class="string">&quot;yuyu&quot;</span>);</span><br><span class="line">		fish.walk(); <span class="comment">// 子类定义的抽象方法覆盖了父类</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// System.out.println(cat.name); 不可访问的私有属性</span></span><br><span class="line">		System.out.println(fish.name);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Animal a = new Animal(0); animal是抽象类 不可直接实例化	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	Spider() &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;蜘蛛吃人！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	Cat(String name) &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	Cat() &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 接口方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;小猫咪&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;在玩！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;小猫咪&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;在吃！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	Fish(String name) &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	Fish () &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;小鱼&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;在玩！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;小鱼&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;在吃！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;小鱼&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;游啊游&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4、多态"><a href="#4、多态" class="headerlink" title="4、多态"></a>4、多态</h1><h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DuoTai;</span><br><span class="line"><span class="comment">// 接口只能包含方法名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MortalInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 英雄类</span><br><span class="line"> */</span><br><span class="line">package DuoTai;</span><br><span class="line"></span><br><span class="line">public class Hero implements Comparable&lt;Hero&gt;&#123;</span><br><span class="line">	static String copyright;</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;初始化copyright&quot;);</span><br><span class="line">		copyright = &quot;cct&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	synchronized static public void test () &#123;</span><br><span class="line">		for (int i =0; i &lt; 20; i++) &#123;</span><br><span class="line">			System.out.print(i + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	String name;</span><br><span class="line">	public int hp;</span><br><span class="line">	String type;</span><br><span class="line">	public int damage;</span><br><span class="line">	// 构造方法</span><br><span class="line">	public Hero () &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public Hero (String name, int hp, String type) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.hp = hp;</span><br><span class="line">		this.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	public Hero (String name, int hp, int damage) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.hp = hp;</span><br><span class="line">		this.damage = damage;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	void kill(MortalInterface m) &#123;</span><br><span class="line">		m.die();</span><br><span class="line">	&#125;</span><br><span class="line">	static void battlewin( ) &#123;</span><br><span class="line">		System.out.println(&quot;hero wins!!!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Hero:[name: &quot; + this.name + &quot;, hp: &quot; + this.hp + &quot;, damage: &quot; + this.damage + &quot;]&quot; ;</span><br><span class="line">	&#125;</span><br><span class="line">	// 重写比较函数</span><br><span class="line">	// 按伤害从高到低</span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Hero o) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		if (damage &lt; o.damage) return 1; // &gt; 0 伤害小的排后面去 新来的的排前面去</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	// 判断血量是否为0</span><br><span class="line">	public boolean isDead() &#123;</span><br><span class="line">		return hp &lt;= 0 ? true:false;</span><br><span class="line">	&#125;</span><br><span class="line">	// 攻击另一个英雄</span><br><span class="line">	public void attackHero(Hero h) &#123;</span><br><span class="line">		/*try &#123;</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// 中断异常</span><br><span class="line">			// sleep过程中被停止</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		/*if (this.isDead()) &#123;</span><br><span class="line">			System.out.println(name + &quot;挂了！&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;*/</span><br><span class="line">		h.hp -= damage;</span><br><span class="line">		System.out.format(&quot;%s正在攻击%s,%s的血量变成%d%n&quot;, name, h.name, h.name, h.hp);</span><br><span class="line">		if (h.isDead()) &#123;</span><br><span class="line">			System.out.println(h.name + &quot;挂了！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 掉血</span><br><span class="line">	synchronized public void hurt() &#123;</span><br><span class="line">		hp -= 1;</span><br><span class="line">		System.out.println(&quot;当前血量&quot; +hp);</span><br><span class="line">	&#125;</span><br><span class="line">	// 回血</span><br><span class="line">	synchronized public void recover() &#123;</span><br><span class="line">		hp += 1;</span><br><span class="line">		System.out.println(&quot;当前血量&quot; +hp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ADHero extends Hero implements MortalInterface&#123;</span><br><span class="line">	ADHero(String name, int hp) &#123;</span><br><span class="line">		super(name, hp, &quot;ADHero&quot;);</span><br><span class="line">		// 若没有上面的super，则默认调用父类的无参构造函数</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	ADHero()&#123;</span><br><span class="line">		super(&quot;nothing&quot;, 0, &quot;ADHero&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void die() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(this.type + &quot; die!ad die hh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// 重写类方法</span><br><span class="line">	static void battlewin() &#123;</span><br><span class="line">		System.out.println(&quot;adhero wins!!!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class APHero extends Hero implements MortalInterface&#123;</span><br><span class="line">	APHero(String name, int hp) &#123;</span><br><span class="line">		super(name, hp, &quot;APHero&quot;);</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void die() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(this.type + &quot; die!ap die hh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ADAPHero extends Hero implements MortalInterface&#123;</span><br><span class="line">	ADAPHero(String name, int hp) &#123;</span><br><span class="line">		super(name, hp, &quot;ADAPHero&quot;);</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void die() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(this.type + &quot; die!adap die hh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DuoTai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuoTai</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Hero h = <span class="keyword">new</span> Hero(<span class="string">&quot;cct&quot;</span>, <span class="number">1000</span>, <span class="string">&quot;hero&quot;</span>);</span><br><span class="line">		ADHero ad = <span class="keyword">new</span> ADHero(<span class="string">&quot;ad&quot;</span>, <span class="number">100</span>);</span><br><span class="line">		APHero ap = <span class="keyword">new</span> APHero(<span class="string">&quot;ap&quot;</span>, <span class="number">100</span>);</span><br><span class="line">		ADAPHero adap = <span class="keyword">new</span> ADAPHero(<span class="string">&quot;adap&quot;</span>, <span class="number">100</span>);</span><br><span class="line">		h.kill(ad); <span class="comment">// kill是hero统一方法，kill方法中根据不同对象调用实现的不同的接口方法die()</span></span><br><span class="line">		h.kill(ap);</span><br><span class="line">		h.kill(adap);</span><br><span class="line">		Hero.battlewin();</span><br><span class="line">		</span><br><span class="line">		Hero h2 = <span class="keyword">new</span> ADHero(<span class="string">&quot;ad2&quot;</span>, <span class="number">100</span>);</span><br><span class="line">		h2.battlewin(); <span class="comment">// 结果是hero类的静态方法</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Object方法</span></span><br><span class="line">		Hero h11 = <span class="keyword">new</span> Hero(<span class="string">&quot;cct&quot;</span>,<span class="number">1000</span>,<span class="string">&quot;hero&quot;</span>);</span><br><span class="line">		Hero h22 = <span class="keyword">new</span> Hero(<span class="string">&quot;cct&quot;</span>,<span class="number">1000</span>,<span class="string">&quot;hero&quot;</span>);</span><br><span class="line">		Hero h33 = <span class="keyword">new</span> Hero(<span class="string">&quot;cct&quot;</span>,<span class="number">1000</span>,<span class="string">&quot;hero&quot;</span>);</span><br><span class="line">		h33 = h11;</span><br><span class="line">		System.out.println(h11 == h22); <span class="comment">// false</span></span><br><span class="line">		System.out.println(h11.equals(h22)); <span class="comment">// false</span></span><br><span class="line">		System.out.println(h11.equals(h33)); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(h11.toString());</span><br><span class="line">		System.out.print(h11.getClass());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5、文件输入输出流"><a href="#5、文件输入输出流" class="headerlink" title="5、文件输入输出流"></a>5、文件输入输出流</h1><h2 id="5-1-一些文件函数"><a href="#5-1-一些文件函数" class="headerlink" title="5.1 一些文件函数"></a>5.1 一些文件函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">System.out.println(f.getAbsolutePath());</span><br><span class="line">System.out.println(f.exists());</span><br><span class="line">File[] fs = f.listFiles();</span><br></pre></td></tr></table></figure>
<h2 id="5-2-获取文件列表"><a href="#5-2-获取文件列表" class="headerlink" title="5.2 获取文件列表"></a>5.2 获取文件列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getFiles</span><span class="params">(File[] fs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (File f:fs) &#123;</span><br><span class="line">	<span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">		File[] next_fs = f.listFiles();</span><br><span class="line">		getFiles(next_fs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(f.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-字节流读取文件"><a href="#5-2-字节流读取文件" class="headerlink" title="5.2 字节流读取文件"></a>5.2 字节流读取文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">readFile</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">		<span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">		fis.read(all);<span class="comment">// 字节流形式读出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">byte</span> b:all) &#123;</span><br><span class="line">			System.out.print((<span class="keyword">char</span>)b);</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-字节流写入文件"><a href="#5-3-字节流写入文件" class="headerlink" title="5.3 字节流写入文件"></a>5.3 字节流写入文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">		<span class="keyword">byte</span> data[] = &#123;<span class="number">96</span>,<span class="number">97</span>&#125;;</span><br><span class="line">		fos.write(data);</span><br><span class="line">		fos.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-字符流读取文件"><a href="#5-4-字符流读取文件" class="headerlink" title="5.4 字符流读取文件"></a>5.4 字符流读取文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">readFile2</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line">		<span class="keyword">char</span>[] all = <span class="keyword">new</span> <span class="keyword">char</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">		fr.read(all);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> b: all) &#123;</span><br><span class="line">			System.out.print(b);</span><br><span class="line">		&#125;</span><br><span class="line">		fr.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-字符流写入文件"><a href="#5-5-字符流写入文件" class="headerlink" title="5.5 字符流写入文件"></a>5.5 字符流写入文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeFile2</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">		String data = <span class="string">&quot;我是陈彩婷！&quot;</span>;</span><br><span class="line">		<span class="keyword">char</span>[] cs = data.toCharArray();</span><br><span class="line">		fw.write(cs);</span><br><span class="line">		fw.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6、集合框架"><a href="#6、集合框架" class="headerlink" title="6、集合框架"></a>6、集合框架</h1><h2 id="6-1-arraylist"><a href="#6-1-arraylist" class="headerlink" title="6.1 arraylist"></a>6.1 arraylist</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> arrayListLearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListLearn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputArray</span><span class="params">(List&lt;Hero&gt; heros)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 增强型for循环</span></span><br><span class="line">		<span class="comment">/*for (Object hero : heros) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(hero.toString());</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="comment">// 迭代器while循环</span></span><br><span class="line">		Iterator&lt;Hero&gt; it = heros.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Hero hero = it.next();</span><br><span class="line">			System.out.println(hero.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ArrayList&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">		heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;cct&quot;</span>, <span class="number">1000</span>, <span class="string">&quot;hero&quot;</span>));</span><br><span class="line">		heros.add(<span class="keyword">new</span> Hero());</span><br><span class="line">		<span class="comment">// 在特定的位置上添加</span></span><br><span class="line">		Hero spHero = <span class="keyword">new</span> Hero(<span class="string">&quot;sphero&quot;</span>, <span class="number">100</span>, <span class="string">&quot;hero&quot;</span>);</span><br><span class="line">		heros.add(<span class="number">1</span>, spHero);</span><br><span class="line">		<span class="comment">// 数组大小</span></span><br><span class="line">		System.out.println(heros.size());</span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="comment">// 调用重写的toString方法</span></span><br><span class="line">		<span class="keyword">new</span> ArrayListLearn().outputArray(heros);</span><br><span class="line">		<span class="comment">// 获取指定位置的对象</span></span><br><span class="line">		System.out.println(heros.get(<span class="number">0</span>));</span><br><span class="line">		<span class="comment">// 判断对象是否存在</span></span><br><span class="line">		System.out.println(heros.contains(spHero));</span><br><span class="line">		<span class="comment">// 获取对象所处的位置</span></span><br><span class="line">		System.out.println(heros.indexOf(spHero));</span><br><span class="line">		System.out.println(heros.lastIndexOf(spHero));</span><br><span class="line">		<span class="comment">// 按下标删除对象</span></span><br><span class="line">		heros.remove(heros.size() - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">new</span> ArrayListLearn().outputArray(heros);</span><br><span class="line">		<span class="comment">// 按下标替换对象</span></span><br><span class="line">		Hero spHero2 = <span class="keyword">new</span> Hero(<span class="string">&quot;sphero2&quot;</span>, <span class="number">100</span>, <span class="string">&quot;hero&quot;</span>);</span><br><span class="line">		heros.set(<span class="number">1</span>, spHero2);</span><br><span class="line">		<span class="comment">// heros.set(2, spHero2); 越界</span></span><br><span class="line">		<span class="keyword">new</span> ArrayListLearn().outputArray(heros);</span><br><span class="line">		<span class="comment">// 按对象删除</span></span><br><span class="line">		heros.remove(spHero2);</span><br><span class="line">		<span class="keyword">new</span> ArrayListLearn().outputArray(heros);</span><br><span class="line">		<span class="comment">// 转换为数组</span></span><br><span class="line">		Hero hs[] = (Hero[])heros.toArray(<span class="keyword">new</span> Hero[] &#123;&#125;);</span><br><span class="line">		System.out.println(hs);</span><br><span class="line">		<span class="comment">// 初始化5个对象</span></span><br><span class="line">		ArrayList&lt;Hero&gt; anotherHeros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        	anotherHeros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, <span class="number">10</span>,<span class="string">&quot;hero&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 容器相加</span></span><br><span class="line">        heros.addAll(anotherHeros);</span><br><span class="line">		<span class="keyword">new</span> ArrayListLearn().outputArray(heros);</span><br><span class="line">		<span class="comment">// 容器清空</span></span><br><span class="line">		anotherHeros.clear();</span><br><span class="line">		<span class="keyword">new</span> ArrayListLearn().outputArray(anotherHeros);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-linkedlist"><a href="#6-2-linkedlist" class="headerlink" title="6.2 linkedlist"></a>6.2 linkedlist</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> linkListLearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"><span class="keyword">import</span> arrayListLearn.ArrayListLearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListLearn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 双向链表</span></span><br><span class="line">		<span class="comment">// 实现了List Deque </span></span><br><span class="line">		LinkedList&lt;Hero&gt; l1 = <span class="keyword">new</span> LinkedList&lt;Hero&gt;();</span><br><span class="line">		<span class="comment">// 在后面插入新的英雄</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			l1.addLast(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, <span class="number">10</span>, <span class="string">&quot;hero&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 在前面插入新的英雄</span></span><br><span class="line">		l1.addFirst(<span class="keyword">new</span> Hero(<span class="string">&quot;hero 00&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hero&quot;</span>));</span><br><span class="line">		<span class="comment">// 调用别包的方法 需要是public</span></span><br><span class="line">		<span class="comment">// 默认是package，只有包内可用</span></span><br><span class="line">		ArrayListLearn al = <span class="keyword">new</span> ArrayListLearn();</span><br><span class="line">		al.outputArray(l1);</span><br><span class="line">		<span class="comment">// 查看与删除</span></span><br><span class="line">		<span class="comment">// getFirst() removeFirst()</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 实现Queue接口</span></span><br><span class="line">		Queue&lt;Hero&gt; q1 = l1; <span class="comment">// 大的包容小的</span></span><br><span class="line">		<span class="comment">// 从队尾入</span></span><br><span class="line">		q1.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;hero tail&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hero&quot;</span>));</span><br><span class="line">		<span class="comment">// 查看队头</span></span><br><span class="line">		System.out.println(q1.peek());</span><br><span class="line">		<span class="comment">// 从队头出</span></span><br><span class="line">		Hero h = q1.poll();</span><br><span class="line">		System.out.println(h);</span><br><span class="line">		LinkedList&lt;Hero&gt; l2 = <span class="keyword">new</span> LinkedList&lt;Hero&gt;();</span><br><span class="line">		l2 = (LinkedList&lt;Hero&gt;)q1; <span class="comment">// 从大到小 强制转换</span></span><br><span class="line">		al.outputArray(l2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-hashset"><a href="#6-3-hashset" class="headerlink" title="6.3 hashset"></a>6.3 hashset</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hashLearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetLearn</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">queryList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; myList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">			myList.add(i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 进行10次查找</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 打乱数组</span></span><br><span class="line">			Collections.shuffle(myList);</span><br><span class="line">			<span class="comment">// 获取当前时间</span></span><br><span class="line">			<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">			<span class="keyword">for</span> (Integer num : myList) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num == <span class="number">100000</span>) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;find 100000!&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取结束时间</span></span><br><span class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">			System.out.printf(<span class="string">&quot;花了%d毫秒\n&quot;</span>,end-start);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">queryHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">			myMap.put(i + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 获取当前时间</span></span><br><span class="line">			<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">			<span class="keyword">int</span> target = myMap.get(<span class="number">100000</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;find &quot;</span>+ target);</span><br><span class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">			System.out.printf(<span class="string">&quot;花了%d毫秒\n&quot;</span>,end-start);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		HashSet&lt;String&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="comment">// 生成随机数</span></span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			hs.add(<span class="string">&quot;aa&quot;</span>+random.nextInt(<span class="number">6</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 发生插入则返回true</span></span><br><span class="line">		<span class="comment">// 反之返回false</span></span><br><span class="line">		System.out.println(hs.add(<span class="string">&quot;aa5&quot;</span>));</span><br><span class="line">		System.out.println(hs);</span><br><span class="line">		System.out.println(hs.size());</span><br><span class="line">		</span><br><span class="line">		HashSetLearn hsl = <span class="keyword">new</span> HashSetLearn();</span><br><span class="line">		<span class="comment">// hsl.queryList();</span></span><br><span class="line">		<span class="comment">// hsl.queryHashMap();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 存储类型的hashset</span></span><br><span class="line">		HashSet&lt;Hero&gt; hs2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			hs2.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, <span class="number">10</span>, <span class="string">&quot;hero&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 发生插入则返回true</span></span><br><span class="line">		<span class="comment">// 反之返回false</span></span><br><span class="line">		Hero ahero = <span class="keyword">new</span> Hero(<span class="string">&quot;hero 0&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hero&quot;</span>);</span><br><span class="line">		System.out.println(hs2.add(ahero)); <span class="comment">// true</span></span><br><span class="line">		<span class="comment">// equals判断为true 所以不能进行进一步添加</span></span><br><span class="line">		System.out.println(hs2.add(ahero)); <span class="comment">// false</span></span><br><span class="line">		System.out.println(hs2);</span><br><span class="line">		System.out.println(hs2.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7、匿名类"><a href="#7、匿名类" class="headerlink" title="7、匿名类"></a>7、匿名类</h1><h2 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaLearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeroChecker</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Hero h)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数-1"><a href="#主函数-1" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaLearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"><span class="keyword">import</span> arrayListLearn.ArrayListLearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaLearn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Hero h_cct = <span class="keyword">new</span> Hero(<span class="string">&quot;cct&quot;</span>,<span class="number">1000</span>,<span class="number">50</span>);</span><br><span class="line">		List&lt;Hero&gt; hero_list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			hero_list.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero&quot;</span> + (i + <span class="number">1</span>), random.nextInt(<span class="number">1000</span>), random.nextInt(<span class="number">50</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">		hero_list.add(h_cct);</span><br><span class="line">		ArrayListLearn al = <span class="keyword">new</span> ArrayListLearn();</span><br><span class="line">		al.outputArray(hero_list);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 排序</span></span><br><span class="line">		System.out.println(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">		Collections.sort(hero_list);</span><br><span class="line">		al.outputArray(hero_list);</span><br><span class="line">		<span class="comment">// 1. 显示实现test接口方法</span></span><br><span class="line">		<span class="comment">// 筛选 传入匿名类对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;筛选damage&gt;=30的后：&quot;</span>);</span><br><span class="line">		HeroChecker checker = <span class="keyword">new</span> HeroChecker() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Hero h)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> (h.damage &lt; <span class="number">30</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// filter方法只有是static，才能直接调用</span></span><br><span class="line">		List&lt;Hero&gt; new_hero_list1 = filter(hero_list, checker);</span><br><span class="line">		al.outputArray(new_hero_list1);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 2.1 匿名类：精简接口方法 </span></span><br><span class="line">		<span class="comment">// 筛选 传入Lambda</span></span><br><span class="line">		<span class="comment">// Lambda类实际上就是一个参数-&gt;判断bool函数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;筛选hp&gt;=800的后：&quot;</span>);</span><br><span class="line">		List&lt;Hero&gt; new_hero_list2 = filter(hero_list, (h)-&gt;h.hp &lt; <span class="number">800</span>);</span><br><span class="line">		al.outputArray(new_hero_list2);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 2.2 </span></span><br><span class="line">		<span class="comment">// Lambda排序方式</span></span><br><span class="line">        <span class="comment">// sort是一个筛选函数 当实现的接口方法返回1时 发生位置调换 即小的h1换到大的h2后面 所以是从大到小</span></span><br><span class="line">		System.out.println(<span class="string">&quot;对hp进行从大到小的排序后：&quot;</span>);</span><br><span class="line">		Collections.sort(new_hero_list2, (h1, h2)-&gt;h1.hp &lt; h2.hp ? <span class="number">1</span>:-<span class="number">1</span>); <span class="comment">// 1：后面的排在前面 ；-1：后面的还是在后面</span></span><br><span class="line">		al.outputArray(new_hero_list2);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 3. </span></span><br><span class="line">		<span class="comment">// Lambda调用静态方法</span></span><br><span class="line">		<span class="comment">// List&lt;Hero&gt; new_hero_list3 = filter(hero_list, h-&gt;testHero(h));</span></span><br><span class="line">		List&lt;Hero&gt; new_hero_list3 = filter(hero_list, LambdaLearn::testHero);</span><br><span class="line">		al.outputArray(new_hero_list3);</span><br><span class="line">		<span class="comment">// 还可以引用对象方法，容器中对象的方法</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 聚合操作</span></span><br><span class="line">		System.out.println(<span class="string">&quot;聚合操作：&quot;</span>);</span><br><span class="line">		Hero thirdhero = hero_list</span><br><span class="line">				.stream() <span class="comment">// Collection切换为管道源</span></span><br><span class="line">				.sorted((h1, h2) -&gt; h1.hp &lt; h2.hp?<span class="number">1</span>:-<span class="number">1</span>) <span class="comment">// 中间操作：按照hp从高到低排序</span></span><br><span class="line">				.skip(<span class="number">2</span>) <span class="comment">// 中间操作：跳过前2个</span></span><br><span class="line">				.findFirst() <span class="comment">// 结束</span></span><br><span class="line">				.get();</span><br><span class="line">		System.out.println(thirdhero);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  List&lt;Hero&gt; <span class="title">filter</span><span class="params">(List&lt;Hero&gt; heros, HeroChecker hc)</span> </span>&#123;</span><br><span class="line">		List&lt;Hero&gt; new_heros = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Hero h : heros) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!hc.test(h)) &#123; <span class="comment">// 筛选器 当返回true时 选上</span></span><br><span class="line">				new_heros.add(h);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> new_heros;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testHero</span><span class="params">(Hero h)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> h.hp &lt; <span class="number">800</span> &amp;&amp; h.damage &lt; <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8、多线程"><a href="#8、多线程" class="headerlink" title="8、多线程"></a>8、多线程</h1><h2 id="8-1-线程的一些基本操作"><a href="#8-1-线程的一些基本操作" class="headerlink" title="8.1 线程的一些基本操作"></a>8.1 线程的一些基本操作</h2><p>实现线程的3种方式：</p>
<ol>
<li>继承Thread<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KillThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Hero h1;</span><br><span class="line">	<span class="keyword">private</span> Hero h2;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">KillThread</span><span class="params">(Hero h1, Hero h2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.h1 = h1;</span><br><span class="line">		<span class="keyword">this</span>.h2 = h2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!h2.isDead()) &#123;</span><br><span class="line">			h1.attackHero(h2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Battle类实现runnable接口：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Battle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Hero h1;</span><br><span class="line">	Hero h2;</span><br><span class="line">	Battle(Hero h1, Hero h2) &#123;</span><br><span class="line">		<span class="keyword">this</span>.h1 = h1;</span><br><span class="line">		<span class="keyword">this</span>.h2 = h2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">while</span> (!h2.isDead()) &#123;</span><br><span class="line">			h1.attackHero(h2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匿名类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多线程例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Hero h1 = <span class="keyword">new</span> Hero(<span class="string">&quot;A&quot;</span>, <span class="number">2500</span>, <span class="number">5</span>);</span><br><span class="line">		Hero h2 = <span class="keyword">new</span> Hero(<span class="string">&quot;B&quot;</span>, <span class="number">2000</span>, <span class="number">8</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 顺序</span></span><br><span class="line"><span class="comment">		while (!h2.isDead()) &#123;</span></span><br><span class="line"><span class="comment">			h1.attackHero(h2);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		while (!h1.isDead()) &#123;</span></span><br><span class="line"><span class="comment">			h2.attackHero(h1);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">// 多线程</span></span><br><span class="line">		<span class="comment">// 继承Thread</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		KillThread kt1 = new KillThread(h1, h2);</span></span><br><span class="line"><span class="comment">		kt1.start(); // 借助一个线程对象的start方法，才会启动一个线程</span></span><br><span class="line"><span class="comment">		KillThread kt2 = new KillThread(h2, h1);</span></span><br><span class="line"><span class="comment">		kt2.start();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">//或实现Runnable接口 </span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Battle b1 = new Battle(h1, h2);</span></span><br><span class="line"><span class="comment">		Battle b2 = new Battle(h2, h1);</span></span><br><span class="line"><span class="comment">		new Thread(b2).start();</span></span><br><span class="line"><span class="comment">		new Thread(b1).start();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">// 或匿名类</span></span><br><span class="line">		<span class="comment">// A攻击B</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// 可直接使用外部final变量</span></span><br><span class="line">				<span class="comment">// JDK7之后无要求</span></span><br><span class="line">				<span class="keyword">while</span> (!h2.isDead()) &#123;</span><br><span class="line">					h1.attackHero(h2);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// B攻击A</span></span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (!h1.isDead()) &#123;</span><br><span class="line">					Thread.yield(); <span class="comment">// 临时暂停</span></span><br><span class="line">					h2.attackHero(h1);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t1.setPriority(<span class="number">1</span>);</span><br><span class="line">		t2.setPriority(<span class="number">10</span>); <span class="comment">// 优先级大的抢占CPU能力强</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		try &#123;</span></span><br><span class="line"><span class="comment">			t1.join(); // 加入到主线程中</span></span><br><span class="line"><span class="comment">			t2.join();</span></span><br><span class="line"><span class="comment">		&#125; catch(InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">			e.printStackTrace();</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Game Over!!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-原子操作"><a href="#8-2-原子操作" class="headerlink" title="8.2 原子操作"></a>8.2 原子操作</h2>普通int不能做到并发操作，而AtomicInteger可以<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger aint = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span> number = <span class="number">100000</span>;</span><br><span class="line">		Thread[] t1 = <span class="keyword">new</span> Thread[number];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					value++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			t.start();</span><br><span class="line">			t1[i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Thread t: t1) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				t.join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">		Thread t2[] = <span class="keyword">new</span> Thread[number];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					aint.incrementAndGet(); <span class="comment">// 原子操作:自增</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			t.start();</span><br><span class="line">			t2[i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Thread t:t2) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				t.join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;aint:&quot;</span> + aint.intValue());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-synchronized"><a href="#8-3-synchronized" class="headerlink" title="8.3 synchronized"></a>8.3 synchronized</h2>Hero类的recover方法与hurt方法有synchronized关键词修饰：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程同步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">final</span> Hero h = <span class="keyword">new</span> Hero(<span class="string">&quot;cct&quot;</span>, <span class="number">1000</span>, <span class="number">50</span>);</span><br><span class="line">		System.out.printf(<span class="string">&quot;初始血量为%d\n&quot;</span>, h.hp);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// n个线程</span></span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">10000</span>;</span><br><span class="line">		Thread[] addThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line">		Thread[] reduceThreads = <span class="keyword">new</span> Thread[n];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 匿名类建立n个线程增加hp</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread() &#123; </span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					h.recover();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			t.start();</span><br><span class="line">			addThreads[i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 匿名类建立n个线程减少hp</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread() &#123; </span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					h.hurt();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			t.start();</span><br><span class="line">			reduceThreads[i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 等待所有增加线程结束</span></span><br><span class="line">		<span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				t.join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 等待所有减少线程结束</span></span><br><span class="line">		<span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">			t.join();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(h.hp); <span class="comment">// 初始血量1000</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-4-await-signal-signalAll"><a href="#8-4-await-signal-signalAll" class="headerlink" title="8.4 await signal signalAll"></a>8.4 await signal signalAll</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取当前时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印日志</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;%s %s %s%n&quot;</span>, now(), Thread.currentThread().getName(), msg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		Condition condition = lock.newCondition();<span class="comment">// await signal signalAll方法</span></span><br><span class="line">		</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">					log(<span class="string">&quot;试图lock&quot;</span>);</span><br><span class="line">					lock.lock();</span><br><span class="line">					log(<span class="string">&quot;已占有(5s)&quot;</span>);</span><br><span class="line">					Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">					log(<span class="string">&quot;临时释放lock对象，并等待&quot;</span>);</span><br><span class="line">					condition.await(); <span class="comment">// 自身陷入等待</span></span><br><span class="line">					log(<span class="string">&quot;重新占有lock,继续5s&quot;</span>);</span><br><span class="line">					Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					log(<span class="string">&quot;释放对象unlock&quot;</span>);</span><br><span class="line">					lock.unlock();</span><br><span class="line">				&#125;</span><br><span class="line">				log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">boolean</span> locked = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">					log(<span class="string">&quot;试图lock&quot;</span>);</span><br><span class="line">					<span class="comment">// lock.lock();</span></span><br><span class="line">					locked = lock.tryLock(<span class="number">6</span>, TimeUnit.SECONDS); <span class="comment">// 试图占有操作，时限1s</span></span><br><span class="line">					<span class="keyword">if</span> (locked) &#123;</span><br><span class="line">						log(<span class="string">&quot;已占有(5s)&quot;</span>);</span><br><span class="line">						Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">						log(<span class="string">&quot;唤醒&quot;</span>);</span><br><span class="line">						condition.signal();</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						log(<span class="string">&quot;1s内没能成功占有 Sorry&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (locked) &#123; <span class="comment">// 在占有对象的前提下</span></span><br><span class="line">						log(<span class="string">&quot;释放对象unlock&quot;</span>);</span><br><span class="line"><span class="comment">//						lock.unlock();</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-5-死锁实例"><a href="#8-5-死锁实例" class="headerlink" title="8.5 死锁实例"></a>8.5 死锁实例</h2>hero实例对象使用synchronized修饰<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DuoTai.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">final</span> Hero h1 = <span class="keyword">new</span> Hero(<span class="string">&quot;hero1&quot;</span>, <span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">final</span> Hero h2 = <span class="keyword">new</span> Hero(<span class="string">&quot;hero2&quot;</span>, <span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">final</span> Hero h3 = <span class="keyword">new</span> Hero(<span class="string">&quot;hero3&quot;</span>, <span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (h1) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;t1占有h1！&quot;</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;t1想去占有h2&quot;</span>);</span><br><span class="line">					<span class="keyword">synchronized</span> (h2) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;nothing&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (h2) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;t2占有h2！&quot;</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;t2想去占有h3&quot;</span>);</span><br><span class="line">					<span class="keyword">synchronized</span> (h3) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;nothing&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t2.start();</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (h3) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;t3占有h3！&quot;</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;t3想去占有h1&quot;</span>);</span><br><span class="line">					<span class="keyword">synchronized</span> (h1) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;nothing&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-6-生产者与消费者"><a href="#8-6-生产者与消费者" class="headerlink" title="8.6 生产者与消费者"></a>8.6 生产者与消费者</h2>两种方式<h3 id="synchronized与信号量方式"><a href="#synchronized与信号量方式" class="headerlink" title="synchronized与信号量方式"></a>synchronized与信号量方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 生产者-消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;E&gt; ms = <span class="keyword">new</span> Stack&lt;E&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> limit = <span class="number">10</span>; <span class="comment">// 栈的大小</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.limit = l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在栈满的情况下 使当前进程wait</span></span><br><span class="line">	<span class="comment">// 将item压入栈</span></span><br><span class="line">	<span class="comment">// 通知消费者wait进程可拿</span></span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (ms.size() == limit) <span class="keyword">this</span>.wait(); <span class="comment">// 使用while再次确认 防止虚假唤醒 </span></span><br><span class="line">		ms.push(item);</span><br><span class="line">		System.out.println(<span class="string">&quot;当前stack大小为&quot;</span>+ms.size());</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在栈空的情况下 使当前进程wait</span></span><br><span class="line">	<span class="comment">// 将item取出栈</span></span><br><span class="line">	<span class="comment">// 通知生产者wait进程可放</span></span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (ms.size() == <span class="number">0</span>) <span class="keyword">this</span>.wait();</span><br><span class="line">		E item = ms.pop();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前stack大小为&quot;</span>+ms.size());</span><br><span class="line">		notifyAll();</span><br><span class="line">		<span class="keyword">return</span> item;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCproblem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyStack&lt;Integer&gt; ms = <span class="keyword">new</span> MyStack(<span class="number">10</span>); <span class="comment">// 临界区</span></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Thread producer = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				Random r = <span class="keyword">new</span> Random();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">						<span class="keyword">int</span> x = r.nextInt(<span class="number">10</span>);</span><br><span class="line">						ms.push(x);</span><br><span class="line">						System.out.println(<span class="string">&quot;压入&quot;</span>+ x);</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		producer.start();</span><br><span class="line">		</span><br><span class="line">		Thread[] consumer = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">							<span class="keyword">int</span> x = ms.pop();</span><br><span class="line">							System.out.println(<span class="string">&quot;弹出&quot;</span>+ x);</span><br><span class="line">							Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			consumer[i] = t;</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lock法"><a href="#lock法" class="headerlink" title="lock法"></a>lock法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 生产者-消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNewStack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;E&gt; ms = <span class="keyword">new</span> Stack&lt;E&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> limit = <span class="number">10</span>; <span class="comment">// 栈的大小</span></span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 创建锁对象</span></span><br><span class="line">	Condition condition = lock.newCondition();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取当前时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印日志</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;%s %s %s%n&quot;</span>, now(), Thread.currentThread().getName(), msg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyNewStack</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.limit = l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在栈满的情况下 使当前进程wait 释放锁</span></span><br><span class="line">	<span class="comment">// 不能使用synchronized关键字，因为使用后确保对stack的互斥访问 尽管await了，还是上着锁</span></span><br><span class="line">	<span class="comment">// 当栈不满后，将item压入栈</span></span><br><span class="line">	<span class="comment">// 通知消费者wait进程可拿</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">while</span> (ms.size() == limit) &#123;</span><br><span class="line">				log(<span class="string">&quot;栈满了，生产者等待&quot;</span>);</span><br><span class="line">				condition.await(); <span class="comment">// 使用while再次确认 防止虚假唤醒 </span></span><br><span class="line">			&#125;</span><br><span class="line">			ms.push(item);</span><br><span class="line">			log(<span class="string">&quot;生产者压入&quot;</span>+ item);</span><br><span class="line">			condition.signal(); <span class="comment">// 通知消费者</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在栈空的情况下 使当前进程wait</span></span><br><span class="line">	<span class="comment">// 将item取出栈</span></span><br><span class="line">	<span class="comment">// 通知生产者wait进程可放</span></span><br><span class="line">	<span class="function">E <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">while</span> (ms.size() == <span class="number">0</span>) &#123;</span><br><span class="line">				log(<span class="string">&quot;栈为空，消费者等待&quot;</span>);</span><br><span class="line">				condition.await();</span><br><span class="line">			&#125;</span><br><span class="line">			E item = ms.pop();</span><br><span class="line">			log(<span class="string">&quot;消费者弹出&quot;</span>+item);</span><br><span class="line">			condition.signal();</span><br><span class="line">			<span class="keyword">return</span> item;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCproblem2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyNewStack&lt;Integer&gt; ms = <span class="keyword">new</span> MyNewStack(<span class="number">10</span>); <span class="comment">// 临界区</span></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// 1个生产者线程</span></span><br><span class="line">		Thread producer = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ms.log(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">				Random r = <span class="keyword">new</span> Random();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">						<span class="keyword">int</span> x = r.nextInt(<span class="number">10</span>);</span><br><span class="line">						ms.push(x);</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		producer.setName(<span class="string">&quot;producer&quot;</span>);</span><br><span class="line">		producer.start();</span><br><span class="line">		<span class="comment">// 3个消费者线程</span></span><br><span class="line">		Thread[] consumer = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					ms.log(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">							<span class="keyword">int</span> x = ms.pop();</span><br><span class="line">							ms.log(<span class="string">&quot;thousand years later...&quot;</span>);</span><br><span class="line">							Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			consumer[i] = t;</span><br><span class="line">			t.setName(<span class="string">&quot;consumer&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-7-线程池"><a href="#8-7-线程池" class="headerlink" title="8.7 线程池"></a>8.7 线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multipleThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> poolSize;</span><br><span class="line">	<span class="comment">// 任务容器</span></span><br><span class="line">	LinkedList&lt;Runnable&gt; tasks = <span class="keyword">new</span> LinkedList&lt;Runnable&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 10个消费者进程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		poolSize = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> ConsumeThread(<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 加入到任务容器中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">			tasks.add(r);</span><br><span class="line">			<span class="comment">// 通知wait的消费者进程</span></span><br><span class="line">			tasks.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 子类</span></span><br><span class="line">	<span class="comment">// 消费者线程</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ConsumeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ConsumeThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		Runnable task;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;启动：&quot;</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 启动后一直保持运行状态</span></span><br><span class="line">				<span class="keyword">synchronized</span> (tasks) &#123; <span class="comment">// 对tasks同步访问</span></span><br><span class="line">					<span class="comment">// 任务容器为空 wait</span></span><br><span class="line">					<span class="keyword">while</span> (tasks.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							tasks.wait();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 从任务容器中取出任务</span></span><br><span class="line">					task = tasks.removeLast();</span><br><span class="line">					<span class="comment">// 通知生产任务线程继续生产</span></span><br><span class="line">					tasks.notifyAll();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;获取到任务，并执行&quot;</span>);</span><br><span class="line">				task.run();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selfThreadPoolMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 线程数</span></span><br><span class="line">		<span class="comment">// 最大线程数</span></span><br><span class="line">		<span class="comment">// 多余线程被回收的空余时间</span></span><br><span class="line">		ThreadPoolExecutor tpe = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,<span class="number">15</span>,<span class="number">60</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">			tpe.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">					System.out.println(<span class="string">&quot;do something!&quot;</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123; <span class="comment">// 拉长任务执行时间</span></span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">new</span> ThreadPool().selfThreadPoolMethods();</span><br><span class="line">		System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		MyThreadPool mtp = new MyThreadPool();</span></span><br><span class="line"><span class="comment">		int slptime = 1000;</span></span><br><span class="line"><span class="comment">		// 加入任务</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="comment">			Runnable r = new Runnable() &#123;</span></span><br><span class="line"><span class="comment">				public void run() &#123;</span></span><br><span class="line"><span class="comment">					System.out.println(&quot;do something!&quot;);</span></span><br><span class="line"><span class="comment">					try &#123; // 拉长任务执行时间</span></span><br><span class="line"><span class="comment">						Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">					&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">						// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">						e.printStackTrace();</span></span><br><span class="line"><span class="comment">					&#125;</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;;</span></span><br><span class="line"><span class="comment">			mtp.add(r);</span></span><br><span class="line"><span class="comment">			try &#123;</span></span><br><span class="line"><span class="comment">				slptime = slptime &gt; 100 ? slptime - 100 : slptime;</span></span><br><span class="line"><span class="comment">				Thread.sleep(slptime); // 缩短任务加入间隔</span></span><br><span class="line"><span class="comment">			&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">				// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">				e.printStackTrace();</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>面经</title>
    <url>/2020/05/07/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="面经刷题"><a href="#面经刷题" class="headerlink" title="面经刷题"></a>面经刷题</h1><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p>注意分号的使用，当以”(“、”[“、”/“、”+”、”-“为行的开头，可能与前一行形成调用或者元素引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr=[1,2,3,4,5,6]</span><br><span class="line">function myShuffle(arr)&#123;</span><br><span class="line">    for(let i=arr.length;i;i--)&#123;</span><br><span class="line">        let j = Math.floor(Math.random()*i);</span><br><span class="line">        [arr[i-1],arr[j]]=[arr[j],arr[i-1]];</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">myShuffle(arr)</span><br></pre></td></tr></table></figure>

<h2 id="CSS两列布局"><a href="#CSS两列布局" class="headerlink" title="CSS两列布局"></a>CSS两列布局</h2><h3 id="将content右栏margin-left，main主栏float-sidebar定宽并设置float，margin-left"><a href="#将content右栏margin-left，main主栏float-sidebar定宽并设置float，margin-left" class="headerlink" title="将content右栏margin-left，main主栏float,sidebar定宽并设置float，margin-left;"></a>将content右栏margin-left，main主栏float,sidebar定宽并设置float，margin-left;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">	</span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">	margin:0;</span><br><span class="line">	padding:0</span><br><span class="line">	&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">	float:left;</span><br><span class="line">	width:100%;</span><br><span class="line">	&#125;</span><br><span class="line">.main .content&#123;</span><br><span class="line">	margin-left:200px;</span><br><span class="line">	&#125;</span><br><span class="line">.sidebar&#123;</span><br><span class="line">	width:200px;</span><br><span class="line">	float:left; // 先设置float布局，下一步margin-left才有效</span><br><span class="line">	margin-left:-100%; // 向左移动一个屏幕的距离</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">		content-right</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;sidebar&quot;&gt;</span><br><span class="line">	sidebar-leftsidebar-leftsidebar-left</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这他娘的为啥不行！无语</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">	margin:0;</span><br><span class="line">	padding:0</span><br><span class="line">	&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">	overflow:hidden;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">	&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">	background:red;</span><br><span class="line">	margin-left:200px;</span><br><span class="line">	height: 200px;</span><br><span class="line">	&#125;</span><br><span class="line">.sidebar&#123;</span><br><span class="line">	float:left;</span><br><span class="line">	width:200px;</span><br><span class="line">	height: 200px;</span><br><span class="line">	background:skyblue;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="content右栏position-absolute-left-200px"><a href="#content右栏position-absolute-left-200px" class="headerlink" title="content右栏position:absolute,left:200px"></a>content右栏position:absolute,left:200px</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">	</span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">	margin:0;</span><br><span class="line">	padding:0</span><br><span class="line">	&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	left:200px;</span><br><span class="line">	right:0;</span><br><span class="line">	top:0;</span><br><span class="line">	&#125;</span><br><span class="line">.sidebar&#123;</span><br><span class="line">	width:200px;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">	content-right</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;sidebar&quot;&gt;</span><br><span class="line">	sidebar-leftsidebar-leftsidebar-left</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="flex布局：设置sidebar的order为-1，长度为200px-content右栏flex-1；"><a href="#flex布局：设置sidebar的order为-1，长度为200px-content右栏flex-1；" class="headerlink" title="flex布局：设置sidebar的order为-1，长度为200px;content右栏flex:1；"></a>flex布局：设置sidebar的order为-1，长度为200px;content右栏flex:1；</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">	</span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">	margin:0;</span><br><span class="line">	padding:0</span><br><span class="line">	&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">	display:flex;</span><br><span class="line">	&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">	flex:1; // 我的理解是：在没有其他元素的情况下，flex-grow:1可以霸占剩余区域</span><br><span class="line">	&#125;</span><br><span class="line">.sidebar&#123;</span><br><span class="line">	flex:0 0 200px;</span><br><span class="line">	order:-1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">		content-right</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;sidebar&quot;&gt;</span><br><span class="line">		sidebar-leftsidebar-leftsidebar-left</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p><a href="https://segmentfault.com/a/1190000017329980">参考链接</a></p>
<ol>
<li>解析HTML文档-&gt;DOM树；（JS脚本的加载会阻塞DOM树的生成）</li>
<li>解析CSS规则-&gt;CSSOM树；（会阻塞涉及CSS的JS脚本与对应DOM树的构建)<br>CSS解析与DOM解析可同时进行;</li>
<li>构建渲染树：遍历DOM树，对每个节点查找对应的CSS规则（去除display:none,script,meta,link;visibility或opacity隐藏的节点依然存在）</li>
<li>回流：（布局）在设备视口确切位置与尺寸大小；</li>
<li>绘制：将可见节点转换为屏幕的具体像素，绘制在浏览器上。</li>
</ol>
<p>触发：</p>
<ol>
<li>开始渲染；</li>
<li>浏览器窗口变化；</li>
<li>DOM元素添加或删除；</li>
<li>元素尺寸大小，位置；</li>
<li>元素内部内容改变；</li>
<li>style属性改变。</li>
</ol>
<p>如何优化：</p>
<ol>
<li>css样式改变最小化；</li>
<li>动画元素脱离文档流；</li>
<li>先在脱离文档流的情况下构建好，再插入到主文档中:<br>（display:none/fragment构建子树/拷贝到脱离文档的节点中）</li>
<li>避免触发同步布局事件;</li>
<li>css3硬件加速（GPU加速）。</li>
</ol>
<h2 id="typeOf的返回值"><a href="#typeOf的返回值" class="headerlink" title="typeOf的返回值"></a>typeOf的返回值</h2><p>undefined,string,number,boolen,function,object(null,array);<br><strong>基本类型：</strong>string number boolen null undefined;<br><strong>引用类型：</strong>function object array data regexp;</p>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><a href="https://blog.csdn.net/sinat_36422236/article/details/88763187">参考链接</a><br>块级格式化上下文：盒子模型，独立的块，包含内部所有元素，除了被包含在新BFC下的元素；隔离的独立容器，不受外部元素的影响，内部也不会影响到外部元素。<br>特性：<br>在垂直方向上一个接一个放置；<br>属于一个BFC的相邻margin会重叠（防止外边距合并）<br>不与外部float box重叠(自适应两栏)；<br>计算内部float box的高度(清除浮动)<br>产生方法：<br>float不为none;<br>position:absolute,fixed;<br>display:inline-block,table-cell,flex,table-caption,inline-flex;<br>overflow不为visible;</p>
<h2 id="观察者模式与发布-订阅模式"><a href="#观察者模式与发布-订阅模式" class="headerlink" title="观察者模式与发布-订阅模式"></a>观察者模式与发布-订阅模式</h2><p><a href="https://juejin.im/post/5a14e9edf265da4312808d86">参考链接</a><br>相同点：Observer订阅，Subject接受事件，以及notify通知观察者；<br>不同，<br>观察者模式同步，发布者与订阅者直接连接，单个应用程序空间中实现；<br>发布-订阅模式异步，中间有消息代理进行通信，松散耦合，交叉应用模式。</p>
<h2 id="函数运算符优先级等综合练习"><a href="#函数运算符优先级等综合练习" class="headerlink" title="函数运算符优先级等综合练习"></a>函数运算符优先级等综合练习</h2><p><a href="https://www.v2ex.com/t/351261">参考链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName = function () &#123; alert (1); &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function () &#123; alert (2);&#125;;</span><br><span class="line">Foo.prototype.getName = function () &#123; alert (3);&#125;;</span><br><span class="line">var getName = function () &#123; alert (4);&#125;;</span><br><span class="line">function getName() &#123; alert (5);&#125;</span><br><span class="line"> </span><br><span class="line">//请写出以下输出结果：</span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line">new Foo.getName();</span><br><span class="line">new Foo().getName();</span><br><span class="line">new new Foo().getName();</span><br></pre></td></tr></table></figure>
<h3 id="Foo-getName-2"><a href="#Foo-getName-2" class="headerlink" title="Foo.getName() // 2"></a>Foo.getName() // 2</h3><ol>
<li>静态属性与静态方法在没有初始化实例时就能访问；</li>
<li>要调用公有属性、公有方法，必须new；公有方法不能调用私有属性与方法；</li>
<li>外部不可调用私有属性和方法。</li>
</ol>
<h3 id="getName-4"><a href="#getName-4" class="headerlink" title="getName() // 4"></a>getName() // 4</h3><p>函数声明发生变量提升，被同名函数表达式覆盖；</p>
<h3 id="Foo-getName-1"><a href="#Foo-getName-1" class="headerlink" title="Foo.getName() // 1"></a>Foo.getName() // 1</h3><p>Foo()函数执行返回window全局对象，其中getName覆盖函数；</p>
<h3 id="getName-1"><a href="#getName-1" class="headerlink" title="getName() // 1"></a>getName() // 1</h3><p>全局对象的getName()函数；</p>
<h3 id="new-Foo-getName-2"><a href="#new-Foo-getName-2" class="headerlink" title="new Foo.getName() // 2"></a>new Foo.getName() // 2</h3><p>运算符优先级：.=new有参&gt;new无参&gt;函数调用<br>所以</p>
<ol>
<li>先Foo.getName得到静态方法；</li>
<li>再new得到该方法的实例；</li>
<li>最后调用。</li>
</ol>
<h3 id="new-Foo-getName-3"><a href="#new-Foo-getName-3" class="headerlink" title="new Foo().getName() // 3"></a>new Foo().getName() // 3</h3><ol>
<li>先new有参,初始化Foo实例(实例返回引用类型this，则为实例对象)；</li>
<li>.操作符，获得函数getName(沿原型链)；</li>
<li>执行函数；</li>
</ol>
<h3 id="new-new-Foo-getName-3"><a href="#new-new-Foo-getName-3" class="headerlink" title="new new Foo().getName() // 3"></a>new new Foo().getName() // 3</h3><ol>
<li>先new有参（第2个new），初始化Foo实例；</li>
<li>.操作符，获得函数getName(沿原型链)；</li>
<li>new无参（第1个new),得到该方法实例；</li>
<li>最后调用。</li>
</ol>
<h2 id="什么是闭包？优缺点？"><a href="#什么是闭包？优缺点？" class="headerlink" title="什么是闭包？优缺点？"></a>什么是闭包？优缺点？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>匿名函数引用了它的包含函数内的变量，该函数在外部被调用时，产生了闭包，可以使用包含函数的变量，使其可以常驻内存，不随函数销毁而销毁。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>变量长期驻扎在内存中；</li>
<li>私有成员避免污染全局变量；<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li>
<li>变量占用内存，导致性能下降；循环引用Html元素会内存泄漏；</li>
<li>闭包是操作包含函数变量的共有方法，不能随意改变该变量值；</li>
</ol>
<h2 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手 四次挥手"></a>三次握手 四次挥手</h2><p><a href="https://blog.csdn.net/qq_38950316/article/details/81087809">参考链接</a></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ol>
<li>进程表示资源调度的基本单位，线程是CPU调度的最小单位；</li>
<li>进程内即同一进程的线程数据共享，而不同进程之间数据不共享；</li>
<li>进程表示程序进入到CPU后：获取程序上下文+CPU执行+保存程序上下文的过程；</li>
<li>线程则是在CPU执行过程中，分为不同的块；</li>
<li>进程消耗较大的计算机资源；</li>
<li>进程：互斥锁、信号量；</li>
</ol>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html">参考链接</a><br>状态仅由异步操作的结果决定resolve/reject 不可更改 可实现回调链<br>用维护状态、传递状态的方式使回调函数能及时调用<br>简单、灵活<br>then catch Promise.all Promise.race</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>简化了函数定义，相当于匿名函数；<br>不同的是匿名函数的this为windows或为undefined，<br>而这个this按照词法作用域绑定了，即指向外层调用者。</p>
<h2 id="generator生成器"><a href="#generator生成器" class="headerlink" title="generator生成器"></a>generator生成器</h2><p><a href="https://www.cnblogs.com/diligenceday/p/5488037.html">参考链接</a><br>特性：function与函数名之间又一个*号，函数内部yield表达式；<br>功能：自动生成并返回迭代器，调用next方法开始运行，移动迭代器指针，直到移到函数末尾，返回undefined。<br>如果给next传参数，那么该参数作为上一个yield语句的返回值；<br>注：为异步操作。</p>
<h2 id="vue双向数据绑定"><a href="#vue双向数据绑定" class="headerlink" title="vue双向数据绑定"></a>vue双向数据绑定</h2><ol>
<li>遍历data对象；</li>
<li>添加Observer对象：Object.defineProperty()数据劫持————getter、setter；<br>getter中初始化Watcher，用于依赖收集Dep；setter触发数据变更事件notify通知Watcher，用于派发更新；<h2 id="手写一个单例模式"><a href="#手写一个单例模式" class="headerlink" title="手写一个单例模式"></a>手写一个单例模式</h2><h3 id="直接执行函数，闭包封装instance"><a href="#直接执行函数，闭包封装instance" class="headerlink" title="直接执行函数，闭包封装instance"></a>直接执行函数，闭包封装instance</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var A;</span><br><span class="line">(function(name)&#123;</span><br><span class="line">	var instance;</span><br><span class="line">	A=function(name)&#123;</span><br><span class="line">		if(instance)&#123;</span><br><span class="line">			return instance;</span><br><span class="line">		&#125;</span><br><span class="line">		instance=this</span><br><span class="line">		this.name=name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;());</span><br><span class="line">var a=new A();</span><br><span class="line">var b=new A(); // a===b</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>var,let,function都会发生变量提升；<br>var：变量声明首先进入内存，相当于提升到了当前作用域顶部，但是没有初始化和赋值；<br>可以在还没有声明赋值时调用该变量，值为undefined；<br>let：也存在变量声明，不同的是出现暂时性死区，在赋值之前不允许该值调用；<br>function：变量提升，同时函数赋值也放到了顶部。</p>
<h2 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h2><p>JavaScipt是单线程的；<br>同步任务：在执行栈中按顺序执行，后面的任务必须等待前面任务执行完成；<br>异步任务：挂载出来的任务，不会进入主线程，而进入任务队列；当异步任务完成，则在任务队列中增加进入标志，主线程可在同步任务执行完成后，读取该任务到执行栈中，执行回调函数；</p>
<p>settimeout异步任务，在经过等待的时间后，才有可能被读取到执行栈中，或者是继续等待执行栈中同步任务与任务队列前面的异步任务执行结束。</p>
<h2 id="node-js事件循环"><a href="#node-js事件循环" class="headerlink" title="node.js事件循环"></a>node.js事件循环</h2><p>nextTick:在读取任务队列前进行，即在所有异步任务之前；<br>setImediate:在下一个eventloop时执行，即所有异步任务之后。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>所有的构造函数都有存在一个原型对象，prototype指针指向该原型对象；<br>由该函数构造的实例都可继承原型对象，__proto__指向；<br>该原型对象存在constructor属性指回构造函数。<br>原型链即原型对象为另外一个对象的实例，构成原型链条；<br>当读取当前实例属性或方法时，从实例，到原型，再由下至上去父类的原型中找，最终到Object的原型；<br>因为所有函数都由Object继承而来，原型链的最顶部是Object的原型。</p>
<h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><h2 id="键头函数的this指向和普通函数的区别"><a href="#键头函数的this指向和普通函数的区别" class="headerlink" title="键头函数的this指向和普通函数的区别"></a>键头函数的this指向和普通函数的区别</h2><h2 id="Vue-Router生命周期"><a href="#Vue-Router生命周期" class="headerlink" title="Vue Router生命周期"></a>Vue Router生命周期</h2><h2 id="网页的优化"><a href="#网页的优化" class="headerlink" title="网页的优化"></a>网页的优化</h2><h2 id="怎么判断数组"><a href="#怎么判断数组" class="headerlink" title="怎么判断数组"></a>怎么判断数组</h2><h2 id="webpack原理？有没有自己配过"><a href="#webpack原理？有没有自己配过" class="headerlink" title="webpack原理？有没有自己配过"></a>webpack原理？有没有自己配过</h2><h1 id="项目整理"><a href="#项目整理" class="headerlink" title="项目整理"></a>项目整理</h1><h2 id="统一入口平台"><a href="#统一入口平台" class="headerlink" title="统一入口平台"></a>统一入口平台</h2><h3 id="如何部署项目pm2"><a href="#如何部署项目pm2" class="headerlink" title="如何部署项目pm2"></a>如何部署项目pm2</h3><p>带有负载均衡功能的Node应用的进程管理器，避免多个终端同时开启，并且可以实现进程永远活着。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run pm2 // npm启动pm2</span><br><span class="line">pm2 deploy deploy.yaml production setup  // 首次部署项目</span><br><span class="line">pm2 start 项目启动文件 --name myname//启动node项目</span><br><span class="line">pm2 list // 列出pm2管理的所有进程信息</span><br></pre></td></tr></table></figure>
<h3 id="权限多选树"><a href="#权限多选树" class="headerlink" title="权限多选树"></a>权限多选树</h3><p>el-tree组件的改进;封装新el-tree与el-select，得到mutil-select-tree;<br>为实现调用该多选树的父组件与相应子组件的通信：<br>父-&gt;子传递数据：<br>父组件在引用时，设置组件属性:data=xxx；子组件中设置props-data 同名属性；<br>(加冒号表示属性为变量或表达式)<br>子-&gt;父传递数据：<br>子组件定义事件childevent：emit(“eventname”,事件中携带的数据);子组件绑定方法@click=’childevent’;父组件在引用子组件时定义@childevent，并编写相应的取数据代码。<br>组件间调用方法：设置refs。</p>
<h2 id="传片系统"><a href="#传片系统" class="headerlink" title="传片系统"></a>传片系统</h2><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>异步组件：将代码分段，防止打包文件过大；使用工厂函数引入全局/局部组件，当需要该组件时，才调用工厂函数，执行异步解析组件，并保存供未来渲染。</p>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>定义：状态管理模式，集中式存储管理应用的所有组件的状态，并保证状态以一种可预测的方式发生变化；<br>解决问题：多个视图依赖同一状态，不同视图需要对同一状态进行操作；<br><strong>state</strong>：在计算属性中获得状态：this.$store.state.count/…mapState({});<br><strong>getter</strong>：认为是store的计算属性，根据依赖值缓存，对state进行过滤等操作；<br>使用方法：this.$store.getters.doneTodosCount/this.$store.getters.getTodoById(2)/…mapGetters([]);<br><strong>mutation</strong>：更改状态的唯一方式是提交mutation，同步操作，事件类型+回调函数；<br>触发：store.commit({<br>  type: ‘increment’,<br>  amount: 10<br>})  /<br> …mapMutations([])<br><strong>action</strong>:提交mutation，可以包含任意异步操作；<br>触发：store.dispatch(‘increment’)/…mapActions([])</p>
<h3 id="页面权限控制"><a href="#页面权限控制" class="headerlink" title="页面权限控制"></a>页面权限控制</h3><p>钩子函数，在每一个路由变化中，判断是否存在token；<br>true：不为登录页则获取当前用户信息；<br>false：不在白名单中则跳转回登录页；<br>router.beforeEach(async(to,from,next))</p>
<h3 id="vue生命周期钩子函数"><a href="#vue生命周期钩子函数" class="headerlink" title="vue生命周期钩子函数"></a>vue生命周期钩子函数</h3><p>beforeCreated created beforeMounted mounted beforeUpdated updated beforeDestoryed destroyed<br>created创建实例，获取data属性；（在这里执行DOM操作时一定要放在Vue.nextTick()回调函数中；<br>mounted渲染DOM，获取el属性。</p>
<h3 id="vue-router钩子函数"><a href="#vue-router钩子函数" class="headerlink" title="vue-router钩子函数"></a>vue-router钩子函数</h3><p>全局：beforeEach,afterEach;<br>路由：beforeEnter,afterEnter;<br>组件：beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave.</p>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p><strong>原理：</strong>Vue异步执行DOM更新，当数据改变时，Vue开启队列，存放与该事件循环相关的数据改变；<br>当下一次事件循环tick中，再清空该队列，并且执行相关操作。<br><strong>使用情况：</strong>created中涉及DOM操作；在数据变化后中需要进行涉及随数据改变的DOM的操作；</p>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>通过少量数据交换，实现页面部分的异步更新；<br>vue.js 2.0 推荐使用axios;<br>基本使用方法：axios.post(url,{}).then().catch();<br>请求配置项：url,method,baseURL,headers,params,data,timeout,responseType;<br>响应信息：data，status,statusText,headers,config;<br>可设置拦截器:axios.interceptors.request.use()；<br>可默认设置配置：axios.default.baseURL;</p>
<h3 id="http头部信息"><a href="#http头部信息" class="headerlink" title="http头部信息"></a>http头部信息</h3><p><strong>请求：</strong><br>User-Agent浏览器信息；<br>Accept：接受的数据格式；<br>Content-Type:服务器文件类型；<br>connection：连接形式：保持连接keep-alive/关闭close；<br>Authorization：客户端回应身份验证信息；<br>If-None-Match:对应Etag，判断上次的资源标志是否有更改；<br>If-Modified-Since：对应Last-Modified，判断上次的更改时间后是否有更改；<br><strong>响应：</strong><br>status：服务器处理结果；<br>Expires：实体过期时间；<br>Cache-Control：告诉客户端缓存规则；<br>Last-Modified:最近一次修改时间；<br>Etag：资源标志；<br>Age：距离上次缓存没更新的时间；</p>
<h3 id="vue-cli脚手架快速搭建项目"><a href="#vue-cli脚手架快速搭建项目" class="headerlink" title="vue-cli脚手架快速搭建项目"></a>vue-cli脚手架快速搭建项目</h3><p>可自动生成vue项目，webpack打包；</p>
<h3 id="vue全家桶"><a href="#vue全家桶" class="headerlink" title="vue全家桶"></a>vue全家桶</h3><p>vue-cli+vue-router+vuex+ElementUI</p>
<h3 id="chart组件式开发"><a href="#chart组件式开发" class="headerlink" title="chart组件式开发"></a>chart组件式开发</h3><h4 id="定义子组件并引出"><a href="#定义子组件并引出" class="headerlink" title="定义子组件并引出"></a>定义子组件并引出</h4><p>export default{<br>    name:…,<br>    props:{ // 自定义图表组件传递属性给echart：<br>        className:{<br>            type:String,<br>            default:’…’<br>        }<br>    }<br>    data(){<br>        return {</p>
<pre><code>    &#125;
&#125;
methods:&#123;

&#125;
</code></pre>
<p>}</p>
<h4 id="父组件中引入子组件"><a href="#父组件中引入子组件" class="headerlink" title="父组件中引入子组件"></a>父组件中引入子组件</h4><p>import<br>再引出给别的组件作子组件<br>要设置:components:{children}<br>页面中使用```<children /></p>
<h4 id="chart-resize防抖"><a href="#chart-resize防抖" class="headerlink" title="chart resize防抖"></a>chart resize防抖</h4><p><strong>mounted阶段:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.__resizeHandler = debounce(() =&gt; &#123; // 防抖</span><br><span class="line">      if (this.chart) &#123;</span><br><span class="line">        this.chart.resize()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 100)</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, this.__resizeHandler) // 添加事件监听</span><br></pre></td></tr></table></figure>
<p><strong>beforeDestory:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!this.chart) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">window.removeEventListener(&#x27;resize&#x27;, this.__resizeHandler) // 移除事件监听</span><br><span class="line">this.chart.dispose()</span><br><span class="line">this.chart = null</span><br></pre></td></tr></table></figure>

<h3 id="el-tabs-选项卡切换"><a href="#el-tabs-选项卡切换" class="headerlink" title="el-tabs 选项卡切换"></a>el-tabs 选项卡切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;el-tabs v-model=&quot;activeName&quot; type=&quot;card&quot; @tab-click=&quot;handleClick&quot;&gt;</span><br><span class="line"> 	&lt;el-tab-pane v-for=&quot;item in tabMapOptions&quot; :key=&quot;item.key&quot; :label=&quot;item.label&quot; :name=&quot;item.key&quot;&gt;</span><br><span class="line">        &lt;keep-alive&gt;</span><br><span class="line">          &lt;tab-pane v-if=&quot;item.key===&#x27;yes&#x27;&quot; /&gt;</span><br><span class="line">          &lt;tann-pane v-if=&quot;item.key===&#x27;no&#x27;&quot; /&gt;</span><br><span class="line">        &lt;/keep-alive&gt;</span><br><span class="line">    &lt;/el-tab-pane&gt;</span><br><span class="line">&lt;/el-tabs&gt;</span><br></pre></td></tr></table></figure>
<p>tab-pane与tann-pane为子组件，以v-if判断item.key，显示对应的界面。<br>keep-alive 对经常使用的界面保存组件状态，直接从缓存中读取，避免重复渲染。</p>
<h3 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h3><p>CSS预处理器，先有SASS，后有SCSS；<br>分段加载scss文件，将其组合为完整的css规则；</p>
<ol>
<li>$嵌入变量，#{}嵌入字符串;</li>
<li>&amp;表示父选择器;</li>
<li>可嵌套;</li>
<li>引入：@import …;</li>
<li>mixin声明需要复用的CSS声明，include调用该片段：@mixin @include;</li>
<li>继承：%style @extend</li>
<li>可用操作符计算样式；</li>
<li>命名空间内嵌套属性；</li>
<li>@if @else @for;</li>
<li>方法定义@function;</li>
</ol>
<h3 id="服务器读取图片"><a href="#服务器读取图片" class="headerlink" title="服务器读取图片"></a>服务器读取图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$http.get(&#x27;http://localhost:8088/project/image/byname/&#x27; + this.piclocal,</span><br><span class="line">    &#123; responseType: &#x27;arraybuffer&#x27; &#125;).then(response =&gt; &#123;</span><br><span class="line">        const data = response.data</span><br><span class="line">        console.log(response)</span><br><span class="line">        this.url = &#x27;data:image/png;base64,&#x27; + btoa(new Uint8Array(data).reduce((data, byte) =&gt; data + String.fromCharCode(byte), &#x27;&#x27;))</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>后台将byte数组传送给前端，前台解析图片在页面上展示：<br>btoa方法转换base-64编码；<br>reduce为Array对象的一个方法，接受一个函数作为累加器，数组从左到右开始累加,<br>reduce(function(total,currentValue,currentIndex,arr),initialValue);</p>
<h1 id="字节面经"><a href="#字节面经" class="headerlink" title="字节面经"></a>字节面经</h1><h2 id="css怎么实现动画"><a href="#css怎么实现动画" class="headerlink" title="css怎么实现动画"></a>css怎么实现动画</h2><ol>
<li>animation设置<br>animation-duration:动画时间；<br>animation-delay:动画延迟播放时间；<br>animation-timing-function:速度时间函数linear；<br>animation-direction:进行下一个动画方向alternative；<br>animation-iteration-count:重复播放次数infinite；<br>animation-play-state:动画状态paused|running;</li>
<li>transition设置<br>transition: property duration timing-function delay<br>在hover上设置变化属性;</li>
</ol>
<h2 id="css怎么画三角形"><a href="#css怎么画三角形" class="headerlink" title="css怎么画三角形"></a>css怎么画三角形</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.triangle &#123;</span><br><span class="line">	width:0;</span><br><span class="line">	height:0;</span><br><span class="line">	border-width:0 50px 100px 50px;</span><br><span class="line">	border-color:transparent transparent red transparent;</span><br><span class="line">	border-style:solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css怎么画圆形"><a href="#css怎么画圆形" class="headerlink" title="css怎么画圆形"></a>css怎么画圆形</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.circle &#123;</span><br><span class="line">	width:100px;</span><br><span class="line">	height:100px;</span><br><span class="line">	border-radius:50%;</span><br><span class="line">	background:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css画扇形"><a href="#css画扇形" class="headerlink" title="css画扇形"></a>css画扇形</h2><p>利用border 设置radius,其他border颜色设置为transparent，可得出一个90度的扇形；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.sector</span><br><span class="line">&#123;</span><br><span class="line">	width:0;</span><br><span class="line">	height:0;</span><br><span class="line">	border-width:50px 50px 50px 50px;</span><br><span class="line">	border-color:transparent yellow transparent transparent;</span><br><span class="line">	border-style:solid;</span><br><span class="line">	border-radius:50%;</span><br><span class="line">	transform:rotate(-45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画多个角度的<br>不知道为啥？？不行！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.circle &#123;</span><br><span class="line">	width:100px;</span><br><span class="line">	height:100px;</span><br><span class="line">	position:relative:</span><br><span class="line">	overflow:hidden;</span><br><span class="line">	border-radius:50%;</span><br><span class="line">	background:red;</span><br><span class="line">	&#125;</span><br><span class="line">.slice</span><br><span class="line">&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	transform-origin:0% 100%;</span><br><span class="line">	overflow:hidden;</span><br><span class="line">	top:0;</span><br><span class="line">	right:0;</span><br><span class="line">	width:50%;</span><br><span class="line">	height:50%;</span><br><span class="line">&#125;</span><br><span class="line">.slice-one</span><br><span class="line">&#123;</span><br><span class="line">	background:green;</span><br><span class="line">	transform:rotate(30deg) skewY(-30deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="setTimeout-setInterval-requestAnimationFrame的区别"><a href="#setTimeout-setInterval-requestAnimationFrame的区别" class="headerlink" title="setTimeout setInterval requestAnimationFrame的区别"></a>setTimeout setInterval requestAnimationFrame的区别</h2><p>setTimeout在一段时间过后执行某种操作，setInterval以一定的时间间隔执行某种操作；<br>setInterval即使执行报错，也会循环执行；<br>使用上述两个进行动画操作，控制DOM，会有掉帧、抖动的情况，因为JS事件循环机制，操作不一定会在特定时间内执行，还有固定时间的原因；<br>所以引入requestAnimationFrame，提供动画API；<br>与setTimeout的几点区别：</p>
<ol>
<li>JS引擎；GUI引擎，与显示屏刷新频率保持一致；</li>
<li>页面隐藏或最小化时，在后台执行；屏幕刷新任务停止；</li>
<li>以固定的时间刷新界面；自动优化。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>python封装算法包（可import）</title>
    <url>/2021/12/28/Python/python%E5%B0%81%E8%A3%85%E7%AE%97%E6%B3%95%E5%8C%85%EF%BC%88%E5%8F%AFimport%EF%BC%89/</url>
    <content><![CDATA[<p>External Libraries&gt;site-packages&gt;ccm_scripts</p>
<p>打包自己的python算法，通过import就能使用</p>
<span id="more"></span>

<h1 id="1-待打包算法的文件结构"><a href="#1-待打包算法的文件结构" class="headerlink" title="1. 待打包算法的文件结构"></a>1. 待打包算法的文件结构</h1><p>CCM_pkg&gt;ccm_scripts为编写算法的目录</p>
<p>CCM_pkg&gt;ccm_scripts&gt;scripts</p>
<p>CCM_pkg&gt;ccm_scripts&gt;utils</p>
<p>两个包中的代码需要打包，则在文件夹下添加_<em>init</em>_.py文件，若有子文件夹，也需要添加</p>
<p><img src="C:\Users\cct\AppData\Roaming\Typora\typora-user-images\image-20211228190754457.png" alt="image-20211228190754457"></p>
<h1 id="2-编写setup-py"><a href="#2-编写setup-py" class="headerlink" title="2. 编写setup.py"></a>2. 编写setup.py</h1><p>根目录文件夹下（CCM_pkg）新建setup.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools <span class="comment"># 需要install</span></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=<span class="string">&quot;CCM&quot;</span>,</span><br><span class="line">    version=<span class="string">&#x27;0.0.1&#x27;</span>,</span><br><span class="line">    include_package_data=<span class="literal">True</span>, <span class="comment"># 是否添加除了py以外的文件</span></span><br><span class="line">    packages=setuptools.find_packages(), <span class="comment"># 直接通过setuptool找到项目相关的包列表（通过是否存在__init__.py文件来判断）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="3-安装相关插件"><a href="#3-安装相关插件" class="headerlink" title="3. 安装相关插件"></a>3. 安装相关插件</h1><p><strong>pip install –upgrade setuptools wheel</strong></p>
<h1 id="4-打包"><a href="#4-打包" class="headerlink" title="4. 打包"></a>4. 打包</h1><p>根目录文件夹下（CCM_pkg）调用命令打包</p>
<p><strong>python setup.py sdist bdist_wheel</strong></p>
<p>出现以下几个内容：</p>
<p><img src="C:\Users\cct\AppData\Roaming\Typora\typora-user-images\image-20211228191737319.png" alt="image-20211228191737319"></p>
<p>dist文件夹下的whl文件即发行包</p>
<p><img src="C:\Users\cct\AppData\Roaming\Typora\typora-user-images\image-20211228191832233.png" alt="image-20211228191832233"></p>
<h1 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h1><p>在一个新的项目中，pip install whl文件路径</p>
<p>则算法包出现在External Libraries&gt;site-packages&gt;ccm_scripts</p>
<p>import即可使用</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/smileyes/p/7657591.html">https://www.cnblogs.com/smileyes/p/7657591.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/161930778">https://zhuanlan.zhihu.com/p/161930778</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python调用c语言代码</title>
    <url>/2021/12/28/Python/python%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>原本的机器学习项目都用python写好，老板这边又出了个新需求，将部分核心代码抽出来，用C编写，然后通过dll的方式引用，目的就是为了隐藏部分核心代码。</p>
<span id="more"></span>

<h1 id="1-编写C代码"><a href="#1-编写C代码" class="headerlink" title="1. 编写C代码"></a>1. 编写C代码</h1><p>使用codeblocks建dll库</p>
<ol>
<li>选择ddl</li>
</ol>
<p><img src="http://r4tsuv730.hd-bkt.clouddn.com/img/image-20211228161228492.png" alt="image-20211228161228492"></p>
<ol start="2">
<li>main.c编写要导出的函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> DLL_EXPORT <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span>* DLL_EXPORT <span class="title">Kernel</span><span class="params">( <span class="keyword">double</span>* x,  <span class="keyword">double</span>* y,  <span class="keyword">int</span> row, <span class="keyword">int</span> col,<span class="keyword">double</span> gamma, <span class="keyword">double</span>* w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">double</span> *res = <span class="literal">NULL</span>;</span><br><span class="line">     res =(<span class="keyword">double</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*row*col);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,row,col); <span class="comment">// c 数组空间创建</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            res[i*col + j] = x[i*col + j] + y[i*col + j]; <span class="comment">// 访问二维指针数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>main.h 编写导出头文件（默认）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  To use this exported function of dll, include this header</span></span><br><span class="line"><span class="comment"> *  in your project.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BUILD_DLL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 这边编写导出的函数名称</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> DLL_EXPORT <span class="title">add_int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span>* DLL_EXPORT <span class="title">Kernel</span><span class="params">(<span class="keyword">double</span>*,<span class="keyword">double</span>*,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">double</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __MAIN_H__</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编译<br>编译成功后在对应文件夹bin/Debug生成dll文件</li>
</ol>
<h1 id="2-C调用dl"><a href="#2-C调用dl" class="headerlink" title="2 C调用dl"></a>2 C调用dl</h1><ol>
<li><p>新建Console Application</p>
</li>
<li><p>main.c代码编写</p>
</li>
</ol>
<p>  注意点：</p>
<ul>
<li>导入头文件”windows.h”</li>
<li>函数定义 typedef int (*addInt)(int,int);</li>
<li>导入DLL: HMODULE LoadLibrary</li>
<li>获得dll的函数：add_int = (addInt)GetProcAddress(hDll, “add_int”);</li>
<li>FreeLibrary</li>
<li>若c参数为二维指针，需要两次malloc</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*addInt)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>** (*myKernel)(<span class="keyword">float</span>**,<span class="keyword">float</span>**,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">float</span>*);</span><br><span class="line">addInt add_int;</span><br><span class="line">myKernel kernel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//asm(&quot;int3&quot;);</span></span><br><span class="line">    HMODULE hDll = LoadLibrary(<span class="string">&quot;dll路径&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDll != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">        add_int = (addInt)GetProcAddress(hDll, <span class="string">&quot;add_int&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> res_add = add_int(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res_add);</span><br><span class="line"></span><br><span class="line">        kernel = (myKernel)GetProcAddress(hDll,<span class="string">&quot;Kernel&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> arr1[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1.1</span>,<span class="number">2.0</span>,<span class="number">3.0</span>&#125;,&#123;<span class="number">1.1</span>,<span class="number">2</span>,<span class="number">3.0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">float</span> arr2[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">float</span> (*temp1)[<span class="number">3</span>] = arr1;</span><br><span class="line">        <span class="keyword">float</span> (*temp2)[<span class="number">3</span>] = arr2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> **x = <span class="literal">NULL</span>;</span><br><span class="line">     x = (<span class="keyword">float</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>*)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            x[i]=(<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                  *(*(x+i)+j) = <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> arr3[<span class="number">3</span>] =&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">float</span> *w = arr3;</span><br><span class="line">        <span class="keyword">float</span>** res = kernel(x,x,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.2</span>,w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %f\n &quot;</span>, i,j,*(*(res+i)+j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    FreeLibrary(hDll);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Python调用Dll"><a href="#3-Python调用Dll" class="headerlink" title="3 Python调用Dll"></a>3 Python调用Dll</h1><ol>
<li>下载与导入ctypes包</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll,c_float,c_int</span><br><span class="line"><span class="keyword">import</span> numpy.ctypeslib <span class="keyword">as</span> npct</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> win32api</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>导入dll</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mykernel = cdll.LoadLibrary(<span class="string">&#x27;dll路径&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>要调用的C函数参数(argtypes)与返回值(restype)都有二维指针，因此需要预先设置</p>
<p>npct.ndpointer表示是指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mykernel.Kernel.argtypes = [npct.ndpointer(dtype=np.float64,ndim=<span class="number">2</span>,shape = (<span class="number">2</span>, <span class="number">3</span>),flags=<span class="string">&#x27;C_CONTIGUOUS&#x27;</span>),</span><br><span class="line">                           npct.ndpointer(dtype=np.float64,ndim=<span class="number">2</span>,shape = (<span class="number">2</span>, <span class="number">3</span>),flags=<span class="string">&#x27;C_CONTIGUOUS&#x27;</span>),</span><br><span class="line">                           c_int,</span><br><span class="line">                           c_int,</span><br><span class="line">                           c_float,</span><br><span class="line">                           npct.ndpointer(dtype=np.float64,ndim=<span class="number">1</span>,flags=<span class="string">&#x27;C_CONTIGUOUS&#x27;</span>)]</span><br><span class="line">    mykernel.Kernel.restype = npct.ndpointer(dtype=np.float64,ndim=<span class="number">2</span>,shape = (<span class="number">2</span>, <span class="number">3</span>),flags=<span class="string">&#x27;C_CONTIGUOUS&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>numpy数组</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=[[1,2,3],[4,5,6]]</span><br><span class="line">   x=np.array(x,dtype=np.float64)</span><br><span class="line">   w=[1,1,1]</span><br><span class="line">   w=np.array(w,dtype=np.float64)</span><br><span class="line">  </span><br><span class="line">   print(&#x27;addreess&#x27;,k)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>调用函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = mykernel.Kernel(x,x,x.shape[0],x.shape[1],c_float(0.1),w)</span><br><span class="line"># res就是返回的二维数组numpy</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Free</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">win32api.FreeLibrary(mykernel._handle)</span><br></pre></td></tr></table></figure>



<p><strong>一个大坑：</strong></p>
<p>python的float32要对应C的float类型，float64对应 double类型，否则会造成地址访问冲突<br>具体报错：exception: access violation reading 0xFFFFFFFFFFFFFFFF</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="!https://www.dazhuanlan.com/hannah_l/topics/1509272">使用ctypes调用C函数库加速Numpy运算</a></p>
<p><a href="!https://blog.csdn.net/qq_29630271/article/details/74012465">Codeblocks上dll的创建和使用</a></p>
<p><a href="!https://cloud.tencent.com/developer/news/333692">Python如何调用DLL函数：C数组与numpy数组传递</a></p>
<p><a href="!https://docs.huihoo.com/scipy/scipy-zh-cn/ctypes_numpy.html">Ctypes和NumPy</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2019/08/29/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>有关动态规划的算法和练习题整体的归纳与总结</p>
<span id="more"></span>
<h2 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h2><ol>
<li>原问题-&gt;子问题</li>
<li>状态</li>
<li>初始状态</li>
<li>状态转移方程<h2 id="eg"><a href="#eg" class="headerlink" title="eg."></a>eg.</h2><h3 id="hduoj1003-Max-Sum"><a href="#hduoj1003-Max-Sum" class="headerlink" title="hduoj1003 Max Sum"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">hduoj1003 Max Sum</a></h3></li>
</ol>
<p> <strong>求一串数字的和最大子序列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct dp&#123;</span><br><span class="line">    int x,val;</span><br><span class="line">&#125; dp[100000];</span><br><span class="line">//dp[i]保存以i位置结尾的子串的最优解</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int time=0;</span><br><span class="line">    int x=1;</span><br><span class="line">    cin&gt;&gt;time;</span><br><span class="line">    while(time--)&#123;</span><br><span class="line">       int num=0;</span><br><span class="line">       int a[100000];</span><br><span class="line">       cin&gt;&gt;num;</span><br><span class="line">       for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">       &#125;</span><br><span class="line">       dp[0].val=a[0];</span><br><span class="line">       dp[0].x=0;</span><br><span class="line">       for(int i=1;i&lt;num;i++)&#123;</span><br><span class="line">            if(dp[i-1].val+a[i]&lt;a[i])&#123;</span><br><span class="line">                dp[i].x=i;</span><br><span class="line">                dp[i].val=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dp[i].x=dp[i-1].x;</span><br><span class="line">                dp[i].val=dp[i-1].val+a[i];</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       int max=-1001;</span><br><span class="line">       int start=0,end=0;</span><br><span class="line">       for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(dp[i].val&gt;max)&#123;</span><br><span class="line">            max=dp[i].val;</span><br><span class="line">            start=dp[i].x;</span><br><span class="line">            end=i;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       cout&lt;&lt;&quot;Case &quot;&lt;&lt;x++&lt;&lt;&quot;:&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;max&lt;&lt;&#x27; &#x27;&lt;&lt;start+1&lt;&lt;&#x27; &#x27;&lt;&lt;end+1&lt;&lt;endl;</span><br><span class="line">		if(time)cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj2084"><a href="#hduoj2084" class="headerlink" title="hduoj2084"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2084">hduoj2084</a></h3><p> <strong>经典数塔问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int dp[1100];</span><br><span class="line">int a[101][101];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">    while(N--)&#123;</span><br><span class="line">        int layer;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;layer);</span><br><span class="line">        //输入金字塔</span><br><span class="line">        for(int i=1;i&lt;=layer;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=i;j++)</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=layer-1;i&gt;=1;i--)&#123;</span><br><span class="line">            for(int j=1;j&lt;=i;j++)&#123;</span><br><span class="line">                a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%dn&quot;,a[1][1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1176"><a href="#hduoj1176" class="headerlink" title="hduoj1176"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1176">hduoj1176</a></h3><p> <strong>gameboy免费馅饼,求获得的最多馅饼量；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int dp[110000][20];</span><br><span class="line">//dp表示i时间段在各个位置上的最佳馅饼数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int x,T;</span><br><span class="line">    int maxT=0;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=0)&#123;</span><br><span class="line">        memset(dp,0,sizeof(dp));</span><br><span class="line">        maxT=0;</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x,&amp;T);</span><br><span class="line">            dp[T][x]++;</span><br><span class="line">            if(T&gt;maxT)maxT=T;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=maxT-1;i&gt;=0;i--)&#123;</span><br><span class="line">            for(int j=0;j&lt;=10;j++)&#123;</span><br><span class="line">                if(j==0)&#123;</span><br><span class="line">                    dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else if(j==10)&#123;</span><br><span class="line">                    dp[i][j]=max(dp[i+1][j],dp[i+1][j-1])+dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j]=max(max(dp[i+1][j-1],dp[i+1][j]),dp[i+1][j+1])+dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%dn&quot;,dp[0][5]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1087"><a href="#hduoj1087" class="headerlink" title="hduoj1087"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1087">hduoj1087</a></h3><p> <strong>Super Jump!跳到比当前大的位置，求从start到end经过的最大和；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int dp[1100];</span><br><span class="line">int a[1100];</span><br><span class="line">//dp作为以i为最后一步时，得到的最佳分数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;N)!=EOF&amp;&amp;N!=0)&#123;</span><br><span class="line">        memset(dp,0,sizeof(dp));</span><br><span class="line">        int i=0;</span><br><span class="line">        int temp=N;</span><br><span class="line">        while(temp--)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">            dp[i]=a[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">            for(int k=0;k&lt;j;k++)&#123;</span><br><span class="line">                if(a[j]&gt;a[k]&amp;&amp;dp[k]+a[j]&gt;dp[j])&#123;</span><br><span class="line">                    dp[j]=dp[k]+a[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       // for(int kk=0;kk&lt;=N;kk++)&#123;printf(&quot;%d &quot;,dp[kk]);&#125;</span><br><span class="line">        printf(&quot;%dn&quot;,*max_element(dp, dp + N));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hduoj1159"><a href="#hduoj1159" class="headerlink" title="hduoj1159"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1159">hduoj1159</a></h3><p> <strong>Common Subsequence经典最长公共子序列问题，构建矩阵；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int dp[1001][1001];</span><br><span class="line">//dp可能因为太大了，所以需要开在全局</span><br><span class="line">//dp矩阵保存当前2个字符串的最长相同子序列长度</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class="line">        int la=a.length();</span><br><span class="line">        int lb=b.length();</span><br><span class="line">        //cout&lt;&lt;la&lt;&lt;&quot; &quot;&lt;&lt;lb&lt;&lt;endl;</span><br><span class="line">        memset(dp,0,sizeof(dp));</span><br><span class="line">        int m=0;</span><br><span class="line">        for(int i=1;i&lt;=la;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=lb;j++)&#123;</span><br><span class="line">                if(a[i-1]==b[j-1])</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">                if(m&lt;dp[i][j])m=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%dn&quot;,m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hash</title>
    <url>/2019/08/30/%E7%AE%97%E6%B3%95/hash/</url>
    <content><![CDATA[<p>哈希表是根据设定的哈希函数和处理冲突的方法将一组关键字映射到一个有限的地址空间上；</p>
<span id="more"></span>
<hr>
<h3 id="hduoj1264"><a href="#hduoj1264" class="headerlink" title="hduoj1264"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1264">hduoj1264</a></h3><p> <strong>counting squares：计算unit，以一个rect[101][101]的数组存放是否数过的标记；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//暴力：</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int rect[110][110];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ax,ay,bx,by;</span><br><span class="line">    int res=0;</span><br><span class="line">    memset(rect,0,sizeof(rect));</span><br><span class="line">    while(scanf(&quot;%d%d%d%d&quot;,&amp;ax,&amp;ay,&amp;bx,&amp;by)!=EOF)&#123;</span><br><span class="line">        if(ax&lt;0)&#123;</span><br><span class="line">            cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">            if(ax==-2)break;//结束</span><br><span class="line">            memset(rect,0,sizeof(rect));</span><br><span class="line">            res=0;</span><br><span class="line">        &#125;</span><br><span class="line">        //还在输入</span><br><span class="line">        if(ax&gt;bx)swap(ax,bx);</span><br><span class="line">        if(ay&gt;by)swap(ay,by);</span><br><span class="line">        for(int i=ax;i&lt;bx;i++)&#123;</span><br><span class="line">            for(int j=ay;j&lt;by;j++)&#123;</span><br><span class="line">                if(rect[i][j]==0)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    rect[i][j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1280"><a href="#hduoj1280" class="headerlink" title="hduoj1280"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1280">hduoj1280</a></h3><p> <strong>将in中两两相加的nX(n-1)/2个值，映射到sum数组中（和作为sum的下标值:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//哈希：</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int in[3001];</span><br><span class="line">int sum[10001];</span><br><span class="line">//将in中两两相加的n*(n-1)/2个值，映射到sum数组中</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //使用暴力法的话</span><br><span class="line">    //3000个整数不管在时间上还是空间上都不ok</span><br><span class="line">    //选择hash</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        memset(in,0,sizeof(in));</span><br><span class="line">        memset(sum,0,sizeof(sum));</span><br><span class="line">        for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;in[i]);</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;n;j++)&#123;</span><br><span class="line">                sum[in[i]+in[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //在sum数组中找到前m大的数</span><br><span class="line">        int tmp=10000;</span><br><span class="line">        bool flag=false;</span><br><span class="line">        while(tmp&gt;=0&amp;&amp;m&gt;0)&#123;</span><br><span class="line">            if(sum[tmp]==0)&#123;</span><br><span class="line">                tmp--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                cout&lt;&lt;&quot; &quot;&lt;&lt;tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else cout&lt;&lt;tmp;</span><br><span class="line">            flag=true;</span><br><span class="line">            sum[tmp]--;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2019/08/30/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>有关贪心算法的练习题整体的归纳与总结</p>
<span id="more"></span>
<h2 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h2><p>贪心：对问题进行求解时，每一步都采取最优的选择；近似最优解；</p>
<ol>
<li>数学模型</li>
<li>原问题-&gt;子问题</li>
<li>得到子问题的局部最优解</li>
<li>把局部最优解整合成整个问题的近似最优解<br>（集合覆盖问题、旅行商问题）<h2 id="eg"><a href="#eg" class="headerlink" title="eg."></a>eg.</h2><h3 id="hduoj1009"><a href="#hduoj1009" class="headerlink" title="hduoj1009"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1009">hduoj1009</a></h3></li>
</ol>
<p> <strong>FatMouse’ Trade：算出比例，从大到小排列，选择；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int t;</span><br><span class="line">&#125;JF[1000];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    double xx=(double)a.x/a.y;</span><br><span class="line">    double yy=(double)b.x/b.y;</span><br><span class="line">    return xx&gt;yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF&amp;&amp;m!=-1&amp;&amp;n!=-1)&#123;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;JF[i].x&gt;&gt;JF[i].y;</span><br><span class="line">            JF[i].t=i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(JF,JF+n,cmp);</span><br><span class="line">        int sum=0;int i;</span><br><span class="line">        for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(m&gt;=JF[i].y)&#123;</span><br><span class="line">                sum+=JF[i].x;</span><br><span class="line">                m=m-JF[i].y;</span><br><span class="line">            &#125;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        double tmp;</span><br><span class="line">        if(m!=0&amp;&amp;i!=n)tmp=(double)(JF[i].x*m)/JF[i].y+sum;</span><br><span class="line">        else tmp=(double)sum;</span><br><span class="line">        printf(&quot;%.3lfn&quot;,tmp);</span><br><span class="line">        /*for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;JF[i].t&lt;&lt;&quot; &quot;&lt;&lt;JF[i].x&lt;&lt;&quot; &quot;&lt;&lt;JF[i].y&lt;&lt;endl;</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1045"><a href="#hduoj1045" class="headerlink" title="hduoj1045"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1045">hduoj1045</a></h3><p> <strong>放置碉堡的问题，麻烦，按照每块干扰的区域数从小到大排列，选择；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">char maze[5][5];</span><br><span class="line">int num;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int value;</span><br><span class="line">&#125;flag[20];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.value&lt;b.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool fire(node n)</span><br><span class="line">&#123;</span><br><span class="line">    int x=n.x;</span><br><span class="line">    int y=n.y;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(maze[i][y]==&#x27;f&#x27;)&#123;</span><br><span class="line">            //证明i与x之间没有墙</span><br><span class="line">            int up,down;</span><br><span class="line">            if(i&gt;x)&#123;</span><br><span class="line">                up=x;</span><br><span class="line">                down=i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                up=i;down=x;</span><br><span class="line">            &#125;</span><br><span class="line">            int tmp=up+1;</span><br><span class="line">            //if(tmp==down)break;</span><br><span class="line">            for(;tmp&lt;down;tmp++)&#123;</span><br><span class="line">                if(maze[tmp][y]==&#x27;X&#x27;)break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp==down)break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i!=num)return false;</span><br><span class="line">    for(j=0;j&lt;num;j++)&#123;</span><br><span class="line">        if(maze[x][j]==&#x27;f&#x27;)&#123;</span><br><span class="line">            //证明j与y之间没有墙</span><br><span class="line">            int l,r;</span><br><span class="line">            if(j&lt;y)&#123;</span><br><span class="line">                l=j;</span><br><span class="line">                r=y;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                l=y;r=j;</span><br><span class="line">            &#125;</span><br><span class="line">            int tmp=l+1;</span><br><span class="line">            //if(tmp==r)break;</span><br><span class="line">            for(;tmp&lt;r;tmp++)&#123;</span><br><span class="line">                if(maze[x][tmp]==&#x27;X&#x27;)break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp==r)break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j!=num)return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;num)!=EOF&amp;&amp;num!=0)&#123;</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;num;j++)</span><br><span class="line">                cin&gt;&gt;maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line">                //cout&lt;&lt;maze[i][j];</span><br><span class="line">                int t=i*num+j;</span><br><span class="line">                flag[t].x=i;</span><br><span class="line">                flag[t].y=j;</span><br><span class="line">                //设计贪心依据数组</span><br><span class="line">                if(maze[i][j]==&#x27;X&#x27;)&#123;</span><br><span class="line">                    flag[t].value=0;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    int count=1;</span><br><span class="line">                    //往上</span><br><span class="line">                    for(int a=i-1;a&gt;=0;a--)&#123;</span><br><span class="line">                        if(maze[a][j]==&#x27;X&#x27;)break;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //往下</span><br><span class="line">                    for(int a=i+1;a&lt;num;a++)&#123;</span><br><span class="line">                        if(maze[a][j]==&#x27;X&#x27;)break;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //往左</span><br><span class="line">                    for(int b=j-1;b&gt;=0;b--)&#123;</span><br><span class="line">                        if(maze[i][b]==&#x27;X&#x27;)break;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //往右</span><br><span class="line">                    for(int b=j+1;b&lt;num;b++)&#123;</span><br><span class="line">                        if(maze[i][b]==&#x27;X&#x27;)break;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag[t].value=count;</span><br><span class="line">                &#125;</span><br><span class="line">                //cout&lt;&lt;flag[t].value;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //从小到大排序</span><br><span class="line">        sort(flag,flag+num*num,cmp);</span><br><span class="line">        //for(int i=0;i&lt;num*num;i++)cout&lt;&lt;flag[i].value&lt;&lt;&quot; &quot;;</span><br><span class="line">        //贪心选择</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;num*num;i++)&#123;</span><br><span class="line">            if(flag[i].value!=0)&#123;//排除墙</span><br><span class="line">                if(fire(flag[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    maze[flag[i].x][flag[i].y]=&#x27;f&#x27;;//已放置标记</span><br><span class="line">                    //cout&lt;&lt;flag[i].x&lt;&lt;&quot; &quot;&lt;&lt;flag[i].y&lt;&lt;&quot; &quot;&lt;&lt;flag[i].value&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1051"><a href="#hduoj1051" class="headerlink" title="hduoj1051"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1051">hduoj1051</a></h3><p> <strong>对长度、宽度进行从小到大排序，先选择小的，向后选择满足条件的然后标记访问；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool vis[5000];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int l;</span><br><span class="line">    int w;</span><br><span class="line">&#125;wood[5000];</span><br><span class="line"></span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">    if(x.l==y.l)&#123;</span><br><span class="line">        return x.w&lt;y.w;</span><br><span class="line">    &#125;</span><br><span class="line">    return x.l&lt;y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int num;</span><br><span class="line">        int sum=0;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            cin&gt;&gt;wood[i].l&gt;&gt;wood[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(wood,wood+num,cmp);</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            //cout&lt;&lt;wood[i].l&lt;&lt;&quot; &quot;&lt;&lt;wood[i].w&lt;&lt;endl;</span><br><span class="line">            if(vis[i])continue;//访问完跳过</span><br><span class="line">            //因为l已经从小到大排序过</span><br><span class="line">            //因此关注w</span><br><span class="line">            int curw=wood[i].w;</span><br><span class="line">            for(int j=i+1;j&lt;num;j++)&#123;</span><br><span class="line">                if(!vis[j]&amp;&amp;curw&lt;=wood[j].w)&#123;</span><br><span class="line">                    //cout&lt;&lt;&quot;ok&quot;;</span><br><span class="line">                    vis[j]=1;//标记访问</span><br><span class="line">                    curw=wood[j].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2019/08/30/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p> <strong>迪杰斯特拉算法</strong>:</p>
<ul>
<li><a href="https://blog.csdn.net/mu399/article/details/50903876">详解</a></li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719">图示</a><span id="more"></span></li>
</ul>
<hr>
<h3 id="hduoj1142"><a href="#hduoj1142" class="headerlink" title="hduoj1142"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1142">hduoj1142</a></h3><p> <strong>算出最短路径后+DFS；（好题）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int edge[1005][1005];</span><br><span class="line">int maxint=1000001;</span><br><span class="line">int vis[1005];//是否访问过</span><br><span class="line">int dist[1005];//源点到i点的最短路径</span><br><span class="line">int path[1005];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void dijstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">    //init</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        vis[i]=0;</span><br><span class="line">        dist[i]=edge[s][i];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s]=1;</span><br><span class="line"></span><br><span class="line">    //使所有的点都访问过，在vis[]内标记为1</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int Min=maxint;</span><br><span class="line">        int tmp=0;</span><br><span class="line">        //找出最小dist[j]</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(Min&gt;dist[j]&amp;&amp;!vis[j])&#123;</span><br><span class="line">                Min=dist[j];</span><br><span class="line">                tmp=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[tmp]=1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(edge[tmp][j]!=maxint&amp;&amp;!vis[j])&#123;</span><br><span class="line">                //存在边</span><br><span class="line">                //试图更新</span><br><span class="line">                int d=Min+edge[tmp][j];</span><br><span class="line">                if(d&lt;dist[j])&#123;</span><br><span class="line">                    dist[j]=d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //for(int i=1;i&lt;=n;i++)cout&lt;&lt;dist[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DFS(int x)</span><br><span class="line">&#123;</span><br><span class="line">    //遇到算过的路径</span><br><span class="line">    if(path[x]!=-1)&#123;</span><br><span class="line">        return path[x];</span><br><span class="line">    &#125;</span><br><span class="line">    //遇到结尾2,1条路径</span><br><span class="line">    if(x==2)&#123;return 1;&#125;</span><br><span class="line">    path[x]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(edge[x][i]!=maxint&amp;&amp;dist[i]&lt;dist[x])&#123;</span><br><span class="line">            path[x]+=DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return path[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!n)break;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                edge[i][j]=maxint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int x,y,d;</span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;d);</span><br><span class="line">            edge[x][y]=d;</span><br><span class="line">            edge[y][x]=d;//无向图</span><br><span class="line">        &#125;</span><br><span class="line">        dijstra(2);</span><br><span class="line">        dist[2]=0;//少了这一步的话，</span><br><span class="line">                  //dist[2]为maxint，很大</span><br><span class="line">                  //不能满足dist[i]&lt;dist[x]条件</span><br><span class="line">        memset(path,-1,sizeof(path));</span><br><span class="line">        cout&lt;&lt;DFS(1)&lt;&lt;endl;</span><br><span class="line">        //for(int i=1;i&lt;=n;i++)cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj2544"><a href="#hduoj2544" class="headerlink" title="hduoj2544"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">hduoj2544</a></h3><p> <strong>基础最短路径图，求出源点到终点的路径长度；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int edge[105][105];</span><br><span class="line">int maxint=999999;</span><br><span class="line">int vis[105];//是否访问过</span><br><span class="line">int dist[105];//源点到i点的最短路径</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">int dijstra()</span><br><span class="line">&#123;</span><br><span class="line">    //init</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        vis[i]=0;</span><br><span class="line">        dist[i]=edge[1][i];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[1]=1;</span><br><span class="line"></span><br><span class="line">    //使所有的点都访问过，在vis[]内标记为1</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int Min=maxint;</span><br><span class="line">        int tmp=0;</span><br><span class="line">        //找出最小dist[j]</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(Min&gt;dist[j]&amp;&amp;!vis[j])&#123;</span><br><span class="line">                Min=dist[j];</span><br><span class="line">                tmp=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[tmp]=1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(edge[tmp][j]!=maxint&amp;&amp;!vis[j])&#123;</span><br><span class="line">                //存在边</span><br><span class="line">                //试图更新</span><br><span class="line">                int d=Min+edge[tmp][j];</span><br><span class="line">                if(d&lt;dist[j])&#123;</span><br><span class="line">                    dist[j]=d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //for(int i=1;i&lt;=n;i++)cout&lt;&lt;dist[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;</span><br><span class="line">    return dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;m&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)</span><br><span class="line">                edge[i][j]=maxint;</span><br><span class="line">        &#125;</span><br><span class="line">        int x,y,d;</span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;d);</span><br><span class="line">            edge[x][y]=d;</span><br><span class="line">            edge[y][x]=d;//无向图</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;dijstra()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图匹配</title>
    <url>/2019/08/30/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/dark_scope/article/details/8880547">匈牙利算法</a><br>腾，有机会上，没机会创造机会也要上；</p>
<span id="more"></span>
<h3 id="hduoj2063"><a href="#hduoj2063" class="headerlink" title="hduoj2063"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063">hduoj2063</a></h3><p> <strong>经典，求最大匹配；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int girls[505];//存放男孩的匹配女孩</span><br><span class="line">bool flag[505];//存放标记</span><br><span class="line">bool relation[505][505];//存放关系</span><br><span class="line">int k,m,n;</span><br><span class="line"></span><br><span class="line">//第x个女孩找匹配对象</span><br><span class="line">bool f(int x)</span><br><span class="line">&#123;</span><br><span class="line">    for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        if(relation[x][j]&amp;&amp;!flag[j])&#123;</span><br><span class="line">            flag[j]=1;</span><br><span class="line">            if(girls[j]==0||f(girls[j]))&#123;</span><br><span class="line">                girls[j]=x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;k)!=EOF&amp;&amp;k!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        int x,y;</span><br><span class="line">        memset(relation,0,sizeof(relation));</span><br><span class="line">        memset(girls,0,sizeof(girls));</span><br><span class="line">        for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            relation[x][y]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            memset(flag,0,sizeof(flag));</span><br><span class="line">            if(f(i+1))sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1068"><a href="#hduoj1068" class="headerlink" title="hduoj1068"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1068">hduoj1068</a></h3><p> <strong>求没有关系的最大子集：总数-最大匹配数/2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int maze[1010][1010];</span><br><span class="line">bool vis[1010];</span><br><span class="line">int flag[1010];</span><br><span class="line">int num;</span><br><span class="line"></span><br><span class="line">bool f(int x)</span><br><span class="line">&#123;</span><br><span class="line">    for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line">        if(maze[x][j]==1&amp;&amp;!vis[j])&#123;</span><br><span class="line">            vis[j]=1;</span><br><span class="line">            if(flag[j]==-1||f(flag[j]))&#123;</span><br><span class="line">                flag[j]=x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;num)!=EOF)&#123;</span><br><span class="line">        memset(maze,0,sizeof(maze));</span><br><span class="line">        int a,b;</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            scanf(&quot;%d: (%d)&quot;,&amp;a,&amp;b);</span><br><span class="line">            int tmp=0;</span><br><span class="line">            for(int j=0;j&lt;b;j++)&#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;tmp);//使用cin超时</span><br><span class="line">                maze[i][tmp]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum=0;</span><br><span class="line">        memset(flag,-1,sizeof(flag));</span><br><span class="line">        //第i个学生的是否可配对</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            memset(vis,0,sizeof(vis));</span><br><span class="line">            if(f(i))sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        //学生总数-最大匹配数/2</span><br><span class="line">        cout&lt;&lt;num-sum/2&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>查找与排序</title>
    <url>/2019/08/31/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul>
<li>顺序查找又称线性查找。它的过程为：<strong>从查找表的最后一个元素开始逐个与给定关键字比较</strong>，若某个记录的关键字和给定值比较相等，则查找成功，否则，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录查找不成功，它的缺点是效率低下。</li>
</ul>
<span id="more"></span>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li>简介<br>基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x，算法中止；如果x &lt; a[n/2]，则只要在数组a的左半部分继续搜索x，如果x &gt; a[n/2]，则只要在数组a的右半部搜索x。<br>二分查找的时间复杂度为O(logn)</li>
<li>实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BinSearch(int low,int high,int target)</span><br><span class="line">&#123;</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        int mid=(low+high)/2;</span><br><span class="line">        if(target==arr[mid])return mid;</span><br><span class="line">        else if(arr[mid]&gt;target)&#123;</span><br><span class="line">            high=mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else low=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2></li>
<li>简介<br>基本思想是：设排序序列的记录个数为n，进行n-1次遍历，每次遍历从开始位置依次往后比较前后相邻元素，这样较大的元素往后移，n-1次遍历结束后，序列有序。</li>
<li>实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//冒泡排序：从小到大</span><br><span class="line">void BubbleSort(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    int flag=true;</span><br><span class="line">    for(int i=0;i&lt;len-1;i++)&#123;//len-1次冒泡</span><br><span class="line">        if(!flag)break;</span><br><span class="line">        flag=false;</span><br><span class="line">        for(int j=0;j&lt;len-i-1;j++)&#123;//去除最后一个已到位的</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                swap(arr[j+1],arr[j]);</span><br><span class="line">                flag=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分析<br>最佳情况下冒泡排序只需一次遍历就能确定数组已经排好序，不需要进行下一次遍历，所以最佳情况下，时间复杂度为**O(n)<strong>。<br>最坏情况下冒泡排序需要n-1次遍历，第一次遍历需要比较n-1次，第二次遍历需要n-2次，…，最后一次需要比较1次，最差情况下时间复杂度为</strong>O(n^2)**。<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2></li>
<li>简介<br>设排序序列的记录个数为n，进行n-1次选择，每次在n-i+1(i = 1,2,…,n-1)个记录中选择关键字最小的记录作为有效序列中的第i个记录。</li>
<li>实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//选择排序，从小到大</span><br><span class="line">void SelectSort(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;len-1;i++)&#123;</span><br><span class="line">        int mini=i;</span><br><span class="line">        for(int j=i+1;j&lt;len;j++)&#123;</span><br><span class="line">            if(arr[mini]&gt;arr[j])&#123;</span><br><span class="line">                mini=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i],arr[mini]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分析<br>进行比较操作的时间复杂度为 O(n^2) ，进行移动操作的时间复杂度为 O(n) 。总的时间复杂度为<strong>O(n^2)</strong><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2></li>
<li>简介<br>思想：是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。</li>
<li>实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//直接插入排序，从小到大</span><br><span class="line">void DInsertSort(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    int now=0;</span><br><span class="line">    for(int i=1;i&lt;len;i++)&#123;</span><br><span class="line">        now=arr[i];</span><br><span class="line">        int j=i-1;</span><br><span class="line">        for(;j&gt;=0;j--)&#123;</span><br><span class="line">            if(arr[j]&lt;now)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+1]=arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+1]=now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分析<br>最好情况下，当待排序序列中记录已经有序时，则需要n-1次比较，不需要移动，时间复杂度为<strong>O(n)</strong> 。最差情况下，当待排序序列中所有记录正好逆序时，则比较次数和移动次数都达到最大值，时间复杂度为<strong>O(n^2)</strong> 。平均情况下，时间复杂度为**O(n^2)**。<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2></li>
<li>简介<br>归并排序是<strong>分治法</strong>的一个典型应用，它的主要思想是：将待排序序列分为两部分，对每部分递归地应用归并排序，在两部分都排好序后进行合并。</li>
<li>实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//归并排序：从小到大</span><br><span class="line">//#define Max 1000</span><br><span class="line">int Merge(int A[],int p,int q,int r)</span><br><span class="line">&#123;</span><br><span class="line">    int n1=q-p+1;</span><br><span class="line">    int n2=r-q;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    //用2个数组分别存放目标A[]数组</span><br><span class="line">    //p~q与q+1~r的数</span><br><span class="line">    int L[n1+1],R[n1+1];</span><br><span class="line">    for(i=0;i&lt;n1;i++)&#123;</span><br><span class="line">        L[i]=A[p+i];</span><br><span class="line">    &#125;</span><br><span class="line">    L[i]=Max;</span><br><span class="line">    for(j=0;j&lt;n2;j++)&#123;</span><br><span class="line">        R[j]=A[q+j+1];</span><br><span class="line">    &#125;</span><br><span class="line">    R[j]=Max;</span><br><span class="line">    i=0;j=0;</span><br><span class="line">    //合并L[]与R[]数组</span><br><span class="line">    for(int k=p;k&lt;=r;k++)&#123;</span><br><span class="line">        if(L[i]&lt;=R[j])&#123;</span><br><span class="line">            A[k]=L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            A[k]=R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MergeSort(int A[],int p,int r)</span><br><span class="line">&#123;</span><br><span class="line">    int q=0;</span><br><span class="line">    if(p&lt;r)&#123;</span><br><span class="line">        q=(p+r)/2;</span><br><span class="line">        MergeSort(A,p,q);</span><br><span class="line">        MergeSort(A,q+1,r);</span><br><span class="line">        Merge(A,p,q,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">//MergeSort(array,0,len-1);</span><br></pre></td></tr></table></figure></li>
<li>分析<br>时间复杂度为O(nlogn)<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li>
<li>简介<br>主要思想是：在待排序的序列中选择一个称为主元的元素，将数组分为两部分，使得第一部分中的所有元素都小于或等于主元，而第二部分中的所有元素都大于主元，然后对两部分递归地应用快速排序算法。</li>
<li>实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//快速排序：从小到大</span><br><span class="line">//实现对子数组A[p,r]的原址重拍</span><br><span class="line">int PARTITION(int A[],int p,int r)</span><br><span class="line">&#123;</span><br><span class="line">    int x=A[r];</span><br><span class="line">    //i作为比x小的位置标记</span><br><span class="line">    int i=p-1;</span><br><span class="line">    int j;</span><br><span class="line">    for(j=p;j&lt;r;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(A[j]&lt;=x)&#123;</span><br><span class="line">        //使i+1到j之前严格大于A[r]</span><br><span class="line">            i=i+1;</span><br><span class="line">            swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i=i+1;</span><br><span class="line">    swap(&amp;A[i],&amp;A[r]);</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void QUICKSORT(int A[],int p,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(p&lt;r)&#123;</span><br><span class="line">        int x=PARTITION(A,p,r);</span><br><span class="line">        QUICKSORT(A,p,x-1);</span><br><span class="line">        QUICKSORT(A,x+1,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//QUICKSORT(array,0,len-1);</span><br></pre></td></tr></table></figure></li>
<li>分析<br>最差情况下算法需要(n-1)+(n-2)+…+1= <strong>O(n^2)</strong> 时间;<br>最佳情况下，每次主元将数组划分为规模大致相等的两部分，时间复杂度为**O(nlogn)**。<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2></li>
<li>简介<br>堆性质(小根堆)：(1) ki &lt;= k(2i）且 ki &lt;= k(2i+1) (1 ≤ i≤ n/2），即完全二叉树中所有的非终端节点的值均不大于（或不小于）其左右孩子节点的值。<br>主要思想是：给定一个待排序序列，首先经过<strong>一次调整</strong>，将序列构建成一个大根堆，此时第一个元素是最大的元素，将其和序列的最后一个元素交换，然后对<strong>前n-1个</strong>元素调整为大根堆，再将其第一个元素和末尾元素交换，这样最后即可得到有序序列。</li>
<li>实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//堆排序：小到大</span><br><span class="line">void MAX_HEAPIF(int A[],int i)</span><br><span class="line">&#123;</span><br><span class="line">    int x=2*(i+1);</span><br><span class="line">    int l=x-1;</span><br><span class="line">    int r=x;</span><br><span class="line">    int largest=i;</span><br><span class="line">    if(l&lt;Heap_Size&amp;&amp;A[i]&lt;A[l])&#123;</span><br><span class="line">        largest=l;</span><br><span class="line">    &#125;</span><br><span class="line">    if(r&lt;Heap_Size&amp;&amp;A[largest]&lt;A[r])&#123;</span><br><span class="line">        largest=r;</span><br><span class="line">    &#125;</span><br><span class="line">    if(largest!=i)&#123;//根节点比他的孩子结点小，需要交换</span><br><span class="line">        int f=A[i];</span><br><span class="line">        A[i]=A[largest];</span><br><span class="line">        A[largest]=f;</span><br><span class="line"></span><br><span class="line">    //为保持以孩子结点为根节点的堆为最大堆</span><br><span class="line">    MAX_HEAPIF(A,largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将最原始的数组变为最大堆</span><br><span class="line">//需要从最底下的非叶子结点往上建</span><br><span class="line">void BUILD_MAX_HEAP(int A[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int node=n/2;</span><br><span class="line">    for(int i=node-1;i&gt;=0;i--)&#123;</span><br><span class="line">        MAX_HEAPIF(A,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//堆排序算法</span><br><span class="line">void HEAP_SORT(int A[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    BUILD_MAX_HEAP(A,n);</span><br><span class="line">    //建一个最大堆之后，每次将根节点与Heap_size最后一个结点置换，再继续建最大堆</span><br><span class="line">    //直到Heap_size为1</span><br><span class="line">    while(Heap_Size&gt;1)&#123;</span><br><span class="line">        int f=A[Heap_Size-1];</span><br><span class="line">        A[Heap_Size-1]=A[0];</span><br><span class="line">        A[0]=f;</span><br><span class="line"></span><br><span class="line">        Heap_Size--;</span><br><span class="line"></span><br><span class="line">        MAX_HEAPIF(A,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Heap_Size=len;</span><br><span class="line">//HEAP_SORT(array,len);</span><br></pre></td></tr></table></figure></li>
<li>分析<br>由于建初始堆所需的比较次数较多，所以堆排序<strong>不适宜于记录数较少的文件</strong>。堆排序时间复杂度也为**O(nlogn)**，空间复杂度为O(1)。它是不稳定的排序方法。与快排和归并排序相比，堆排序在最差情况下的时间复杂度优于快排，空间效率高于归并排序。<br><a href="https://blog.csdn.net/tianlihua306/article/details/44621827">二叉树的性质</a><br><img src="/img/sort.webp" alt="各种常用排序算法"><br><a href="https://www.jianshu.com/p/42f81846c0fb">常见数据结构与算法整理</a></li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>非比较排序；[0,MAX]格子的桶；</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>桶排序的延伸，预处理成数位相同，从个位开始到最高位，依次桶排序</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>保研历程</title>
    <url>/2019/09/30/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/%E4%BF%9D%E7%A0%94%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<p>今天是9.30日，离填完系统已经过了2天，离浙大面试过了有5天了，还是觉得很难过，尤其在是社交网络上看到自己身边的人收获了一大堆的美好，就好像最后只有我，两手空空。不完满是人生的常态吧，这几个月以来的纠结和痛苦虽然没有一个很好的结果，但是并非没有意义，这个意义的量化就在于我在这次失败中吸取了怎样的教训，做出了多少的改变。</p>
<span id="more"></span>
<p>从今年寒假来学校才真正萌生出想要保研的念头（很惭愧，大学前三年都喂了狗），同时又在纠结，或许我拿不到保研名额？或许直接工作才能使收益最大化？于是边想着投简历，边纠结保研的事情。果真大三真是焦虑的顶峰，尤其是像我这种人，想着“船到桥头自然直”，对未来没有任何的规划，混日子般同时可笑地维持着自己的绩点，不知道浪费了多少时间。<br>保研的大部分时间都是一边怀疑自己一边前进的，知道保研资格出来后，才逐渐坚定，导致大部分时间不是来琢磨如何才能在保研这条路上走得更好，而是思考这条路有没有意义，这也是导致最终结果的最主要原因了。<br>一直都不自信，于是懒于尝试，不敢走出舒适圈，不管是在这条路上，亦或者大学前三年都是这样。试想如果尝试多投一点学校，选择的机会是不是就会更多些，就算没有，也是不断地在积累经验了，而不是造成最后极端被动，吊死在一棵树上。还有如果大学多尝试一些比赛，对提升自我的事情多一点坚持，简历上也不至于空空。<br>我的面试水平也太菜了点，似乎一直以来都是这样，不善于在别人面前表现自己，在老师专业问题的狂轰乱炸下，逐渐乱了阵脚。当然也是我的专业知识属实太不扎实了，大学三年绩点虽然高，其实都是考前速成，面向应试的专业课学习，实际上在课堂上没有任何收获。之前甚至为课堂上不学习，仅仅考前努力一把都能取得不错的成绩而沾沾自喜，真是太羞愧了。老师的一句话让我印象深刻，“不管你是在研究生面试，甚至以后企业面试，看重的都是你真正内化的在你脑子里的知识，而不是成绩单上的数字。”<br>老师问过我一个关于项目的问题，“识别的准确率有多少？”，我懵圈了，既然是参与到这个项目中去的，我确确实实不知道并且从没有了解过。在做这个创新创业项目时确实缺少思考，只做最简单的代码搬运工，这个过程很累，也花费了很多时间，但是没有意义啊！</p>
<p>总结保研失败的几点原因：</p>
<ol>
<li>不自信，在怀疑自己上浪费了很多时间；</li>
<li>不尝试，习惯待在舒适圈；</li>
<li>面试水平差；</li>
<li>专业基础知识不牢固，平时不好好积累；</li>
<li>反应能力，即兴语言组织逻辑约等于无；</li>
<li>学习或者做事浮躁，懒得动脑子；</li>
<li>做决定纠纠结结；</li>
<li>抗挫能力弱；<br>当然，还有那么一点点坏运气。</li>
</ol>
<p>保研路上当然也收获了很多，遇到的人都很优秀，并且都渴望更加优秀，这也激发了我心里想要变得优秀的欲望，放大了我的野心。同时我也在这条路上逐渐地认识自己，了解自己，发现自己的不足，这何尝不是一份宝贵的财富。<br>留本校还是会觉得不甘心，但是事已至此，希望自己能记住这种“我本可以”的痛苦，多方面改善自己的不足，不要再像大学前三年浑浑噩噩，毫无方向了，努力地沉淀自己吧！<br>很酸同学们获得的成就，但是他们在背后也一定承受了常人不能承受的努力。<br>如果大家都可以变得很优秀，足够自由，并且随心所欲，那么我也可以。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习</title>
    <url>/2019/09/06/%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h1><ol>
<li><strong>并发</strong>：同一时间内多个程序执行,一个程序的执行尚未结束，另一个的程序执行已经开始；<br>并行(parallel)与并发(concurrentcy)的区别：<span id="more"></span></li>
</ol>
<ul>
<li>解释一<ul>
<li>并行：<strong>两个或者多个事件</strong>在同一<strong>时刻</strong>发生；</li>
<li>并发：<strong>两个或多个事件</strong>在同一<strong>时间间隔</strong>发生；</li>
</ul>
</li>
<li>解释二<ul>
<li>并行：<strong>不同实体</strong>的多个事件；</li>
<li>并发：<strong>同一实体</strong>的多个事件；</li>
</ul>
</li>
<li>解释三<ul>
<li>并行：同一时刻，<strong>多条</strong>指令在<strong>多个</strong>处理器上同时执行；</li>
<li>并发：同一时刻，<strong>一条</strong>指令分为<strong>多个进程指令</strong>，快速轮换执行，<strong>宏观同时</strong>；<br><img src="https://upload-images.jianshu.io/upload_images/7557373-72912ea8e89c4007.jpg" alt="并行">      <img src="https://upload-images.jianshu.io/upload_images/7557373-da64ffd6d1effaac.jpg" alt="并发"></li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>共享</strong>：系统中的<strong>资源</strong>可以被内存中多个并发执行的<strong>进线程共同使用</strong>；</li>
<li><strong>虚拟</strong>：通过<strong>时分复用</strong>（如分时系统）以及<strong>空分复用</strong>（如虚拟内存）技术实现把一个物理实体虚拟为多个；</li>
<li><strong>异步</strong>：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进;<br>同步与异步的区别:<a href="https://blog.csdn.net/qq_32725491/article/details/78679414">相关理解</a><br>同步：所有的操作都做完，才返回给用户；<br>异步：不用等所有操作等做完，就响应用户请求（消息队列）；<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2>行为的一个规则叫程序（指令的有序集合，静态，作为资料永久存在），程序在处理机上执行时所发生的活动成为进程（执行过程，动态，暂时）；<br>进程：一个具有一定的独立功能的程序关于某个数据集的一次运行活动；<h2 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h2>进程=程序+数据；动态与静态；永久与暂存；进程可以创建其他进程；真实地描述并发；一个程序对应多个进程；<h2 id="引入进程的目的"><a href="#引入进程的目的" class="headerlink" title="引入进程的目的"></a>引入进程的目的</h2>为了使多个程序并发执行，以改善资源利用率，提高系统吞吐量（衡量性能，单位时间内系统处理用户的请求数）；</li>
</ol>
<h2 id="多进程组织的3个部分"><a href="#多进程组织的3个部分" class="headerlink" title="多进程组织的3个部分"></a>多进程组织的3个部分</h2><ol>
<li>PCB：使多道程序环境下不能独立运行的程序（含数据），成为一个能<strong>独立运行</strong>的基本单位，与其他进程并发执行的进程；<strong>控制和管理</strong>进程；与进程<strong>一一对应</strong>，<strong>感知进程存在的唯一标志</strong>；包括进程标识符，状态，程序与数据地址，优先级，现场保护区；</li>
<li>状态：就绪，阻塞，运行</li>
<li>队列：就绪队列，阻塞队列<h2 id="CPU调度算法"><a href="#CPU调度算法" class="headerlink" title="CPU调度算法"></a>CPU调度算法</h2></li>
</ol>
<ul>
<li>先来先服务（FCFS）：按作业或进程<strong>到达的先后次序</strong>依次调度（平均周转时间长）；</li>
<li>短作业优先：选要求服务<strong>时间短</strong>的优先调度（确保了周转时间，但响应时间长）；</li>
<li>高响应比优先：响应比=1+等待时间/要求服务时间；</li>
<li>时间片轮转：按到达的先后分配时间片，不断轮转（时间片用完从运行态转到就绪态，暂停当前进程放到队列尾部，保证响应时间）；</li>
<li>多级反馈队列：FIFS放入多个队列，有不同的优先级（优先级高时间片短），前一个队列在一定时间内没有运行完，将剩余进程或作业插入到下一个队列的结尾；<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2>是进程内一个相对独立的、可独立调度和指派的执行单元；线程可以创建其他线程；一个进程中至少拥有一个线程；不拥有资源；<br>TCB：PC程序计数器，SP栈，State状态，寄存器，线程id；<h2 id="引入线程目的"><a href="#引入线程目的" class="headerlink" title="引入线程目的"></a>引入线程目的</h2>减少程序并发执行时所付出的时空开销；<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2>进程：拥有资源的基本单位；创建、撤销、切换的系统开销大<br>线程：CPU调度和指派任务的的基本单位；同一进程内的同步与通信的实现较容易；线程间会互相影响；<h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2>原则：</li>
</ul>
<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待<br>经典问题:生产者-消费者问题；哲学家进餐问题；读者-写者问题<br>死锁：<br>在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。<br>产生条件：</li>
<li>互斥条件        – 一个资源一次只能被一个进程使用</li>
<li>请求保持条件 – 一个进程因请求资源而阻塞时，对已经获得资源保持不放 </li>
<li>不可抢占条件 – 进程已获得的资源在未使用完之前不能强行剥夺</li>
<li>循环等待条件 – 若干进程之间形成一种头尾相接的循环等待资源的关系<br>死锁处理：<br>预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量<br>避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法<br>检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大<br>解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大</li>
</ol>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><p> <strong>互斥</strong>：任何时候只有一个对象访问某个资源，绝不允许多个对象同时操作；<br> <strong>同步</strong>：事情执行之间的依赖关系，具有顺序的互斥，协调对共享数据的并发访问；</p>
<p> <strong>信号量</strong>：协调共享资源访问，确保线程同步，PV操作（进/出临界区，s.value,s.queue）;必须有公共内存，不能用于分布式操作系统；<br> <strong>管程</strong>：将共享变量和对他们的操作集中在一个模块中，多线程互斥访问共享资源的程序结构。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>为多道程序的运行提供良好的环境，方便用户使用存储器，以提高存储器的利用率以及从逻辑上扩充存储器;<br>存储管理应具有以下功能:</p>
<ul>
<li>实现内存的分配和回收</li>
<li>地址变换</li>
<li>“扩充”内存容量</li>
<li>进行存储保护<h2 id="连续-分区分配方式"><a href="#连续-分区分配方式" class="headerlink" title="连续/分区分配方式"></a>连续/分区分配方式</h2></li>
<li>单一连续分配：内存分为OS区，用户区，只装入一道作业运行；</li>
<li>固定分区存储管理：内存分为若干个固定大小的分区</li>
</ul>
<p><a href="https://www.cnblogs.com/inception6-lxc/p/9073983.html">操作系统面试常见问题</a></p>
<h1 id="其他乱七八糟"><a href="#其他乱七八糟" class="headerlink" title="其他乱七八糟"></a>其他乱七八糟</h1><h2 id="文件系统和数据库系统的区别，哪个效率更高，为什么"><a href="#文件系统和数据库系统的区别，哪个效率更高，为什么" class="headerlink" title="文件系统和数据库系统的区别，哪个效率更高，为什么"></a>文件系统和数据库系统的区别，哪个效率更高，为什么</h2><p>1、文件系统实现以文件为单位的数据共享，数据库系统实现以记录和字段为单位的数据共享。<br>2、文件系统中的程序和数据有一定的联系，数据库系统中的程序和数据分离。<br>3、文件系统用文件将数据长期保存在外存上，数据库系统用数据库统一存储数据。<br>4、文件系统用操作系统中的存取方法对数据进行管理，数据库系统用DBMS统一管理和控制数据。<br>5、无结构与结构化</p>
<h2 id="BIOS的意思，程序的可移植性"><a href="#BIOS的意思，程序的可移植性" class="headerlink" title="BIOS的意思，程序的可移植性"></a>BIOS的意思，程序的可移植性</h2><p>即微机的基本输入输出系统(Basic Input-Output System)，是集成在主板上的一个ROM芯片，是主板设计者为使主板能正确管理和控制电脑硬件系统而预置的管理程序，其中保存有微机系统最重要的基本输入输出程序、系统信息设置、开机上电自检程序和系统启动自举程序。</p>
<h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>操作系统(Operating System, OS)：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境的软件集合。<br>用户是雇主，操作系统是工人，计算机是机器(由处理器、存储器、设备、文件等几个部件构成)</p>
<p> <strong>处理器管理</strong>：在多道程序的情况下，处理器的分配和运行都以进程(或线程)为基本单位，因而对处理器的管理可以分配为对进程的管理<br> <strong>存储器管理</strong>：包括内存分配、地址映射、内存保护等等<br> <strong>文件管理</strong>：计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分被称为文件系统，文件管理包括文件存储空间的管理、目录管理和读写保护等等<br> <strong>设备管理</strong>：主要任务是完成用户的I/O请求，包括缓冲管理、设备分配、虚拟设备等等<br><a href="https://blog.csdn.net/misayaaaaa/article/details/73087967">链接</a></p>
<p><a href="https://blog.csdn.net/baozhiqiangjava/article/details/79603394">复试常见题</a><br>(<a href="https://blog.csdn.net/qq_34149581/article/details/80003320">https://blog.csdn.net/qq_34149581/article/details/80003320</a>)<br>(<a href="https://blog.csdn.net/qq_38106472/article/details/95788897#ICMP%E6%98%AF%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A4%84%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F">https://blog.csdn.net/qq_38106472/article/details/95788897#ICMP%E6%98%AF%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A4%84%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F</a>)</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程复习</title>
    <url>/2019/09/14/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在计算机软件开发、使用和维护过程中遇到的一系列严重问题和难题</p>
<h3 id="产生的主要原因"><a href="#产生的主要原因" class="headerlink" title="产生的主要原因"></a>产生的主要原因</h3><p>软件规模越来越大，结构越来越复杂，开发管理困难，生产方式落后，开发工具落后</p>
<span id="more"></span>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>指导软件开发的工程学科，采用工程化的概念、原理、技术和方法进行软件的开发和维护</p>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p>方法、过程、工具</p>
<h3 id="遵循的原则"><a href="#遵循的原则" class="headerlink" title="遵循的原则"></a>遵循的原则</h3><ul>
<li>适宜的开发模型</li>
<li>合适的设计方法</li>
<li>高质量的工程支撑</li>
<li>重视软件工程管理<h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3>适用于<strong>不能预先确切定义需求</strong>的软件开发，或项目组成员沟通有困难；<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3>将软件生存周期的各个活动规定为依<strong>线性顺序</strong>连接的若干阶段的模型；适用于<strong>功能明确，无重大变化</strong>的软件系统的开发（操作系统，编译系统）<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3>支持需求不明确的大型软件系统开发，支持用户需求的动态变化，风险分析；<strong>面向规格说明、过程、对象</strong><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3>分成多个子系统进行开发，最后集成；<h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3></li>
</ul>
<p><strong>面向对象</strong>的软件开发方法，以用户需求为动力，对象来驱动；</p>
<h2 id="结构化分析方法（SA）"><a href="#结构化分析方法（SA）" class="headerlink" title="结构化分析方法（SA）"></a>结构化分析方法（SA）</h2><ul>
<li><strong>DD</strong>：数据流+数据存储+数据项+加工说明；<br>系统描述工具中的数据，是对数据定义信息的集合；</li>
<li><strong>DFD</strong>：用于表示系统逻辑模型的工具，以图形的方式描绘<strong>数据在系统中流动和处理的过程</strong>,反映系统必须完成的<strong>逻辑功能</strong>，是一种功能模型。 </li>
<li>数据字典+数据流图=<strong>系统的逻辑模型</strong></li>
<li><strong>自顶向下，逐层分解</strong>；<h2 id="结构化设计方法（SD）"><a href="#结构化设计方法（SD）" class="headerlink" title="结构化设计方法（SD）"></a>结构化设计方法（SD）</h2></li>
<li>DFD-&gt;软件系统的结构</li>
<li>分为概要设计+详细设计<h2 id="软件生存周期"><a href="#软件生存周期" class="headerlink" title="软件生存周期"></a>软件生存周期</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>可行性研究<br>需求分析：确定功能<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3></li>
</ul>
<p><strong>概要设计</strong>：数据库的逻辑设计，确定模块功能和接口，数据结构-&gt;概要设计文档，软件表示<br><strong>详细设计</strong>：确定模块内部特性（算法和数据库的物理设计）-&gt;精确的、结构化的过程描述；</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>保证软件质量的重要手段<br><strong>黑盒测试</strong>：依据需求规格说明书，只在软件接口处进行功能测试；<br><strong>白盒测试</strong>：检查内部控制结构和数据结构；</p>
<h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>系统交付后，为了改正错误或满足新的需求而修改软件的过程；</p>
<h2 id="软件设计基本原则"><a href="#软件设计基本原则" class="headerlink" title="软件设计基本原则"></a>软件设计基本原则</h2><ul>
<li><strong>模块独立性</strong>：高内聚，低耦合</li>
<li><strong>模块化</strong></li>
<li><strong>抽象</strong></li>
<li><strong>信息隐藏</strong><h2 id="软件体系结构设计"><a href="#软件体系结构设计" class="headerlink" title="软件体系结构设计"></a>软件体系结构设计</h2><h3 id="仓库模型"><a href="#仓库模型" class="headerlink" title="仓库模型"></a>仓库模型</h3>子系统紧密耦合共享中央数据仓库中的数据；</li>
</ul>
<p> <strong>优点</strong>：共享数据有效管理，子系统关于数据比较独立，易集成；<br> <strong>缺点</strong>：一致的数据视图影响性能，备份、安全等影响效率；</p>
<h3 id="分布式结构"><a href="#分布式结构" class="headerlink" title="分布式结构"></a>分布式结构</h3><p><strong>优点</strong>：资源共享、开放性高、可伸缩性强、容错能力强、透明性高；<br><strong>缺点</strong>：复杂性、安全性、可管理性、不可预见性；</p>
<h3 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h3><p>用户界面-&gt;应用逻辑-&gt;数据访问</p>
<ul>
<li>两层：胖客户机，瘦客户机（B/S）</li>
<li>三层/多层应用模型</li>
<li>分布式对象结构</li>
</ul>
<p><strong>面向服务的软件架构</strong><br>service-oriented architecture，SOA是一个构件模型，它将应用程序的不同功能单元（称为服务）通过定义良好的接口和契约联系起来。<br><strong>云计算</strong><br>分布式处理(Distributed Computing)、并行处理(ParallelComputing)和网格计算(Grid Computing)的发展，或者说是这些计算机科学概念的商业实现。是指基于互联网的超级计算模式–即把存储于个人电脑、移动电话和其他设备上的大量信息和处理器资源集中在一起，协同工作。在极大规模上可扩展的信息技术能力向外部客户作为服务来提供的一种计算方式。</p>
<h2 id="OOAD的SOLID原则"><a href="#OOAD的SOLID原则" class="headerlink" title="OOAD的SOLID原则"></a>OOAD的SOLID原则</h2><ul>
<li>单一责任</li>
<li>开放封闭：对扩展开发，对修改封闭；</li>
<li>里式替换：接口的子类或实例可替换父类；</li>
<li>接口分离：使用多个专用的接口；</li>
<li>依赖倒置：高层不依赖低层，抽象不依赖细节；</li>
</ul>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2019/08/30/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>有关DFS的算法和练习题整体的归纳与总结</p>
<span id="more"></span>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h2><p>递归思想：终止条件，循环，有效条件，走过标记；</p>
<h2 id="eg"><a href="#eg" class="headerlink" title="eg."></a>eg.</h2><h3 id="hduoj1010"><a href="#hduoj1010" class="headerlink" title="hduoj1010"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1010">hduoj1010</a></h3><p> <strong>典型迷宫，从初始点出发，四个方向，分别DFS，找到最小路径值；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">char maze[10][10];</span><br><span class="line">int flag[10][10];//判断是否走过标记</span><br><span class="line">int dir[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;;//四个方向</span><br><span class="line">int dx,dy,sx,sy;//门和开始的位置</span><br><span class="line">int N,M,T;</span><br><span class="line">bool flaga=false;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y,int step)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==dx&amp;&amp;y==dy)&#123;</span><br><span class="line">        if(step==T)flaga=true;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(step&gt;=T)return;</span><br><span class="line">    if(maze[x][y]!=&#x27;X&#x27;)&#123;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        int nowx=dir[i][0]+x;</span><br><span class="line">        int nowy=dir[i][1]+y;</span><br><span class="line">        if(nowx&lt;0||nowy&lt;0||nowx&gt;=N||nowy&gt;=M)continue;//跳过越界</span><br><span class="line">        if(flag[nowx][nowy]==0&amp;&amp;maze[nowx][nowy]!=&#x27;X&#x27;)&#123;</span><br><span class="line">            flag[nowx][nowy]=1;</span><br><span class="line">            dfs(nowx,nowy,step+1);</span><br><span class="line">            flag[nowx][nowy]=0;</span><br><span class="line">            if(flaga)return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;T)&amp;&amp;N!=0&amp;&amp;M!=0&amp;&amp;T!=0)&#123;</span><br><span class="line">        memset(flag,0,sizeof(flag));</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">                cin&gt;&gt;maze[i][j];</span><br><span class="line">                if(maze[i][j]==&#x27;S&#x27;)&#123;</span><br><span class="line">                    sx=i;</span><br><span class="line">                    sy=j;</span><br><span class="line">                &#125;</span><br><span class="line">                if(maze[i][j]==&#x27;D&#x27;)&#123;</span><br><span class="line">                    dx=i;</span><br><span class="line">                    dy=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /*for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">                cout&lt;&lt;maze[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;*/</span><br><span class="line">        // 不可大于最短路径||奇偶剪枝：若绕路必定比最短路径增长偶数time</span><br><span class="line">        if(abs(sx-dx)+abs(sy-dy)&gt;T||(sx+sy+dx+dy+T)%2==1)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            flaga=false;</span><br><span class="line">            flag[sx][sy]=1;</span><br><span class="line">        dfs(sx,sy,0);</span><br><span class="line">        //printf(&quot;%d\n&quot;,m);</span><br><span class="line">        if(flaga)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">3 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">...D</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1016"><a href="#hduoj1016" class="headerlink" title="hduoj1016"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1016">hduoj1016</a></h3><p> <strong>质数圈</strong><br>1-n内的数字放置在圈内，使相邻2个数字和为质数；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int in[25];</span><br><span class="line">int flag[25];</span><br><span class="line">bool prime[45];</span><br><span class="line">int res[25];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">//预处理判断40内的质数</span><br><span class="line">void Prime()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=3;i&lt;=40;i++)&#123;</span><br><span class="line">        bool flag=false;</span><br><span class="line">        for(int j=2;j&lt;=sqrt(i);j++)&#123;</span><br><span class="line">            if(i%j==0)&#123;</span><br><span class="line">                flag=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            prime[i]=false;</span><br><span class="line">        &#125;</span><br><span class="line">        else prime[i]=true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">void Output()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;res[i];</span><br><span class="line">        if(i!=n-1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int count=0;</span><br><span class="line">void dfs(int x,int step)</span><br><span class="line">&#123;</span><br><span class="line">    if(step==n)&#123;</span><br><span class="line">        //判断与头相加是否为素数</span><br><span class="line">        if(prime[1+res[step-1]])&#123;</span><br><span class="line">            Output();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=in[x];</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int b=in[i];//cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        if(flag[i]==0&amp;&amp;prime[a+b])&#123;//还未走过的位置,并且满足条件</span><br><span class="line">            //继续走下去</span><br><span class="line">            flag[i]=1;</span><br><span class="line">            res[step]=in[i];</span><br><span class="line">            dfs(i,step+1);</span><br><span class="line">            flag[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int Case=0;</span><br><span class="line">    Prime();</span><br><span class="line">    prime[2]=1;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF&amp;&amp;n!=0)&#123;</span><br><span class="line">        memset(in,0,sizeof(in));</span><br><span class="line">        memset(flag,0,sizeof(flag));</span><br><span class="line">        Case++;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            in[i]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[0]=1;</span><br><span class="line">        res[0]=in[0];</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;Case &quot;&lt;&lt;Case&lt;&lt;&quot;:&quot;&lt;&lt;endl;</span><br><span class="line">        dfs(0,1);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="hduoj1312"><a href="#hduoj1312" class="headerlink" title="hduoj1312"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1312">hduoj1312</a></h3><p> <strong>Red and Black 计算从start开始的所有路径，路径上经过的不重复的.数量</strong><br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char datamap[25][25];</span><br><span class="line">int flag[25][25];</span><br><span class="line">int ff[25][25];</span><br><span class="line">int dir[4][2]=&#123;-1,0,0,1,1,0,0,-1&#125;;</span><br><span class="line">int sx,sy;</span><br><span class="line">int count;</span><br><span class="line">int w,h;</span><br><span class="line"></span><br><span class="line">//计算从start开始的所有路径，路径上经过的不重复的.数量</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        int tmpx=x+dir[i][0];</span><br><span class="line">        int tmpy=y+dir[i][1];</span><br><span class="line">        //不是红砖，并且在范围内,并且没走过</span><br><span class="line">        if(datamap[tmpx][tmpy]==&#x27;.&#x27;&amp;&amp;tmpx&gt;=0&amp;&amp;tmpx&lt;h&amp;&amp;tmpy&gt;=0&amp;&amp;tmpy&lt;w&amp;&amp;!flag[tmpx][tmpy])&#123;</span><br><span class="line">            flag[tmpx][tmpy]=1;</span><br><span class="line">           // cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">            count++;</span><br><span class="line">            dfs(tmpx,tmpy);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;w,&amp;h)!=EOF&amp;&amp;w!=0&amp;&amp;h!=0)&#123;</span><br><span class="line">        count=1;</span><br><span class="line">        memset(flag,0,sizeof(flag));</span><br><span class="line">        memset(ff,0,sizeof(ff));</span><br><span class="line">        for(int i=0;i&lt;h;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;w;j++)&#123;</span><br><span class="line">                cin&gt;&gt;datamap[i][j];</span><br><span class="line">                if(datamap[i][j]==&#x27;@&#x27;)&#123;</span><br><span class="line">                    sx=i;</span><br><span class="line">                    sy=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(sx,sy);</span><br><span class="line">        cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">      /* for(int i=0;i&lt;h;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;w;j++)&#123;</span><br><span class="line">                cout&lt;&lt;datamap[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT刷题笔记</title>
    <url>/2019/09/01/%E5%88%B7%E9%A2%98/PAT%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1001-Public-Bike-Management"><a href="#1001-Public-Bike-Management" class="headerlink" title="1001:Public Bike Management"></a>1001:<a href="https://www.nowcoder.com/pat/5/problem/4324">Public Bike Management</a></h2><p>题目大意：自行车数量管理，有一问题站点，解决问题求路径最短，并且让图中每一个站点的自行车数量都为c/2，outbikes最小，inbikes最小；</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**************************</span><br><span class="line">*  Public Bike Management </span><br><span class="line">总体思路：</span><br><span class="line">深搜可以求出两点间的所有可达路径</span><br><span class="line">只要在找到可行路径时判断当前路径是否是更优路径即可。注意回溯*</span><br><span class="line">**************************/</span><br><span class="line"></span><br><span class="line">int c,n,s,m;//最大承载bike量&lt;=100</span><br><span class="line">            //站点数&lt;=500</span><br><span class="line">            //问题站点</span><br><span class="line">            //路径数</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; edge;//存放路径（注意空格）</span><br><span class="line">vector&lt;bool&gt;vis;//访问标记</span><br><span class="line">vector&lt;int&gt;bikes;//各站点bike数量</span><br><span class="line">vector&lt;int&gt;path,res_path;</span><br><span class="line">int cost=2,res_inbikes,res_outbikes,res_len=0;</span><br><span class="line">int res_cost=99999999;</span><br><span class="line">//使用vector防止内存溢出</span><br><span class="line"></span><br><span class="line">void DFS(int e,int index)</span><br><span class="line">&#123;</span><br><span class="line">    //到达终点，判断该路径是否最优</span><br><span class="line">    if(index==e)&#123;</span><br><span class="line">        //计算in/outbikes</span><br><span class="line">        int in=0,out=0;</span><br><span class="line">       /* for(int i=0;i&lt;path.size();i++)&#123;</span><br><span class="line">            cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;*/</span><br><span class="line">        for(int i=0;i&lt;path.size();i++)&#123;</span><br><span class="line">            if(bikes[path[i]]&gt;=c/2)&#123;</span><br><span class="line">                in+=bikes[path[i]]-c/2;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if((c/2-bikes[path[i]])&lt;=in)&#123;//bug1</span><br><span class="line">                    in-=(c/2-bikes[path[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    out+=(c/2-bikes[path[i]])-in;</span><br><span class="line">                   // cout&lt;&lt;in&lt;&lt;&quot; &quot;&lt;&lt;out&lt;&lt;endl;</span><br><span class="line">                    in=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //比较</span><br><span class="line">        if(cost!=res_cost)&#123;</span><br><span class="line">            if(cost&lt;res_cost)&#123;</span><br><span class="line">                res_cost=cost;</span><br><span class="line">                res_inbikes=in;</span><br><span class="line">                res_outbikes=out;</span><br><span class="line">                res_path=path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(out!=res_outbikes)&#123;</span><br><span class="line">                if(out&lt;res_outbikes)&#123;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_inbikes=in;</span><br><span class="line">                    res_outbikes=out;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(in&lt;res_inbikes)&#123;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_inbikes=in;</span><br><span class="line">                    res_outbikes=out;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(edge[index][i]!=0&amp;&amp;!vis[i])&#123;</span><br><span class="line">                vis[i]=1;</span><br><span class="line">                cost+=edge[index][i];</span><br><span class="line">                path.push_back(i);</span><br><span class="line">                DFS(e,i);</span><br><span class="line">                vis[i]=0;</span><br><span class="line">                cost-=edge[index][i];</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;c&gt;&gt;n&gt;&gt;s&gt;&gt;m;</span><br><span class="line">    bikes.resize(n+1,0);</span><br><span class="line">    vis.resize(n+1,0);</span><br><span class="line">    edge.resize(n+1,vector&lt;int&gt;(n+1,0));</span><br><span class="line">    int si,sj,t;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;bikes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;si&gt;&gt;sj&gt;&gt;t;</span><br><span class="line">        edge[si][sj]=t;</span><br><span class="line">        edge[sj][si]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[0]=1;</span><br><span class="line">    DFS(s,0);</span><br><span class="line">    cout&lt;&lt;res_outbikes&lt;&lt;&quot; 0&quot;;</span><br><span class="line">    for(int i=0;i&lt;res_path.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;res_path[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot; &quot;&lt;&lt;res_inbikes&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1002-All-Roads-Lead-to-Rome"><a href="#1002-All-Roads-Lead-to-Rome" class="headerlink" title="1002:All Roads Lead to Rome"></a>1002:<a href="https://www.nowcoder.com/pat/5/problem/4315">All Roads Lead to Rome</a></h2><p>和前面一题一样的思路，图的DFS确定所有可以到目的地的路线，按照一定规则选取最优路径，并存储；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,k;//城市数，路径数</span><br><span class="line">string start_city;</span><br><span class="line"></span><br><span class="line">map&lt;string,int&gt; mapcity;//记录城市信息</span><br><span class="line">map&lt;int,string&gt; mapcity2;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; roads;//记录路径</span><br><span class="line">vector&lt;int&gt; happiness;//记录幸福</span><br><span class="line">vector&lt;bool&gt; vis;</span><br><span class="line">vector&lt;int&gt;path,res_path;</span><br><span class="line">int cost=0,res_cost=999999999,res_hsum=0,res_havg=0,roadnum=0;</span><br><span class="line">int nowh_sum=0,nowh_avg=0;</span><br><span class="line"></span><br><span class="line">void DFS(int index,int e)</span><br><span class="line">&#123;</span><br><span class="line">    //走到罗马了</span><br><span class="line">    if(index==e)&#123;</span><br><span class="line">        nowh_avg=nowh_sum/(path.size()-1);</span><br><span class="line">        //判断cost与幸福总值与均值</span><br><span class="line">        if(cost!=res_cost)&#123;</span><br><span class="line">            if(cost&lt;res_cost)&#123;</span><br><span class="line">                res_path=path;</span><br><span class="line">                res_cost=cost;</span><br><span class="line">                res_hsum=nowh_sum;</span><br><span class="line">                res_havg=nowh_avg;</span><br><span class="line">                roadnum=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            roadnum++;</span><br><span class="line">            if(nowh_sum!=res_hsum)&#123;</span><br><span class="line">                if(nowh_sum&gt;res_hsum)&#123;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_hsum=nowh_sum;</span><br><span class="line">                    res_havg=nowh_avg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if(nowh_avg&gt;res_havg)&#123;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_hsum=nowh_sum;</span><br><span class="line">                    res_havg=nowh_avg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            if(roads[index][i]!=0&amp;&amp;!vis[i])&#123;</span><br><span class="line">                vis[i]=1;</span><br><span class="line">                path.push_back(i);</span><br><span class="line">                cost+=roads[index][i];</span><br><span class="line">                nowh_sum+=happiness[i];</span><br><span class="line">                DFS(i,e);</span><br><span class="line">                vis[i]=0;</span><br><span class="line">                path.pop_back();</span><br><span class="line">                cost-=roads[index][i];</span><br><span class="line">                nowh_sum-=happiness[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;start_city;</span><br><span class="line">    string cityname;</span><br><span class="line">    int h,end_index=0;</span><br><span class="line"></span><br><span class="line">    vis.resize(n,0);</span><br><span class="line">    roads.resize(n,vector&lt;int&gt;(n,0));</span><br><span class="line">    happiness.resize(n,0);</span><br><span class="line"></span><br><span class="line">    mapcity[start_city]=0;</span><br><span class="line">    mapcity2[0]=start_city;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;cityname&gt;&gt;h;</span><br><span class="line">        if(cityname==&quot;ROM&quot;)end_index=i;</span><br><span class="line">        mapcity[cityname]=i;</span><br><span class="line">        happiness[i]=h;</span><br><span class="line">        mapcity2[i]=cityname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string city1,city2;</span><br><span class="line">    int cost;</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;city1&gt;&gt;city2&gt;&gt;cost;</span><br><span class="line">        int x=mapcity[city1];</span><br><span class="line">        int y=mapcity[city2];</span><br><span class="line">        roads[x][y]=cost;</span><br><span class="line">        roads[y][x]=cost;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[0]=1;</span><br><span class="line">    path.push_back(0);</span><br><span class="line">    DFS(0,end_index);</span><br><span class="line">    cout&lt;&lt;roadnum&lt;&lt;&quot; &quot;&lt;&lt;res_cost&lt;&lt;&quot; &quot;&lt;&lt;res_hsum&lt;&lt;&quot; &quot;&lt;&lt;res_havg&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i &lt; res_path.size();i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line">        cout&lt;&lt;mapcity2[res_path[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1003：Highest-Price-in-Supply-Chain"><a href="#1003：Highest-Price-in-Supply-Chain" class="headerlink" title="1003：Highest Price in Supply Chain"></a>1003：<a href="https://www.nowcoder.com/pat/5/problem/4316">Highest Price in Supply Chain</a></h2><p>刚开始没有理解题意，题意是分别输入以0-N-1为下标的父母结点的下标；<br>解题思路：按照输入建树，求层数；<br>使用一个向量数组存放当前结点的子节点：vector<int> tree[100010];用树的DFS求层数；<br>注意树的DFS不需要vis标记访问，因为从根节点到达某一结点有且只有一条路径；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; tree[100010];</span><br><span class="line">int N;</span><br><span class="line">double P,r;</span><br><span class="line">int root;//记录根节点位置</span><br><span class="line">int routes=0,maxdepth=0;</span><br><span class="line"></span><br><span class="line">void dfs(int index,int step)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[index].size()==0)&#123;//到达树的子结点</span><br><span class="line">        if(step&gt;maxdepth)&#123;</span><br><span class="line">            maxdepth=step;</span><br><span class="line">            routes=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(step==maxdepth)routes++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;tree[index].size();i++)&#123;</span><br><span class="line">        dfs(tree[index][i],step+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%lf%lf&quot;,&amp;N,&amp;P,&amp;r);</span><br><span class="line">    r=r/100+1;</span><br><span class="line">    int parent;</span><br><span class="line">    //输入i的父母结点</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;parent;</span><br><span class="line">        //将i存为parent的子结点</span><br><span class="line">        if(parent==-1)&#123;</span><br><span class="line">            root=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            tree[parent].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //dfs确定树的深度</span><br><span class="line">    dfs(root,1);</span><br><span class="line">    double tmp=1;</span><br><span class="line">    for(int i=0;i&lt;maxdepth-1;i++)tmp*=r;</span><br><span class="line">    printf(&quot;%.2lf %d&quot;,tmp*P,routes);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1004-Acute-Stroke"><a href="#1004-Acute-Stroke" class="headerlink" title="1004:Acute Stroke"></a>1004:<a href="https://www.nowcoder.com/pat/5/problem/4317">Acute Stroke</a></h2><p>三维的BFS，用DFS时间复杂度过大；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int M,N,L,T;//矩阵的高&lt;1286</span><br><span class="line">            //矩阵的宽&lt;128</span><br><span class="line">            //slice数&lt;=60</span><br><span class="line">int arr[65][1290][130];</span><br><span class="line">int res=0;</span><br><span class="line">int dir[6][3]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;1,0,0&#125;,&#123;-1,0,0&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;0,0,-1&#125;,&#123;0,0,1&#125;</span><br><span class="line">&#125;;//6个方向：上下前后左右</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    node(int _x, int _y, int _z)&#123;</span><br><span class="line">		x=_x; y=_y; z=_z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void BFS(int i,int j,int k)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(i,j,k));</span><br><span class="line">    arr[i][j][k]=0;</span><br><span class="line">    int sum=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node n=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">            int x=n.x+dir[i][0];</span><br><span class="line">            int y=n.y+dir[i][1];</span><br><span class="line">            int z=n.z+dir[i][2];</span><br><span class="line">            //cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">            if(x&lt;L&amp;&amp;x&gt;=0&amp;&amp;y&lt;M&amp;&amp;y&gt;=0&amp;&amp;z&lt;N&amp;&amp;z&gt;=0)&#123;</span><br><span class="line">            if(arr[x][y][z]==1)&#123;</span><br><span class="line">                q.push(node(x,y,z));</span><br><span class="line">                arr[x][y][z]=0;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    if(sum&gt;=T)res+=sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;L&gt;&gt;T;</span><br><span class="line">    int thickness=0;</span><br><span class="line">    for(int i=0;i&lt;L;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;k++)&#123;</span><br><span class="line">                cin&gt;&gt;thickness;</span><br><span class="line">                arr[i][j][k]=thickness;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;L;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;k++)&#123;</span><br><span class="line">                    //cout&lt;&lt;arr[i][j][k];</span><br><span class="line">                if(arr[i][j][k])BFS(i,j,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-The-Largest-Generation"><a href="#1005-The-Largest-Generation" class="headerlink" title="1005:The Largest Generation"></a>1005:<a href="https://www.nowcoder.com/pat/5/problem/4318">The Largest Generation</a></h2><p>家谱树问题，求结点最多的一层的结点数与层数；思路：使用vector数组保存每个结点的孩子，构建成家谱树，然后使用BFS计算每层结点数，过程中维护家谱树每一层的level，使用一个数组记录各层结点数；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; child;</span><br><span class="line">    int level;</span><br><span class="line">&#125;members[101];</span><br><span class="line">int vis[101];//访问标记</span><br><span class="line">int N,M;//总人数，有孩子的人数</span><br><span class="line">int gen=0;</span><br><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    que.push(members[1]);</span><br><span class="line">    vis[1]=1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        node n=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i=0;i&lt;n.child.size();i++)&#123;</span><br><span class="line">            int index=n.child[i];</span><br><span class="line">            vis[n.level+1]++;</span><br><span class="line">            members[index].level=n.level+1;</span><br><span class="line">            que.push(members[index]);</span><br><span class="line">            if(gen!=n.level)gen=n.level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int id,K;</span><br><span class="line">    //输入构建家谱树</span><br><span class="line">    for(int i=0;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int c;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;K;</span><br><span class="line">        for(int j=0;j&lt;K;j++)&#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            members[id].child.push_back(c);</span><br><span class="line">            if(c==1)members[id].level=1;</span><br><span class="line">            else members[id].level=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BFS();</span><br><span class="line">    int res=0,res_i=0;</span><br><span class="line">    for(int i=1;i&lt;gen;i++)&#123;</span><br><span class="line">        if(vis[i]&gt;res)&#123;</span><br><span class="line">            res=vis[i];</span><br><span class="line">            res_i=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;&quot; &quot;&lt;&lt;res_i+1&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1006-Cars-on-Campus"><a href="#1006-Cars-on-Campus" class="headerlink" title="1006:Cars on Campus"></a>1006:<a href="https://www.nowcoder.com/pat/5/problem/4319">Cars on Campus</a></h2><p>题目意思是给出一组车进出记录，给定时刻，算出状态还未in的车的数量，并且求出一天中停留时间最长的车牌号与时间；<br>题目不难，在理解题意上花了一点时间，主要是pat惯用的需要建立一个专用的数据结构node存储记录；<br>数据量较大，容易超时，刚开始用char type[4]来存储记录的状态，因此每次都需要调用strcmp函数对字符串进行比较，后改为bool字段，直接在输入时判断为in(true)/out(false)，没有超时；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int time;</span><br><span class="line">    char name[8];</span><br><span class="line">    bool type;</span><br><span class="line">&#125;record[10001],valid[10001];</span><br><span class="line"></span><br><span class="line">int timeToInt(int h,int m,int s)</span><br><span class="line">&#123;</span><br><span class="line">    return h*3600+m*60+s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp1(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    int x=strcmp(a.name,b.name);</span><br><span class="line">    if(x)return x&lt;0;</span><br><span class="line">    return a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp2(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    int hh,mm,ss;</span><br><span class="line">    //存储每辆车的停留时间</span><br><span class="line">    map&lt;string,int&gt;parkTime;</span><br><span class="line">    int maxTime=0;</span><br><span class="line">    char t[4];</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s %d:%d:%d %s&quot;,record[i].name,&amp;hh,&amp;mm,&amp;ss,t);</span><br><span class="line">        if(!strcmp(t,&quot;in&quot;))record[i].type=true;</span><br><span class="line">        else record[i].type=false;</span><br><span class="line">        record[i].time=timeToInt(hh,mm,ss);</span><br><span class="line">    &#125;</span><br><span class="line">    //按照name与time从小到大排序</span><br><span class="line">    sort(record,record+n,cmp1);</span><br><span class="line">    int num=0;</span><br><span class="line">    //筛选有效记录,并求出最长停留时间</span><br><span class="line">    for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">       // printf(&quot;%s %d %s\n&quot;,record[i].name,record[i].time,record[i].type);</span><br><span class="line">        if(!strcmp(record[i].name,record[i+1].name)&amp;&amp;</span><br><span class="line">           record[i].type&amp;&amp;!record[i+1].type)&#123;</span><br><span class="line">                valid[num++]=record[i];</span><br><span class="line">                valid[num++]=record[i+1];</span><br><span class="line">                int time=record[i+1].time-record[i].time;</span><br><span class="line">                if(parkTime.count(record[i].name)==0)&#123;</span><br><span class="line">                    parkTime[record[i].name]=0;</span><br><span class="line">                &#125;</span><br><span class="line">                parkTime[record[i].name]+=time;</span><br><span class="line">                if(maxTime&lt;parkTime[record[i].name])&#123;</span><br><span class="line">                    maxTime=parkTime[record[i].name];</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(record[i].name);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(maxTime==parkTime[record[i].name])&#123;</span><br><span class="line">                    ans.push_back(record[i].name);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //按照time从小到大排序</span><br><span class="line">    sort(valid,valid+num,cmp2);</span><br><span class="line">    //输入搜索时间，从记录中选择计算</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">       scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);</span><br><span class="line">        int sum=0;</span><br><span class="line">        int temp=timeToInt(hh,mm,ss);</span><br><span class="line">        for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line"></span><br><span class="line">            if(valid[j].time&gt;temp)break;</span><br><span class="line">            if(valid[j].type)sum++;</span><br><span class="line">            else sum--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /*map&lt;string,int&gt;::iterator it;</span><br><span class="line">    for(it=parkTime.begin();it!=parkTime.end();it++)&#123;</span><br><span class="line">        if(it-&gt;second==maxTime)printf(&quot;%s &quot;,it-&gt;first.c_str());</span><br><span class="line">    &#125;*/</span><br><span class="line">    for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%02d:%02d:%02d\n&quot;, maxTime / 3600, maxTime % 3600 / 60, maxTime % 60);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1007-Consecutive-Factors"><a href="#1007-Consecutive-Factors" class="headerlink" title="1007:Consecutive Factors"></a>1007:<a href="https://www.nowcoder.com/pat/5/problem/4320">Consecutive Factors</a></h2><p>题目大意：求一个数的最长的连续因数串；<br>思路：从1到sqrt(n)的范围内循环，计算从当前i开始能够被n整除的最长子串，保存比较长度，最后得出最长；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; ans,temp;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int tempn=(int)sqrt(n);</span><br><span class="line">    //cout&lt;&lt;tempn&lt;&lt;endl;</span><br><span class="line">    int x=1,num=0,res=0;</span><br><span class="line">    for(int i=2;i&lt;=tempn;i++)&#123;</span><br><span class="line">        x*=i;</span><br><span class="line">        int t=i;</span><br><span class="line">        while(n%x==0&amp;&amp;t&lt;=tempn)&#123;</span><br><span class="line">            temp.push_back(t);</span><br><span class="line">            t++;</span><br><span class="line">            x*=t;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp.size()&gt;ans.size())&#123;</span><br><span class="line">            ans=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        x=1;</span><br><span class="line">        temp.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans.size()==0)&#123;</span><br><span class="line">        cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout&lt;&lt;ans.size()&lt;&lt;endl;</span><br><span class="line">        for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i];</span><br><span class="line">            if(i!=ans.size()-1)cout&lt;&lt;&quot;*&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1008-Deduplication-on-a-Linked-List"><a href="#1008-Deduplication-on-a-Linked-List" class="headerlink" title="1008:Deduplication on a Linked List "></a>1008:<a href="https://www.nowcoder.com/pat/5/problem/4321">Deduplication on a Linked List </a></h2><p>题目大意：将链表式数组中绝对值重复的值取出来，放入一个新的数组中，需要输入当前地址，值，以及下一个地址值；<br>我的思路：</p>
<ol>
<li>使用特定数据结构存储add,value,next,初始化按照链表顺序排好序；</li>
<li>从表头结点开始遍历，判断下一个结点的值是否出现过，flag[10001]表示是否出现过标记；</li>
<li>出现过则需要改变当前结点的next值，同时把重复结点赋予新数组，改变新数组的前一个结点的next值；<br>超时了！主要时间复杂度在排序O(n^2)!<br>不超时思路：</li>
<li>空间换取时间，直接在当前地址存储value/next,inList[add].value=v;inList[add].next=n;</li>
<li>从起始地址开始，判断当前value是否访问过，removeList[] 与 outList[]存放最终结果<strong>各个结点的地址</strong>；</li>
<li>遍历输出List[i],inList[List [i]].value,List[i+1];<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int num,first;</span><br><span class="line">/*</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int add,value,next;</span><br><span class="line">    bool sign;</span><br><span class="line">&#125;List[100001],removeList[100001];</span><br><span class="line">int flag[10001];</span><br><span class="line">int s_index;</span><br><span class="line">void InitNode()</span><br><span class="line">&#123;</span><br><span class="line">    int nnum=1;</span><br><span class="line">    List[0]=removeList[s_index];</span><br><span class="line">    int n=removeList[s_index].next;</span><br><span class="line">    while(n!=-1)&#123;</span><br><span class="line">        for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line">            if(removeList[j].add==n)&#123;</span><br><span class="line">                List[nnum++]=removeList[j];</span><br><span class="line">                n=removeList[j].next;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int removenum=0;</span><br><span class="line">    cin&gt;&gt;first&gt;&gt;num;</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;removeList[i].add&gt;&gt;removeList[i].value&gt;&gt;removeList[i].next;</span><br><span class="line">        if(removeList[i].add==first)s_index=i;</span><br><span class="line">    &#125;</span><br><span class="line">    InitNode();</span><br><span class="line">    flag[abs(List[0].value)]=1;</span><br><span class="line">    for(int i=0;i&lt;num-1;i++)&#123;</span><br><span class="line">        int v=abs(List[i+1].value);</span><br><span class="line">        //发生重复</span><br><span class="line">        if(flag[v]!=0)&#123;</span><br><span class="line">            //从链表中去除结点</span><br><span class="line">            List[i].next=List[i+1].next;</span><br><span class="line">            //加入到remove链表中</span><br><span class="line">            if(removenum==0)removeList[removenum++]=List[i+1];</span><br><span class="line">            else &#123;</span><br><span class="line">                removeList[removenum-1].next=List[i+1].add;</span><br><span class="line">                removeList[removenum++]=List[i+1];</span><br><span class="line">            &#125;</span><br><span class="line">            List[i+1].sign=true;</span><br><span class="line">        &#125;</span><br><span class="line">        else flag[v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    int t=0,f=0;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(!List[i].sign)&#123;</span><br><span class="line">            if(t==num-removenum-1)&#123;</span><br><span class="line">                printf(&quot;%05d %d %d\n&quot;,List[i].add,List[i].value,-1);break;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%05d %d %05d\n&quot;,List[i].add,List[i].value,List[i].next);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;removenum;i++)&#123;</span><br><span class="line">        if(i==removenum-1)</span><br><span class="line">             printf(&quot;%05d %d %d\n&quot;,removeList[i].add,removeList[i].value,-1);</span><br><span class="line">        else printf(&quot;%05d %d %05d\n&quot;,removeList[i].add,removeList[i].value,removeList[i].next);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;*/</span><br><span class="line">#define MAX 100001</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int value,next;</span><br><span class="line">&#125;inList[MAX];</span><br><span class="line">int outList[MAX],removeList[MAX];</span><br><span class="line">bool flag[10001]=&#123;0&#125;;</span><br><span class="line">int s_index=0;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;first,&amp;num);</span><br><span class="line">    int add;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;add;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;inList[add].value,&amp;inList[add].next);</span><br><span class="line">        if(add==first)s_index=add;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp=s_index;</span><br><span class="line">    int p=0,q=0;</span><br><span class="line">    int rfirst=0;</span><br><span class="line">    while(temp!=-1)&#123;</span><br><span class="line">        int v=abs(inList[temp].value);</span><br><span class="line">        //发生冲突</span><br><span class="line">        if(flag[v])&#123;</span><br><span class="line">            if(q==0)rfirst=inList[temp].value;</span><br><span class="line">            removeList[q++]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            outList[p++]=temp;</span><br><span class="line">            flag[v]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=inList[temp].next;</span><br><span class="line">    &#125;</span><br><span class="line">    //输出</span><br><span class="line">    for(int i=0;i&lt;p;i++)&#123;</span><br><span class="line">        if(i!=p-1)&#123;</span><br><span class="line">            //printf(&quot;%05d %d %05d\n&quot;,outList[i].value,outList[i+1].value);</span><br><span class="line">            printf(&quot;%05d %d %05d\n&quot;,outList[i],inList[outList[i]].value,outList[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;%05d %d %d\n&quot;,outList[i],inList[outList[i]].value,-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;q;i++)&#123;</span><br><span class="line">        if(i!=q-1)&#123;</span><br><span class="line">            printf(&quot;%05d %d %05d\n&quot;,removeList[i],inList[removeList[i]].value,removeList[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else  printf(&quot;%05d %d %d\n&quot;,removeList[i],inList[removeList[i]].value,-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1009-Insertion-or-Heap-Sort"><a href="#1009-Insertion-or-Heap-Sort" class="headerlink" title="1009:Insertion or Heap Sort "></a>1009:<a href="https://www.nowcoder.com/pat/5/problem/4322">Insertion or Heap Sort </a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num[101];</span><br><span class="line">int num2[101];</span><br><span class="line">int res[101];</span><br><span class="line">int Heap_Size=0;</span><br><span class="line">bool flag=false;</span><br><span class="line">bool isSame(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(arr[i]!=res[i])return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void out_put(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//插入排序</span><br><span class="line">bool Insert_Sort(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;len;i++)&#123;</span><br><span class="line">        int temp=arr[i];</span><br><span class="line">        int j;</span><br><span class="line">        for(j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">            if(arr[j]&gt;temp)&#123;</span><br><span class="line">                arr[j+1]=arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+1]=temp;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            out_put(arr,len);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(isSame(arr,len))&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Insertion Sort&quot;&lt;&lt;endl;</span><br><span class="line">            flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Max_Heap(int arr[],int i)</span><br><span class="line">&#123;</span><br><span class="line">    int l=2*(i+1)-1;</span><br><span class="line">    int r=2*(i+1);</span><br><span class="line">    int largeset=i;</span><br><span class="line">    if(arr[l]&gt;arr[i]&amp;&amp;l&lt;Heap_Size)&#123;</span><br><span class="line">        largeset=l;</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr[r]&gt;arr[largeset]&amp;&amp;r&lt;Heap_Size)&#123;</span><br><span class="line">        largeset=r;</span><br><span class="line">    &#125;</span><br><span class="line">    if(largeset!=i)&#123;</span><br><span class="line">        swap(arr[largeset],arr[i]);</span><br><span class="line">        Max_Heap(arr,largeset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//建最大堆</span><br><span class="line">void Build_Max_Heap(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    //从第一个非叶子结点开始</span><br><span class="line">    for(int i=len/2-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Max_Heap(arr,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Heap_Sort(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    Heap_Size=len;</span><br><span class="line">    Build_Max_Heap(arr,len);</span><br><span class="line">    for(int i=0;i&lt;len-1;i++)&#123;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            out_put(arr,len);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(isSame(arr,len))&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Heap Sort&quot;&lt;&lt;endl;</span><br><span class="line">            flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[Heap_Size-1],arr[0]);</span><br><span class="line">        Heap_Size--;</span><br><span class="line">        Build_Max_Heap(arr,Heap_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        num2[i]=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(!Insert_Sort(num,n))</span><br><span class="line">        Heap_Sort(num2,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1010-Build-A-Binary-Search-Tree"><a href="#1010-Build-A-Binary-Search-Tree" class="headerlink" title="1010:Build A Binary Search Tree"></a>1010:<a href="https://www.nowcoder.com/pat/5/problem/4323">Build A Binary Search Tree</a></h2>根据输入构造二叉树，利用二叉搜索树的排序特点，将key[]从小到大排序后，就是BST的中序遍历的顺序，因此可以为BST直接赋值，再用queue层次遍历，实际上就是树的BFS；<br>刚开始还想要按照传统方法输入建树，也太蠢了吧！<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct treeNode</span><br><span class="line">&#123;</span><br><span class="line">    int left;</span><br><span class="line">    int right;</span><br><span class="line">    int value;</span><br><span class="line">&#125;Tree[101];</span><br><span class="line">int key[101];</span><br><span class="line">int index=0;</span><br><span class="line"></span><br><span class="line">//中序遍历</span><br><span class="line">void mid(int t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==-1)return;</span><br><span class="line">    mid(Tree[t].left);</span><br><span class="line">    Tree[t].value=key[index++];</span><br><span class="line">    mid(Tree[t].right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//层次遍历</span><br><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">    bool flag=false;</span><br><span class="line">    queue&lt;treeNode&gt;q;</span><br><span class="line">    q.push(Tree[0]);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        treeNode n=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(flag)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        flag=true;</span><br><span class="line">        cout&lt;&lt;n.value;</span><br><span class="line">        if(n.left!=-1)q.push(Tree[n.left]);</span><br><span class="line">        if(n.right!=-1)q.push(Tree[n.right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Tree[i].left&gt;&gt;Tree[i].right;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(key,key+num);</span><br><span class="line">    //for(int i=0;i&lt;num;i++)cout&lt;&lt;key[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    mid(0);</span><br><span class="line">    BFS();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1011-Forwards-on-Weibo"><a href="#1011-Forwards-on-Weibo" class="headerlink" title="1011:Forwards on Weibo"></a>1011:<a href="https://www.nowcoder.com/pat/5/problem/4306">Forwards on Weibo</a></h2>太感动了，思路都是自己想出来的！<br>挺切合实际的，</li>
<li>用vector二维数组保存微博关注者；</li>
<li>使用queue保存每一level转发者；注意保存的是自己设定的node，其中包括level，保证转发层次在一定范围内；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector &lt;int&gt; &gt; User;</span><br><span class="line">int flag[1001];//标记是否转发过</span><br><span class="line">int N=0;//user数&lt;=1000</span><br><span class="line">int level=0;//follow层数&lt;=6</span><br><span class="line">int qnum=0;//查询次数</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int index;</span><br><span class="line">    int Lev;</span><br><span class="line">    node(int _index, int _lev)&#123;</span><br><span class="line">		index=_index;</span><br><span class="line">		Lev=_lev;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;level;</span><br><span class="line">    int num;//关注人数</span><br><span class="line">    int follow;//关注人的下标值</span><br><span class="line">    User.resize(N+1);</span><br><span class="line">    //输入,记录关注者</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line">            cin&gt;&gt;follow;</span><br><span class="line">            User[follow].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   /* cout&lt;&lt;&quot;------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;User[i].size();j++)&#123;</span><br><span class="line">            cout&lt;&lt;User[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;*/</span><br><span class="line">    cin&gt;&gt;qnum;</span><br><span class="line">    int k;</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=0;i&lt;qnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        queue&lt;node&gt; q;</span><br><span class="line">        memset(flag,0,sizeof(flag));</span><br><span class="line">        sum=0;</span><br><span class="line">        flag[k]=1;</span><br><span class="line">        q.push(node(k,0));</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            node temp=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">           //cout&lt;&lt;temp.index&lt;&lt;&quot; &quot;&lt;&lt;temp.Lev&lt;&lt;endl;</span><br><span class="line">            int now_level=temp.Lev;</span><br><span class="line">            if(now_level&gt;=level)break;</span><br><span class="line">            for(int j=0;j&lt;User[temp.index].size();j++)&#123;</span><br><span class="line">                if(!flag[User[temp.index][j]])&#123;</span><br><span class="line">                    sum+=1;</span><br><span class="line">                    q.push(node(User[temp.index][j],now_level+1));</span><br><span class="line">                    flag[User[temp.index][j]]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">       // cout&lt;&lt;&quot;------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1012-Kuchiguse"><a href="#1012-Kuchiguse" class="headerlink" title="1012:Kuchiguse"></a>1012:<a href="https://www.nowcoder.com/pat/5/problem/4307">Kuchiguse</a></h2>char str[101][256]字符数组的输入：scanf(“%s”,&amp;str[i])  /  string str[101]字符串输入：cin&gt;&gt;str[i],以<strong>空格</strong>为分割字符串；<br>简单题，求N个字符串的最长公共后缀，思路：以第一个字符串为基准，遍历另外N-1个字符串，判断从后往前的同样位置字符是否相等；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">string str[101];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    getchar();</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        getline(cin,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    bool flag=false;</span><br><span class="line">    int res=0;</span><br><span class="line">   for(int i=0;i&lt;str[0].length();i++)&#123;</span><br><span class="line">        char temp=str[0][str[0].length()-i-1];</span><br><span class="line">        for(int j=1;j&lt;num;j++)&#123;</span><br><span class="line">            char x=str[j][str[j].length()-i-1];</span><br><span class="line">            if(x!=temp)&#123;</span><br><span class="line">                res=i;</span><br><span class="line">                flag=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(res==0&amp;&amp;flag)//bugcout&lt;&lt;&quot;nai&quot;&lt;&lt;endl;</span><br><span class="line">    else if(res==0)&#123;</span><br><span class="line">        for(int i=0;i&lt;str[0].length();i++)cout&lt;&lt;str[0][i];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    for(int i=str[0].length()-res;i&lt;str[0].length();i++)cout&lt;&lt;str[0][i];</span><br><span class="line">   /* for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cout&lt;&lt;str[i]&lt;&lt;endl;</span><br><span class="line">    &#125;*/</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1013-Hashing"><a href="#1013-Hashing" class="headerlink" title="1013:Hashing"></a>1013:<a href="https://www.nowcoder.com/pat/5/problem/4308">Hashing</a></h2>Hash+平方探测法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isPrime(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==1)return false;</span><br><span class="line">    if(x==2)return true;</span><br><span class="line">    int temp=sqrt(x);</span><br><span class="line">    for(int i=2;i&lt;=temp;i++)&#123;</span><br><span class="line">        if(x%i==0)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到比x大的最近一个质数</span><br><span class="line">int Find_Prime(int x)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        if(isPrime(x))return x;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int MSize,N;</span><br><span class="line">    bool flag[10001];</span><br><span class="line">    int input[10001];</span><br><span class="line">    bool ff=false,fff=false;</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    cin&gt;&gt;MSize&gt;&gt;N;</span><br><span class="line">    int table_size;</span><br><span class="line">    //if(MSize==1)table_size=2;</span><br><span class="line">    table_size=Find_Prime(MSize);</span><br><span class="line">    int num;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        int num=input[i];</span><br><span class="line">        int a=num%table_size;</span><br><span class="line">        if(ff)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        if(!flag[a])&#123;</span><br><span class="line">            cout&lt;&lt;a;</span><br><span class="line">            flag[a]=1;</span><br><span class="line">            fff=true;</span><br><span class="line">        &#125;</span><br><span class="line">        //平方探测法</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int x=1;x&lt;table_size;x++)&#123;//bug</span><br><span class="line">                int t=(x*x+a)%table_size;</span><br><span class="line">                if(!flag[t])&#123;</span><br><span class="line">                    cout&lt;&lt;t;</span><br><span class="line">                    fff=true;</span><br><span class="line">                    flag[t]=1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fff)cout&lt;&lt;&quot;-&quot;;</span><br><span class="line">        ff=true;</span><br><span class="line">        fff=false;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1014-Total-Sales-of-Supply-Chain"><a href="#1014-Total-Sales-of-Supply-Chain" class="headerlink" title="1014:Total Sales of Supply Chain"></a>1014:<a href="https://www.nowcoder.com/pat/5/problem/4309">Total Sales of Supply Chain</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double sum=0;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; tree;</span><br><span class="line">int N;//结点总数</span><br><span class="line">double P,r;//根结点的原始值，rate</span><br><span class="line">int flag[100001];//标记子节点的产品值</span><br><span class="line"></span><br><span class="line">void DFS(int index,int level)</span><br><span class="line">&#123;</span><br><span class="line">    //说明为叶子结点</span><br><span class="line">    //可结合产品数量计算金额</span><br><span class="line">    if(tree[index].size()==0)&#123;</span><br><span class="line">        //这儿存在bug，一个超时，一个错误</span><br><span class="line">        //改用pow函数即可</span><br><span class="line">        /*double t=r;</span><br><span class="line">        for(int k=0;k&lt;level-1;k++)&#123;</span><br><span class="line">            t=r*t;</span><br><span class="line">        &#125;*/</span><br><span class="line">        sum+=pow(r,level)*P*flag[index];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;tree[index].size();i++)&#123;</span><br><span class="line">        DFS(tree[index][i],level+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d %lf %lf&quot;,&amp;N,&amp;P,&amp;r);</span><br><span class="line">    r=(double)1+r/100;</span><br><span class="line">    tree.resize(N);</span><br><span class="line">    int childnum;</span><br><span class="line">    //输入</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;childnum);</span><br><span class="line">        if(childnum!=0)&#123;</span><br><span class="line">            int child;</span><br><span class="line">            //记录各个结点的子节点</span><br><span class="line">            for(int j=0;j&lt;childnum;j++)&#123;</span><br><span class="line">                cin&gt;&gt;child;</span><br><span class="line">                tree[i].push_back(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            int products;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;products);</span><br><span class="line">            flag[i]=products;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DFS求出遍历所有路径</span><br><span class="line">    DFS(0,0);</span><br><span class="line">    printf(&quot;%.1lf&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1015Graduate-Admission"><a href="#1015Graduate-Admission" class="headerlink" title="1015Graduate Admission"></a>1015<a href="https://www.nowcoder.com/pat/5/problem/4310">Graduate Admission</a></h2>优先队列,pop(),push(),top(),没法遍历；</li>
</ol>
<ul>
<li>自定义优先级<br>struct cmp{<br>  operator bool(int x,int y){return x&gt;y;}<br>}<br>priority_queue&lt;int,vector<int>,cmp&gt;</li>
<li>结构体声明方式<br>struct node{<br>  int x,y;<br>  friend bool operator &lt; (node a, node b)<br>　　{<br>　　　　return a.x &gt; b.x;    //结构体中，x小的优先级高<br>　　}<br>}<br>priority_queue<node>q;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int nums,schools,chs;//毕业人数&lt;=40000，</span><br><span class="line">                    //院校数&lt;=100，</span><br><span class="line">                    //志愿数&lt;=5</span><br><span class="line">vector&lt;int&gt;quotas;//院校招生限额</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int index;</span><br><span class="line">    int GE;</span><br><span class="line">    int GT;</span><br><span class="line">    vector&lt;int&gt;choices;</span><br><span class="line">&#125;Students[40001];</span><br><span class="line">vector&lt;node&gt;SchoolsStu[101];//院校招生学生</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    //两个double！！！</span><br><span class="line">    double x=(double)(a.GE+a.GT)/2;</span><br><span class="line">    double y=(double)(b.GE+b.GT)/2;</span><br><span class="line">    if(x!=y)return x&gt;y;</span><br><span class="line">    else return a.GE&gt;b.GE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp2(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.index&lt;b.index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isEqual(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    //两个double！！！</span><br><span class="line">    double x=(double)(a.GE+a.GT)/2;</span><br><span class="line">    double y=(double)(b.GE+b.GT)/2;</span><br><span class="line">    if(x==y&amp;&amp;a.GE==b.GE)return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //输入</span><br><span class="line">    cin&gt;&gt;nums&gt;&gt;schools&gt;&gt;chs;</span><br><span class="line">    int quo;</span><br><span class="line">    for(int i=0;i&lt;schools;i++)&#123;</span><br><span class="line">        cin&gt;&gt;quo;</span><br><span class="line">        quotas.push_back(quo);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;nums;i++)&#123;</span><br><span class="line">        Students[i].index=i;</span><br><span class="line">        Students[i].choices.resize(chs);</span><br><span class="line">        cin&gt;&gt;Students[i].GE&gt;&gt;Students[i].GT;</span><br><span class="line">        int temp;</span><br><span class="line">        for(int j=0;j&lt;chs;j++)&#123;</span><br><span class="line">            cin&gt;&gt;temp;</span><br><span class="line">            Students[i].choices[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算</span><br><span class="line">    sort(Students,Students+nums,cmp);</span><br><span class="line">    for(int i=0;i&lt;nums;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;chs;j++)&#123;</span><br><span class="line">            int tempc=Students[i].choices[j];</span><br><span class="line">            if(quotas[tempc]&gt;SchoolsStu[tempc].size())&#123;</span><br><span class="line">                SchoolsStu[tempc].push_back(Students[i]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //无需用循环！</span><br><span class="line">                //用循环复杂度极高，实际上只要对比新加入的最菜的那个学生即可</span><br><span class="line">                if(isEqual(SchoolsStu[tempc].back(),Students[i]))&#123;</span><br><span class="line">                    SchoolsStu[tempc].push_back(Students[i]);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //输出</span><br><span class="line">    /*cout&lt;&lt;&quot;=============================&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;nums;i++)&#123;</span><br><span class="line">        cout&lt;&lt;Students[i].GE&lt;&lt;&quot; &quot;&lt;&lt;Students[i].GT&lt;&lt;&quot; &quot;;</span><br><span class="line">        for(int j=0;j&lt;Students[i].choices.size();j++)&#123;</span><br><span class="line">            int xx=Students[i].choices[j];</span><br><span class="line">            cout&lt;&lt;xx&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;=============================&quot;&lt;&lt;endl;*/</span><br><span class="line">    for(int i=0;i&lt;schools;i++)&#123;</span><br><span class="line">        //vector的排序方式</span><br><span class="line">        sort(SchoolsStu[i].begin(),SchoolsStu[i].end(),cmp2);</span><br><span class="line">        for(int j=0;j&lt;SchoolsStu[i].size();j++)&#123;</span><br><span class="line">            if(j!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">            cout&lt;&lt;SchoolsStu[i][j].index;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1021"><a href="#1021" class="headerlink" title="1021"></a>1021</h2><p>一开始题目看错，用空间换取时间，出现段错误，因为数组越界；<br>使用了<img src="https://blog.csdn.net/sevenjoin/article/details/81943864" alt="map"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;int,int&gt; myMap[55];</span><br><span class="line">int flag[55];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //N集合数&lt;=50</span><br><span class="line">    //K每个集合的整数个数&lt;=10^4,在[0,10^9]内</span><br><span class="line">    //Q查询数</span><br><span class="line">    //想用Set[55][110000000]空间换取时间，根本不ok</span><br><span class="line">    //换个思路</span><br><span class="line">    int N,K,Q,data;</span><br><span class="line">    map&lt;int,int&gt;::iterator it;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;K;</span><br><span class="line">        for(int j=0;j&lt;K;j++)&#123;</span><br><span class="line">            cin&gt;&gt;data;</span><br><span class="line">            it=myMap[i].find(data);</span><br><span class="line">            if(it==myMap[i].end())&#123;</span><br><span class="line">                myMap[i][data]=1;</span><br><span class="line">               // flag[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                myMap[i][data]++;</span><br><span class="line">            &#125;</span><br><span class="line">            //可直接myMap[i][data]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    int set1,set2;</span><br><span class="line">    for(int i=0;i&lt;Q;i++)&#123;</span><br><span class="line">        int NC=0,NT=0;</span><br><span class="line">        double ret=0;</span><br><span class="line">        cin&gt;&gt;set1&gt;&gt;set2;</span><br><span class="line">        map&lt;int,int&gt;::iterator iit;</span><br><span class="line">        for(iit=myMap[set1-1].begin();iit!=myMap[set1-1].end();iit++)&#123;</span><br><span class="line">            int temp=iit-&gt;first;</span><br><span class="line">            it=myMap[set2-1].find(temp);</span><br><span class="line">            if(it!=myMap[set2-1].end())&#123;</span><br><span class="line">                //找到了</span><br><span class="line">                NC++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       // cout&lt;&lt;NC&lt;&lt;&quot; &quot;&lt;&lt;flag[set1-1]+flag[set2-1]-NC&lt;&lt;endl;</span><br><span class="line">        ret=(double)NC*100/(myMap[set1-1].size()+myMap[set2-1].size()-NC);</span><br><span class="line">        printf(&quot;%.1lf%%\n&quot;,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记</title>
    <url>/2019/10/09/%E5%88%B7%E9%A2%98/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="STL-set用法"><a href="#STL-set用法" class="headerlink" title="STL set用法"></a>STL set用法</h2><p> <strong>特点</strong>：集合，元素唯一，对元素自动进行升序排序;<br>set<int> s;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.begin();</span><br><span class="line">s.end();</span><br><span class="line">s.insert(x); //插入x元素</span><br><span class="line">s.erase(x);  s.erase(it) //删除x元素 ,it迭代器指向元素</span><br><span class="line">s.find(x); //查找x元素,不存在则返回s.end()</span><br><span class="line">s.lower_bound(x); //大于或等于x，得到定位器</span><br></pre></td></tr></table></figure>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h2><ol>
<li>暴力递归解法:得到n对”()”的全排列情况，验证平衡；<br>时间复杂度O(2^2n);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    </span><br><span class="line">    // &#x27;(&#x27;==1  ; &#x27;)&#x27;==-1</span><br><span class="line">    bool vaild(int array[],int len)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            res+=array[i];</span><br><span class="line">            if(res&lt;0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return (res==0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void generate(int arr[],int pos,int len)&#123;</span><br><span class="line">        if(pos == len)&#123;</span><br><span class="line">            //判断是否有效</span><br><span class="line">            if(vaild(arr,len))&#123;</span><br><span class="line">                //将数组转换为string</span><br><span class="line">                string temp=&quot;&quot;;</span><br><span class="line">                for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                    if(arr[i]==1)temp+=&quot;(&quot;;</span><br><span class="line">                    else temp+=&quot;)&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                result.push_back(temp);</span><br><span class="line">                // ncout&lt;&lt;result.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            arr[pos]=1;</span><br><span class="line">            generate(arr,pos+1,len);</span><br><span class="line">            arr[pos]=-1;</span><br><span class="line">            generate(arr,pos+1,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        int *arr=new int[2*n];</span><br><span class="line">        generate(arr,0,2*n);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>动态规划：初始状态为0的””,1的”()”，接下来的值根据前面得到的：(p组括号的所有可能情况)+q组括号的所有可能情况,其中p+q=n-1;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt;dp(n+1);</span><br><span class="line">        dp[0]=&#123;&quot;&quot;&#125;;</span><br><span class="line">        dp[1]=&#123;&quot;()&quot;&#125;;</span><br><span class="line">        if(n==1||n==0)return dp[n];</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                for(int x=0;x&lt;dp[j].size();x++)&#123;</span><br><span class="line">                    for(int y=0;y&lt;dp[i-j-1].size();y++)&#123;</span><br><span class="line">                        string res=&quot;(&quot;+dp[j][x]+&quot;)&quot;+dp[i-j-1][y];</span><br><span class="line">                        dp[i].push_back(res);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23.合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/submissions/">23.合并K个排序链表</a></h2><ol>
<li>最简单粗暴的链表操作：</li>
</ol>
<ul>
<li>原始k个链表已排好序；</li>
<li>在每个列表的表头筛选最小值，即结果链表的下一个值</li>
<li>更新获得最小值的当前链表的下一个值</li>
<li>重复第2步，循环直到所有k个链表到达结尾；</li>
</ul>
<p>时间复杂度O(m*k),m为所有k个链表结点总数；额外的空间复杂度O(m);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;ListNode*&gt;&amp; lists)&#123;</span><br><span class="line">        int len=lists.size();</span><br><span class="line">        int min=99999999;</span><br><span class="line">        int minindex=-1;</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            if(lists[i]!=NULL &amp;&amp; lists[i]-&gt;val&lt;min)&#123;</span><br><span class="line">                min=lists[i]-&gt;val;</span><br><span class="line">                minindex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return minindex;//-1结束：所有链表都已遍历完成</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        ListNode *head=new ListNode(0);</span><br><span class="line">        ListNode *pre=head;</span><br><span class="line">        int pos=0;</span><br><span class="line">        while((pos=findMin(lists))&gt;=0)&#123;</span><br><span class="line">            ListNode *newnode=new ListNode(lists[pos]-&gt;val);</span><br><span class="line"></span><br><span class="line">            //找到最小下标，进行一定操作</span><br><span class="line">            if(lists[pos]-&gt;next!=NULL)lists[pos]=lists[pos]-&gt;next;</span><br><span class="line">            else lists[pos]=NULL;</span><br><span class="line">        </span><br><span class="line">            pre-&gt;next=newnode;</span><br><span class="line">            pre=newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>分治法:将链表两两合并（递归）;<br>时间复杂度:O(mlogk),空间复杂度O(1);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* MergeTwoSortedList(ListNode* l1,ListNode* l2)&#123;</span><br><span class="line">        if(l1==NULL)&#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2==NULL)&#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next=MergeTwoSortedList(l1-&gt;next,l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next=MergeTwoSortedList(l1,l2-&gt;next);</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists,int left,int right)&#123;</span><br><span class="line">        //最小分治，左右边界相等</span><br><span class="line">        if( left == right )&#123;</span><br><span class="line">            return lists[left];</span><br><span class="line">        &#125;</span><br><span class="line">        int mid=(left+right)/2;</span><br><span class="line">        ListNode* l1=mergeKLists(lists,left,mid);</span><br><span class="line">        ListNode* l2=mergeKLists(lists,mid+1,right);</span><br><span class="line">        return MergeTwoSortedList(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        int len=lists.size();</span><br><span class="line">        if(len==0)return NULL;</span><br><span class="line">        ListNode* res=mergeKLists(lists,0,len-1);</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2019/10/13/%E5%88%B7%E9%A2%98/LeetCode/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pat题型总结</title>
    <url>/2019/09/17/%E5%88%B7%E9%A2%98/pat%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<h1 id="窗口排队模拟"><a href="#窗口排队模拟" class="headerlink" title="窗口排队模拟"></a>窗口排队模拟</h1><h2 id="eg1-1017-Queueing-at-Bank-25-分"><a href="#eg1-1017-Queueing-at-Bank-25-分" class="headerlink" title="eg1. 1017 Queueing at Bank (25 分)"></a>eg1. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968">1017 Queueing at Bank (25 分)</a></h2><p> <strong>题意</strong>：给出顾客数与窗口数，以及顾客的到达时间和处理时间；Bank的工作时间在8.-17.；在8.前到达需要等到8.后才开始办理，17.点及之后不办理，88了；计算平均等待时间；<br> <span id="more"></span><br> <strong>思路</strong>：</p>
<ol>
<li>输入； </li>
<li>按照到达时间排序；</li>
<li>先将空窗口填满（入队列）：<strong>即到即办理，或者等到8点</strong>，计算结束时间和等待时间；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在8.以前到达</span><br><span class="line">            if(Start&gt;Customer[i].arr_time)&#123;</span><br><span class="line">                Customer[i].wait_time=Start-Customer[i].arr_time;</span><br><span class="line">                Customer[i].finish_time=Customer[i].p_time;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                Customer[i].wait_time=0;</span><br><span class="line">                Customer[i].finish_time=Customer[i].arr_time+Customer[i].p_time-Start;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li>
<li>然后选取办理时间最早结束的出队列：它的结束时间与下一个候选顾客的到达时间作比较，<strong>到达之后就有空位置即办理，或者等到最先结束的完成后,</strong> 计算结束时间和等待时间；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//等待时间为前一个结束时间-到达时间</span><br><span class="line">            //或者直接有空窗口，无需等待</span><br><span class="line">            int temp=n.finish_time+Start-Customer[i].arr_time;</span><br><span class="line">            if(temp&gt;0)&#123;</span><br><span class="line">                Customer[i].wait_time=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else Customer[i].wait_time=0;</span><br></pre></td></tr></table></figure></li>
<li>3、4步维护总等待时间，当当前顾客到达时间&gt;=17.，结束啦！</li>
</ol>
<p> <strong>注意点</strong>：</p>
<ol>
<li>时间以s统一界定，以免逻辑上把自己给绕晕；</li>
<li>构造数据结构node，存放每个顾客的到达时间，等待时间，结束时间，以及处理时间；</li>
<li>构造优先队列priority_queue,重载&lt;号，结束时间早的优先；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int arr_time;</span><br><span class="line">    int wait_time;//以s计算的等待时间</span><br><span class="line">    int finish_time,p_time;//以s计算的结束时间与处理时间</span><br><span class="line"></span><br><span class="line">    friend bool operator &lt;(const node&amp;a,const node&amp;b)&#123;</span><br><span class="line">        return a.finish_time&gt;b.finish_time;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;Customer[10005];</span><br><span class="line">priority_queue &lt;node&gt; Lines;</span><br></pre></td></tr></table></figure>
<h2 id="eg2-1014-Waiting-in-Line-30-分"><a href="#eg2-1014-Waiting-in-Line-30-分" class="headerlink" title="eg2.1014 Waiting in Line (30 分)"></a>eg2.<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936">1014 Waiting in Line (30 分)</a></h2></li>
</ol>
<p> <strong>题意</strong>：输入窗口数，黄线内每个队伍的最大人数，顾客数与查询数；输入顾客的处理时间，8.开始处理，17.后不接受处理，计算每个顾客处理结束的时间；<br> <strong>思路</strong>：</p>
<ol>
<li>构造顾客数据结构，存放处理时间与结束时间；</li>
<li>queue<node>[i]作为窗口，存放在黄线内的顾客；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int pro_time;</span><br><span class="line">    int fin_time;</span><br><span class="line">    node(int _p,int _f)</span><br><span class="line">    &#123;</span><br><span class="line">        pro_time=_p;</span><br><span class="line">        fin_time=_f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; Lines[25];</span><br></pre></td></tr></table></figure></li>
<li>flag_time[25]数组表示每个窗口队首的结束时间，wf_time[1005]存放K个顾客的结束时间；</li>
<li>填满黄线内窗口空位M*N，一旦进入黄线，结束顾客结束时间确定，即队列顾客back的结束时间+当前顾客的处理时间，更新flag_time与wf_time;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ff=true;</span><br><span class="line">    for(int i=0;i&lt;M&amp;&amp;ff;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">            int temp_time;</span><br><span class="line">            if(Lines[j].size()==0)temp_time=0;</span><br><span class="line">            else temp_time=Lines[j].back().fin_time;</span><br><span class="line">            Lines[j].push(node(p_time[index],p_time[index]+temp_time));</span><br><span class="line">            flag_time[j]=Lines[j].front().fin_time;</span><br><span class="line">            if(temp_time&gt;=540)wf_time[index]=-1;//开始的时间在17.及之后</span><br><span class="line">            else wf_time[index]=p_time[index]+temp_time;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;K)&#123;</span><br><span class="line">                    ff=false;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>黄线外顾客进入队列,首先找到flag_time[]中的最小值，因为最小即该队列最先会有人结束，记录窗口值，队首顾客出队，下一个顾客进队，更新flag_time与wf_time;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=index;i&lt;K;i++)&#123;</span><br><span class="line">        //找到flag_time中的最小值</span><br><span class="line">        int Min=flag_time[0];</span><br><span class="line">        int Min_index=0;</span><br><span class="line">        for(int w=1;w&lt;N;w++)&#123;</span><br><span class="line">            if(flag_time[w]&lt;Min)&#123;</span><br><span class="line">                Min=flag_time[w];</span><br><span class="line">                Min_index=w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第Min_index个窗口最先处理完</span><br><span class="line">        int temp_time=Lines[Min_index].back().fin_time;</span><br><span class="line">           // cout&lt;&lt;temp_time&lt;&lt;&quot; &quot;&lt;&lt;p_time[index]&lt;&lt;endl;</span><br><span class="line">        Lines[Min_index].pop();</span><br><span class="line">        Lines[Min_index].push(node(p_time[index],p_time[index]+temp_time));</span><br><span class="line">        flag_time[Min_index]=Lines[Min_index].front().fin_time;</span><br><span class="line">        if(temp_time&gt;=540)wf_time[index]=-1;//开始的时间在17.及之后</span><br><span class="line">        else wf_time[index]=p_time[index]+temp_time;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <strong>注意点</strong>：</p>
<ol>
<li>if-else，当顾客的开始处理时间在17.及之后，直接忽略了；<h2 id="eg3-1026-Table-Tennis-30-分"><a href="#eg3-1026-Table-Tennis-30-分" class="headerlink" title="eg3. 1026 Table Tennis (30 分)"></a>eg3. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560">1026 Table Tennis (30 分)</a></h2></li>
</ol>
<hr>
<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="eg1-1002-A-B-for-Polynomials-25-分"><a href="#eg1-1002-A-B-for-Polynomials-25-分" class="headerlink" title="eg1. 1002 A+B for Polynomials (25 分)"></a>eg1. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000">1002 A+B for Polynomials (25 分)</a></h2><h2 id="eg2-1009-Product-of-Polynomials-25-分"><a href="#eg2-1009-Product-of-Polynomials-25-分" class="headerlink" title="eg2. 1009 Product of Polynomials (25 分)"></a>eg2. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344">1009 Product of Polynomials (25 分)</a></h2><p> <strong>题意</strong>：输入指数与系数，求两个多项式的和（或乘积）；按指数从大到小输出非零项；<br> <strong>思路</strong>：map&lt;int,double&gt;a,b作为输入的A、B多项式；map&lt;int,double,greater<int> &gt;作为结果（加入greater表示按key值从大到小排列）；<br> <a href="https://www.cnblogs.com/lvchaoshun/p/7769003.html">pair用法</a>:make_pair(x,y);pair-&gt;first<br> <a href="https://blog.csdn.net/sevenjoin/article/details/81943864">map用法</a>:每个key在map中只能出现一次；mp.insert(pair);mp.erase(iter);mp.size();</p>
<h1 id="计算树的叶子结点"><a href="#计算树的叶子结点" class="headerlink" title="计算树的叶子结点"></a>计算树的叶子结点</h1><h2 id="eg1-1004-Counting-Leaves-30-分"><a href="#eg1-1004-Counting-Leaves-30-分" class="headerlink" title="eg1. 1004 Counting Leaves (30 分)"></a>eg1. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184">1004 Counting Leaves (30 分)</a></h2><p> <strong>题意</strong>：家谱树，计算每层没有孩子的成员，即计算树的每层叶子结点树；输入树中结点总数N，以及叶子结点数M；输出M个非叶子结点的K个孩子；输出各层叶子结点的个数；<br> <strong>思路</strong>：</p>
<ol>
<li>数据结构树的结点使用vector存放孩子列表，层数以及当前index；</li>
<li>树的BFS queue;依次将树结点压入队列，同一层的拥有一样的父母结点，都会挤在一起；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Layer_Tra()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    int leavenum=0;</span><br><span class="line">    q.push(Family[1]);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node n=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(n.children.size()==0)&#123;</span><br><span class="line">            leaves[n.level]++;</span><br><span class="line">        &#125;</span><br><span class="line">        now_level=n.level;</span><br><span class="line">       // cout&lt;&lt;now_level&lt;&lt;endl;</span><br><span class="line">        for(int i=0;i&lt;n.children.size();i++)&#123;</span><br><span class="line">            Family[n.children[i]].level=n.level+1;</span><br><span class="line">            //node temp=Family[n.children[i]];</span><br><span class="line">            q.push(Family[n.children[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eg2-1094-The-Largest-Generation-25-分"><a href="#eg2-1094-The-Largest-Generation-25-分" class="headerlink" title="eg2. 1094 The Largest Generation (25 分)"></a>eg2. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048">1094 The Largest Generation (25 分)</a></h2></li>
</ol>
<p> <strong>题意</strong>：同上题，计算的是有最多成员的成员值以及层数；<br> <strong>思路</strong>：同样是使用BFS，用level更新孩子们所在层数，同时用数组[parent.level+1]来维护该层结点的个数；</p>
<h1 id="计算最佳路径（图的DFS）"><a href="#计算最佳路径（图的DFS）" class="headerlink" title="计算最佳路径（图的DFS）"></a>计算最佳路径（图的DFS）</h1><h2 id="eg1-1003-Emergency-25-分"><a href="#eg1-1003-Emergency-25-分" class="headerlink" title="eg1. 1003 Emergency (25 分)"></a>eg1. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003 Emergency (25 分)</a></h2><p> <strong>题意</strong>：输入城市数N、路径数M、in and save city,N个城市的rescue数，M条路径；找出最短路径的长度，以及在路上可以收集的最大rescue teams；输出最短路径的数量以及最大值；<br> <strong>思路</strong>：</p>
<ol>
<li>构建一张有权无向图，求路径最短及节点上值和最大的路径；</li>
<li>DFS(start,end)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(index==End)&#123;</span><br><span class="line">    ...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">                if(Map[index][i]!=0&amp;&amp;flag[i]==false)&#123;</span><br><span class="line">                    flag[i]=true;</span><br><span class="line">                    length+=Map[index][i];</span><br><span class="line">                    rescueSum+=rescueNum[i];</span><br><span class="line">                    DFS(i,End);</span><br><span class="line">                    flag[i]=false;</span><br><span class="line">                    length-=Map[index][i];</span><br><span class="line">                    rescueSum-=rescueNum[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <strong>注意点</strong>：<br> 1.在进入DFS函数前初始化，将起点flag[C1]置为true等：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rescueSum+=rescueNum[C1];</span><br><span class="line">flag[C1]=1;</span><br><span class="line">DFS(C1,C2);</span><br></pre></td></tr></table></figure></p>
<h1 id="时间的比较"><a href="#时间的比较" class="headerlink" title="时间的比较"></a>时间的比较</h1><h2 id="eg-1006-Sign-In-and-Sign-Out-25-分"><a href="#eg-1006-Sign-In-and-Sign-Out-25-分" class="headerlink" title="eg. 1006 Sign In and Sign Out (25 分)"></a>eg. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805516654460928">1006 Sign In and Sign Out (25 分)</a></h2><p><strong>题意</strong>：输入记录：ID+到达时间+离开时间，分别找到最早到与最晚离开的同学，输出ID；<br><strong>思路</strong>：<br>pair的妙用:first存时间，second存学号；max与min比较的是first字段；时间字符串直接按字典序比较；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef pair&lt;string,string&gt; tlog;</span><br><span class="line">tlog ear = tlog(b,a),las = tlog(c,a); </span><br><span class="line">	for (int i=1;i&lt;n;i++)</span><br><span class="line">	  &#123;</span><br><span class="line">	  	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	    ear = min(ear,tlog(b,a));//# include &lt;algorithm&gt;</span><br><span class="line">	    las = max(las,tlog(c,a));</span><br><span class="line">	  &#125;</span><br><span class="line">cout &lt;&lt; ear.second &lt;&lt; &#x27; &#x27; &lt;&lt; las.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="大数-二分查找"><a href="#大数-二分查找" class="headerlink" title="大数+二分查找"></a>大数+二分查找</h1><p><strong>题意</strong>：输入2个数以及其中一个数的进制，找到使这两个数相等的另一个数的进制；<br><strong>思路</strong>：</p>
<ol>
<li>字符串输入，转换成10进制比较；</li>
<li>二分查找；</li>
</ol>
<p><strong>注意点</strong>：</p>
<ol>
<li>转换成10进制时，有可能溢出，需要判断；</li>
<li>二分查找的范围是当前值各个位数中的最大值+1，已知进制值的这个数+1（不可能比这个数更大了，因为这时表示为10）；<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944">1051 Pop Sequence (25 分)</a><br>判断pop序列是否正确</li>
</ol>
<p><strong>思路</strong>:</p>
<ol>
<li>模拟1~N的入栈，以current指向序列首位；遇到相同的则出栈，current后移；</li>
<li>当超出栈容量或者全入栈后，current不为N时，则序列不正确；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int M,N,K;// stack的最大容量，push长度，数量</span><br><span class="line">    vector&lt;int&gt; popList;// pop序列</span><br><span class="line">    vector&lt;int&gt; myStack;// 栈</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;K);</span><br><span class="line">    while(K--)&#123;</span><br><span class="line">        int num;</span><br><span class="line">        popList.clear();</span><br><span class="line">        myStack.clear();</span><br><span class="line">        // 输入pop序列</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">            popList.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        int current=0;// 指向popList当前位置</span><br><span class="line">        bool flag=true;// 标记</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            myStack.push_back(i);// 入栈</span><br><span class="line">            // 超过最大容量</span><br><span class="line">            if(myStack.size()&gt;M)&#123;</span><br><span class="line">                flag=false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当发现当前栈元素与popList头部元素相似</span><br><span class="line">            while(!myStack.empty()&amp;&amp;myStack.back()==popList[current])&#123;</span><br><span class="line">                myStack.pop_back();</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当popList没有遍历完全或者超出最大容量</span><br><span class="line">        if(current!=N||flag==false)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805419468242944">1056 Mice and Rice (25 分)</a></li>
</ol>
<p><strong>思路</strong>:</p>
<ol>
<li>题目看了很久才理解;</li>
<li>使用一个队列存放参赛者名单，pop首部来模拟小组比赛，将获胜者push到队列尾巴，知道队列中只剩一个笑到最后的玩家;</li>
<li>注意在模拟每一局比赛时，固定初始队列大小，而不是动态获取；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX=1010;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int Weight;</span><br><span class="line">    int Rank;</span><br><span class="line">    int Pos;</span><br><span class="line">&#125;Input[MAX];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int NP,NG;//参赛者数，小组人数</span><br><span class="line">    queue&lt;node&gt; mice;// 存放参加比赛的老鼠</span><br><span class="line">    cin&gt;&gt;NP&gt;&gt;NG;</span><br><span class="line">    for(int i=0;i&lt;NP;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Input[i].Weight;</span><br><span class="line">        Input[i].Pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    //将初始比赛序列放入队列</span><br><span class="line">    int p;</span><br><span class="line">    for(int i=0;i&lt;NP;i++)&#123;</span><br><span class="line">        cin&gt;&gt;p;</span><br><span class="line">        mice.push(Input[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    while(!mice.empty())&#123;</span><br><span class="line">        //当队列中只剩一个</span><br><span class="line">        if(mice.size()==1)&#123;</span><br><span class="line">            node temp=mice.front();</span><br><span class="line">            Input[temp.Pos].Rank=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int groupNum=mice.size()/NG;//比赛数</span><br><span class="line">        if(mice.size()%NG!=0)groupNum+=1;//剩余的归于一组</span><br><span class="line">        int oneTimeNum=mice.size();//记录本轮参与者数量</span><br><span class="line">                                   //直接使用mice.size()会在一组比赛结束后发生变化(得到获胜者，插入到队列中后</span><br><span class="line">        for(int i=0;i&lt;groupNum;i++)&#123;</span><br><span class="line">            int winPosition;</span><br><span class="line">            int maxW=-1;</span><br><span class="line">            int memberNum=NG;</span><br><span class="line">            // 最后一组特殊情况考虑</span><br><span class="line">            if(i==groupNum-1&amp;&amp;oneTimeNum%NG!=0)&#123;</span><br><span class="line">                memberNum=oneTimeNum%NG;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=0;j&lt;memberNum;j++)&#123;</span><br><span class="line">                node temp=mice.front();</span><br><span class="line">                mice.pop();</span><br><span class="line">                if(maxW&lt;temp.Weight)&#123;</span><br><span class="line">                    maxW=temp.Weight;</span><br><span class="line">                    winPosition=temp.Pos;</span><br><span class="line">                &#125;</span><br><span class="line">                Input[temp.Pos].Rank=groupNum+1;</span><br><span class="line">            &#125;</span><br><span class="line">            mice.push(Input[winPosition]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出</span><br><span class="line">    for(int i=0;i&lt;NP;i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;Input[i].Rank;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464">1052 Linked List Sorting (25 分)</a></li>
</ol>
<p><strong>思路</strong>：</p>
<ol>
<li>按order排序，按序输出；</li>
<li>有效node的order为key值，无效node的order设为最大值，则在排序时会排到后面去；</li>
<li>注意：需要对原链表遍历处理，清除无效结点；当有效结点值为空的输出；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX = 100010;</span><br><span class="line">struct node &#123;</span><br><span class="line">    int add,key,next;</span><br><span class="line">    int order;</span><br><span class="line"></span><br><span class="line">&#125;myList[MAX];</span><br><span class="line">int N,head;</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.order&lt;b.order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 初始化，使空结点值排到后面</span><br><span class="line">    for(int i=0;i&lt;MAX;i++)&#123;</span><br><span class="line">        myList[i].order=MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;head);</span><br><span class="line">    // 输入N个结点</span><br><span class="line">    int address,key,nextadd;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;address,&amp;key,&amp;nextadd);</span><br><span class="line">        myList[address].add=address;</span><br><span class="line">        myList[address].key=key;</span><br><span class="line">        myList[address].next=nextadd;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp=head;</span><br><span class="line">    int vaild=0;</span><br><span class="line">    while(temp!=-1)&#123;</span><br><span class="line">        vaild++;</span><br><span class="line">        myList[temp].order=myList[temp].key;</span><br><span class="line">        temp=myList[temp].next;</span><br><span class="line">    &#125;</span><br><span class="line">    N=vaild;</span><br><span class="line">    if(N==0)&#123;</span><br><span class="line">        printf(&quot;%d %d\n&quot;,N,-1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(myList,myList+MAX,cmp);</span><br><span class="line">    printf(&quot;%d %05d\n&quot;,N,myList[0].add);</span><br><span class="line">    for(int i=0;i&lt;N-1;i++)&#123;</span><br><span class="line">        printf(&quot;%05d %d %05d\n&quot;,myList[i].add,myList[i].key,myList[i+1].add);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%05d %d %0d\n&quot;,myList[N-1].add,myList[N-1].key,-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080">1033 To Fill or Not to Fill (25 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const double MAX=10000000000;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    double price;</span><br><span class="line">    double dis;</span><br><span class="line">&#125;gasStation[505];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.dis&lt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double Cmax,D,Davg;//车的最大储油量</span><br><span class="line">                      //出发地与目标地之间的距离</span><br><span class="line">                      //每单位油可走的距离</span><br><span class="line">    int N;//N个gas station</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%lf%lf%lf%d&quot;,&amp;Cmax,&amp;D,&amp;Davg,&amp;N);</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;gasStation[i].price,&amp;gasStation[i].dis);</span><br><span class="line">    &#125;</span><br><span class="line">    gasStation[N].dis=D;</span><br><span class="line">    gasStation[N].price=0;</span><br><span class="line">    sort(gasStation,gasStation+N+1,cmp);</span><br><span class="line">    /*for(int i=0;i&lt;=N;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;gasStation[i].dis&lt;&lt;&quot; &quot;&lt;&lt;gasStation[i].price&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;*********************&quot;&lt;&lt;endl;*/</span><br><span class="line">    //贪心策略</span><br><span class="line">    //在每一油站判断</span><br><span class="line">    //找到比当前油站price更小的最近可达的油站，加油加到刚好到达该站即可；</span><br><span class="line">    //否则在该站加满油,然后前往可达范围内油价最低的油站；</span><br><span class="line">    double maxLen=Cmax*Davg;//满油状态下的最大里程</span><br><span class="line">    int pos=0;//车到达位置</span><br><span class="line">    double nowGas=0;//当前油量</span><br><span class="line">    double totalPrice=0;//总油价</span><br><span class="line">    double totalLen=0;//总里程</span><br><span class="line">    //当起点没有油站时</span><br><span class="line">    if(gasStation[0].dis!=0)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;The maximum travel distance = 0.00&quot;&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(pos&lt;N)&#123;</span><br><span class="line">        double lowPrice=MAX;</span><br><span class="line">        int i,tempPos=pos;</span><br><span class="line">        bool flag=false;</span><br><span class="line">        for(i=pos+1;i&lt;=N &amp;&amp; gasStation[i].dis-gasStation[pos].dis&lt;=maxLen;i++)&#123;</span><br><span class="line">            if (gasStation[i].price &lt; gasStation[pos].price) &#123;//发现可达范围内存在比当前油价低的油站</span><br><span class="line">                double needGas=(gasStation[i].dis-gasStation[pos].dis)/Davg;</span><br><span class="line">                if(nowGas&gt;=needGas)&#123;//本来剩余油可达，无需加油啦</span><br><span class="line">                    nowGas-=needGas;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    totalPrice+=(needGas-nowGas)*gasStation[pos].price;</span><br><span class="line">                    nowGas=0;</span><br><span class="line">                &#125;</span><br><span class="line">                pos=i;//去往i油站</span><br><span class="line">                totalLen=gasStation[pos].dis;</span><br><span class="line">                flag=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(gasStation[i].price &lt; lowPrice)&#123;</span><br><span class="line">                lowPrice=gasStation[i].price;</span><br><span class="line">                tempPos=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(gasStation[pos+1].dis-gasStation[pos].dis&gt;maxLen)&#123;//满油也无法到达最近的油站</span><br><span class="line">            printf(&quot;The maximum travel distance = %.2lf&quot;,totalLen+maxLen);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==false)&#123;//说明可达范围内没有比当前更便宜的了，充满</span><br><span class="line">            totalPrice+=(Cmax-nowGas)*gasStation[pos].price;</span><br><span class="line">            nowGas=Cmax-(gasStation[tempPos].dis-gasStation[pos].dis)/Davg;</span><br><span class="line">            pos=tempPos;</span><br><span class="line">            totalLen=gasStation[pos].dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%.2lf&quot;,totalPrice);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805403651522560">1067 Sort with Swap(0, i) (25 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int N;</span><br><span class="line">vector&lt;int&gt;permutation;</span><br><span class="line">void outPut()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cout&lt;&lt;permutation[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    map&lt;int,int&gt;myMap;//存储值与位置关系</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    int input;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;input;</span><br><span class="line">        permutation.push_back(input);</span><br><span class="line">        myMap[input]=i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int num=0;</span><br><span class="line">    int j=1;//将j提到前面来，避免不必要的循环判断</span><br><span class="line">    //贪心</span><br><span class="line">    //0当前在哪个位置上，就去找最终应该在这个位置上的值，swap</span><br><span class="line">    while(true&amp;&amp;N!=0)&#123;</span><br><span class="line">        int pos=myMap[0];</span><br><span class="line">        //当0在0位置上时，实际上序列还没有完成排序</span><br><span class="line">        //与第一个未呆在正确位置的值swap</span><br><span class="line">        if(pos==0)&#123;</span><br><span class="line">            for(j;j&lt;N;j++)&#123;//从左到右找到第一个不在本位的值</span><br><span class="line">                if(permutation[j]!=j)&#123;</span><br><span class="line">                       // cout&lt;&lt;j;</span><br><span class="line">                    swap(permutation[j],permutation[0]);</span><br><span class="line">                    myMap[0]=j;</span><br><span class="line">                    myMap[permutation[0]]=0;//0与j已交换</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j==N)break;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            swap(permutation[myMap[0]],permutation[myMap[pos]]);</span><br><span class="line">            myMap[0]=myMap[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        //outPut();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072">1020 Tree Traversals (25 分)</a><br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024">1086 Tree Traversals Again (25 分)</a><br>已知树的中序遍历、后序(先序)遍历，建树；<br><strong>思路</strong>：(以先序为例)</p>
<ol>
<li>先序遍历的首位结点为当前数的根结点;</li>
<li>在中序遍历中找到首位结点的位置，将该树分为左子树与右子树2部分;</li>
<li>递归求左右子树，直到当前结点为空;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt;preOrder,inOrder,tempOrder,postOrder;</span><br><span class="line">int N;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* CreateTree(int prel,int prer,int inl,int inr)</span><br><span class="line">&#123;</span><br><span class="line">    if(prel&lt;=prer)&#123;</span><br><span class="line">        int k;</span><br><span class="line">        //postr即为当前根节点值</span><br><span class="line">        //找到中序排列中根节点的位置</span><br><span class="line">        for(k=inl;k&lt;=inr;k++)&#123;</span><br><span class="line">            if(inOrder[k]==preOrder[prel])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //左子树的结点值</span><br><span class="line">        int numLeft=k-inl;</span><br><span class="line">        node* root=new node;</span><br><span class="line">        root-&gt;data=inOrder[k];</span><br><span class="line">        root-&gt;left=CreateTree(prel+1,prel+numLeft,inl,k-1);</span><br><span class="line">        root-&gt;right=CreateTree(prel+numLeft+1,prer,k+1,inr);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后序遍历</span><br><span class="line">void postTraversals(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)return;</span><br><span class="line">    postTraversals(root-&gt;left);</span><br><span class="line">    postTraversals(root-&gt;right);</span><br><span class="line">    postOrder.push_back(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int input;</span><br><span class="line">    char oper[5];</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int i=0;i&lt;2*N;i++)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;oper);</span><br><span class="line">        if(!strcmp(oper,&quot;Push&quot;))&#123;</span><br><span class="line">            cin&gt;&gt;input;</span><br><span class="line">            preOrder.push_back(input);</span><br><span class="line">            tempOrder.push_back(input);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            int in=tempOrder.back();</span><br><span class="line">            tempOrder.pop_back();</span><br><span class="line">            inOrder.push_back(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root=CreateTree(0,N-1,0,N-1);</span><br><span class="line">    postTraversals(root);</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;postOrder[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805388447170560">1079 Total Sales of Supply Chain (25 分)</a></li>
</ol>
<p><strong>思路</strong>:<strong>DFS</strong></p>
<ol>
<li>求供应链中产品从供应商到零售商流动后，得到最终的总价格；</li>
<li>即DFS遍历求每个叶子结点的深度；<br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805376476626944">1090 Highest Price in Supply Chain (25 分)</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int products;</span><br><span class="line">    vector&lt;int&gt; child;</span><br><span class="line">&#125;supplyChain[100001];</span><br><span class="line"></span><br><span class="line">int N;//结点数</span><br><span class="line">double P,r;//根节点的初始价格，每层增加的百分比</span><br><span class="line">double sum=0;</span><br><span class="line"></span><br><span class="line">void DFS(int root,int level)</span><br><span class="line">&#123;</span><br><span class="line">    if(supplyChain[root].child.size()==0)&#123;//到达根节点</span><br><span class="line">        sum+=pow(r,level)*supplyChain[root].products*P;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;supplyChain[root].child.size();i++)&#123;</span><br><span class="line">        DFS(supplyChain[root].child[i],level+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%lf%lf&quot;,&amp;N,&amp;P,&amp;r);</span><br><span class="line">    r=(double)1+r/100;</span><br><span class="line">    int k,input;</span><br><span class="line">    //输入</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        if(k==0)&#123;</span><br><span class="line">            cin&gt;&gt;supplyChain[i].products;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int j=0;j&lt;k;j++)&#123;</span><br><span class="line">                cin&gt;&gt;input;</span><br><span class="line">                supplyChain[i].child.push_back(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //DFS求层数</span><br><span class="line">    DFS(0,0);</span><br><span class="line">    printf(&quot;%.1lf&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048">The Largest Generation (25 分)</a><br>求拥有最大结点数的level<br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184">1004 Counting Leaves (30 分)</a><br>求树的每层叶子结点数,可用DFS或BFS；</li>
</ol>
<p><strong>思路</strong>:（BFS）</p>
<ol>
<li>使用一个queue做BFS，一个level[i]数组存储i结点所在的层数,一个res[i]数组存储i层的叶子节点数;</li>
<li>pop出当前结点;for循环得出当前结点的孩子结点，此时设置孩子结点的level为当前结点level+1;</li>
<li>当当前结点孩子数为空，则为叶子结点，res[level]++;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;//总结点数，非叶子结点数</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; myTree[105];</span><br><span class="line">int res[105]=&#123;0&#125;;</span><br><span class="line">int level[105]=&#123;0&#125;;//各结点所处的层号</span><br><span class="line">int maxlevel=-1;</span><br><span class="line"></span><br><span class="line">void BFS(int root)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt;myQueue;</span><br><span class="line">    myQueue.push(root);</span><br><span class="line">    while(!myQueue.empty())&#123;</span><br><span class="line">        int temp=myQueue.front();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        maxlevel=max(maxlevel,level[temp]);</span><br><span class="line">        if(myTree[temp].size()==0)&#123;</span><br><span class="line">            res[level[temp]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;myTree[temp].size();i++)&#123;</span><br><span class="line">            level[myTree[temp][i]]=level[temp]+1;</span><br><span class="line">            myQueue.push(myTree[temp][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int id,k;//结点id，子节点数</span><br><span class="line">    int input;</span><br><span class="line">    memset(res,0,sizeof(res));</span><br><span class="line">    for(int i=0;i&lt;M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;k;</span><br><span class="line">        for(int j=0;j&lt;k;j++)&#123;</span><br><span class="line">            cin&gt;&gt;input;</span><br><span class="line">            myTree[id].push_back(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    level[1]=1;</span><br><span class="line">    BFS(1);</span><br><span class="line">    for(int i=1;i&lt;=maxlevel;i++)&#123;</span><br><span class="line">        if(i!=1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856">1043 Is It a Binary Search Tree (25 分)</a><br>判断给定序列是否为BST，或者BST的镜像;</li>
</ol>
<p><strong>思路</strong>:</p>
<ol>
<li>边输入值，边构建二叉搜索树,判断当前插入在root的左子树或右子树;</li>
<li>构建完树后进行先序遍历与镜像先序遍历，判断是否与输入初始序列相同;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line">node* myRoot=NULL;</span><br><span class="line">int original[1005],pre[1005],preMirror[1005],post[1005],postMirror[1005];</span><br><span class="line">int iindex=0;</span><br><span class="line"></span><br><span class="line">void CreatBST(node* &amp;root,int data)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;//当根结点为空</span><br><span class="line">        root=new node;</span><br><span class="line">        root-&gt;data=data;</span><br><span class="line">        root-&gt;left=NULL;</span><br><span class="line">        root-&gt;right=NULL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(data&gt;=root-&gt;data)&#123;//插入到右子树中</span><br><span class="line">        CreatBST(root-&gt;right,data);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;//插入到左子树</span><br><span class="line">        CreatBST(root-&gt;left,data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[iindex++]=root-&gt;data;</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preMirrorOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    preMirror[iindex++]=root-&gt;data;</span><br><span class="line">    preMirrorOrder(root-&gt;right);</span><br><span class="line">    preMirrorOrder(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSame(int a[],int b[])</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        if(a[i]!=b[i])return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void postOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line">    post[iindex++]=root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void postMirrorOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    postMirrorOrder(root-&gt;right);</span><br><span class="line">    postMirrorOrder(root-&gt;left);</span><br><span class="line">    postMirror[iindex++]=root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    int data;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;data;</span><br><span class="line">        CreatBST(myRoot,data);</span><br><span class="line">        original[i]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    //先序遍历</span><br><span class="line">    preOrder(myRoot);</span><br><span class="line">    //镜像BST的先序遍历</span><br><span class="line">    iindex=0;</span><br><span class="line">    preMirrorOrder(myRoot);</span><br><span class="line">    if(isSame(original,pre))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        iindex=0;</span><br><span class="line">        postOrder(myRoot);</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">            cout&lt;&lt;post[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(isSame(original,preMirror))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        iindex=0;</span><br><span class="line">        postMirrorOrder(myRoot);</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">            cout&lt;&lt;postMirror[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全二叉排序树CBST"><a href="#完全二叉排序树CBST" class="headerlink" title="完全二叉排序树CBST"></a>完全二叉排序树CBST</h3><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805407749357568">1064 Complete Binary Search Tree (30分)</a><br>构建一棵CBST</li>
</ol>
<p><strong>思路</strong>：CBST的特点：如果使用数组存放完全二叉树（即层序存放的结果），那么对于x结点，其左孩子结点为2x，右孩子结点为2x+1（假设存在）;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int data[1001],tree[1001];</span><br><span class="line">int pos=1;</span><br><span class="line">int N;//N&lt;=1000</span><br><span class="line">//使用中序遍历方法构建CBST</span><br><span class="line">void CreateCBST(int root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&gt;N)return;</span><br><span class="line">    int l=2*root;</span><br><span class="line">    int r=2*root+1;</span><br><span class="line">    CreateCBST(l);</span><br><span class="line">    tree[root]=data[pos++];</span><br><span class="line">    CreateCBST(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(data+1,data+N+1);</span><br><span class="line">    CreateCBST(1);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        if(i!=1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805404939173888">1066 Root of AVL Tree (25 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int N;//结点数</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    int height;//当前结点高度</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//获取以root为根结点的树的高度</span><br><span class="line">int getHeight(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)return 0;</span><br><span class="line">    return root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新高度</span><br><span class="line">void updateHeight(node* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    root-&gt;height=max(getHeight(root-&gt;left),getHeight(root-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取以root为根结点的树的平衡因子</span><br><span class="line">//左子树高度-右子树高度</span><br><span class="line">int getBF(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    return getHeight(root-&gt;left)-getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左旋(逆时针</span><br><span class="line">void L(node* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    node* temp=root-&gt;right;//temp为旋转后的根结点</span><br><span class="line">    root-&gt;right=temp-&gt;left;//temp结点的左子树放在root结点的右子树位置</span><br><span class="line">    temp-&gt;left=root;//temp的左子树改为root</span><br><span class="line">    //更新高度</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//右旋(顺时针</span><br><span class="line">void R(node* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    node* temp=root-&gt;left;//temp为旋转后根节点</span><br><span class="line">    root-&gt;left=temp-&gt;right;//temp的右子树放在root结点的左子树位置</span><br><span class="line">    temp-&gt;right=root;</span><br><span class="line">    //更新高度</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertNode(node* &amp;root,int data)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        root=new node;</span><br><span class="line">        root-&gt;data=data;</span><br><span class="line">        root-&gt;left=NULL;</span><br><span class="line">        root-&gt;right=NULL;</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(data&lt;root-&gt;data)&#123;//插入左子树</span><br><span class="line">        insertNode(root-&gt;left,data);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        if(getBF(root)==2)&#123;</span><br><span class="line">            if(getBF(root-&gt;left)==1)&#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(getBF(root-&gt;left)==-1)&#123;</span><br><span class="line">                L(root-&gt;left);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        insertNode(root-&gt;right,data);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        if(getBF(root)==-2)&#123;</span><br><span class="line">            if(getBF(root-&gt;right)==-1)&#123;</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(getBF(root-&gt;right)==1)&#123;</span><br><span class="line">                R(root-&gt;right);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    int data;</span><br><span class="line">    node* myRoot=NULL;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;data;</span><br><span class="line">        insertNode(myRoot,data);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;myRoot-&gt;data;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744">1107 Social Clusters (30 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int pre[1005];</span><br><span class="line">int hobby[1005];</span><br><span class="line">int isRoot[1005];//每个门派中人数</span><br><span class="line">int N,K;//总人数，爱好数</span><br><span class="line">//初始化,将所有的掌门人设为本身</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">        hobby[i]=0;</span><br><span class="line">        isRoot[i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findRoot(int root)</span><br><span class="line">&#123;</span><br><span class="line">    int son,temp;</span><br><span class="line">    son=root;</span><br><span class="line">    //找到最上层掌门人</span><br><span class="line">    while(root!=pre[root])&#123;</span><br><span class="line">        root=pre[root];</span><br><span class="line">    &#125;</span><br><span class="line">    //路径压缩</span><br><span class="line">    //将这条路上遇到的结点pre[x]都直接设置为root</span><br><span class="line">    while(son!=root)&#123;</span><br><span class="line">        temp=pre[son];</span><br><span class="line">        pre[son]=root;</span><br><span class="line">        son=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int root1=findRoot(a);</span><br><span class="line">    int root2=findRoot(b);</span><br><span class="line">    if(root1!=root2)&#123;</span><br><span class="line">        pre[root1]=root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int h;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    init();</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        scanf(&quot;%d:&quot;,&amp;K);</span><br><span class="line">        for(int j=0;j&lt;K;j++)&#123;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            if(hobby[h]==0)&#123;//目前没有人有这个爱好</span><br><span class="line">                hobby[h]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            Union(i,hobby[h]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //统计属于同一门派的人数</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        isRoot[findRoot(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    //统计门派数量</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        if(isRoot[i]!=0)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    //从大到小排序</span><br><span class="line">    sort(isRoot+1,isRoot+N+1,cmp);</span><br><span class="line">    //输出</span><br><span class="line">    for(int i=1;i&lt;=ans;i++)&#123;</span><br><span class="line">        if(i!=1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;isRoot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840">1013 Battle Over Cities (25分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; myMap[1050];// map</span><br><span class="line">int N,M,K;// number of cities &lt; 1000</span><br><span class="line">          // number of remaining highways</span><br><span class="line">          // checked cities</span><br><span class="line">int father[1050];// 存放掌门结点</span><br><span class="line">int rootSet[1050];// 存放i掌门人所处派别人数</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">// 将所有结点的掌门人设为本身</span><br><span class="line">void init(int num)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=num;i++)&#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        rootSet[i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findRoot(int son)</span><br><span class="line">&#123;</span><br><span class="line">    int root=son;</span><br><span class="line">    while(root!=father[root])&#123;</span><br><span class="line">        root=father[root];</span><br><span class="line">    &#125;</span><br><span class="line">    int temp;</span><br><span class="line">    //路径压缩</span><br><span class="line">    while(son!=root)&#123;</span><br><span class="line">        temp=father[son];</span><br><span class="line">        father[son]=root;</span><br><span class="line">        son=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int rootx=findRoot(x);</span><br><span class="line">    int rooty=findRoot(y);</span><br><span class="line">    if(rootx!=rooty)&#123;</span><br><span class="line">        father[rootx]=rooty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 并查集法求连通块数</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    int x,y;</span><br><span class="line">    int block=0;</span><br><span class="line">    for(int i=0;i&lt;M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        myMap[x].push_back(y);</span><br><span class="line">        myMap[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    int concern;</span><br><span class="line">    for(int index=0;index&lt;K;index++)&#123;</span><br><span class="line">        init(N);</span><br><span class="line">        block=0;</span><br><span class="line">        cin&gt;&gt;concern;</span><br><span class="line">        // 枚举每条边</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;myMap[i].size();j++)&#123;</span><br><span class="line">                if(i==concern||myMap[i][j]==concern)continue;</span><br><span class="line">                Union(i,myMap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 统计不同的门派人数</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(i==concern)continue;</span><br><span class="line">            rootSet[findRoot(father[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(rootSet[i]!=0)block++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;block-1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>大数+二分查找</li>
</ol>
<p>模拟题:<br>考虑数据结构<br>一般思路：从一般到特殊</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建博客</title>
    <url>/2021/12/28/%E5%B7%A5%E5%85%B7/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>从0到1搭建hexo博客（前提是有github账号，且已和本地git相关联）</p>
<span id="more"></span>

<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h1><ol>
<li>安装hexo-cli</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化博客</li>
</ol>
<p>在一个位置上新建文件夹，以后就专门存放blog，然后再当前文件夹下执行初始化命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>常用命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure>

<h1 id="2-与github关联"><a href="#2-与github关联" class="headerlink" title="2 与github关联"></a>2 与github关联</h1><ol>
<li>更改根目录文件夹下的_config.yml文件</li>
</ol>
<p><img src="C:\Users\cct\AppData\Roaming\Typora\typora-user-images\image-20211228195059049.png" alt="image-20211228195059049"></p>
<ol start="2">
<li>安装git部署插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h1 id="3-主题更换"><a href="#3-主题更换" class="headerlink" title="3 主题更换"></a>3 主题更换</h1><ol>
<li>在<a href="!https://hexo.io/themes/">Theme</a>找到自己喜欢的主题</li>
<li>下载主题</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next // 对应主题的github位置</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根目录设置主题使用_config.yml</li>
</ol>
<img src="http://r4tsuv730.hd-bkt.clouddn.com/img/image-20211228195532314.png" alt="image-20211228195532314" style="zoom:50%;" />

<h1 id="4-高级"><a href="#4-高级" class="headerlink" title="4 高级"></a>4 高级</h1><h2 id="search实现"><a href="#search实现" class="headerlink" title="search实现"></a>search实现</h2><ol>
<li>blog根目录下安装插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根目录 _config.yml的配置</li>
</ol>
<p>配置1：</p>
<img src="http://r4tsuv730.hd-bkt.clouddn.com/img/image-20211228195921173.png" alt="image-20211228195921173" style="zoom:50%;" />

<p>配置2：</p>
<p>上面那个plugins的配置</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="!https://zhwangart.com/2019/07/02/Ocean-Issues/#1-1-%E5%A6%82%E4%BD%95%E9%A6%96%E9%A1%B5%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E6%91%98%E8%A6%81%EF%BC%9F">待探索</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="!https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
