<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="前端 Python 机器学习">
  
  
  <meta name="description" content="2021.12.28建的博客 看看我能坚持多久">
  
  <title>
    2020暑假刷题笔记 |
    
    Cecyci
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-2020暑假刷题笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  2020暑假刷题笔记
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/01/2020%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-08-01T02:23:44.000Z" itemprop="datePublished">2020-08-01</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="一-leetcode-113-路径总和2"><a href="#一-leetcode-113-路径总和2" class="headerlink" title="一. leetcode 113 路径总和2"></a>一. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">leetcode 113 路径总和2</a></h2><p><strong>前序遍历：</strong></p>
<ol>
<li>先处理当前结点（将该结点push到路径数组中，并且累加其结点值）；</li>
<li>再进行下一步的遍历；</li>
<li>完成当前结点的遍历后，回溯（将该结点pop出路径数组，并且更新结点值和）。<br>一般代码结构如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void preOrder(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; path, int sum, int cur_sum) &#123;</span><br><span class="line">        if (root == NULL) return;</span><br><span class="line">        path.push_back(root-&gt;val); // 更新路径</span><br><span class="line">        cur_sum += root-&gt;val; // 更新当前和</span><br><span class="line">        // 当前和与要求和相同，并且为叶子结点</span><br><span class="line">        if (cur_sum == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        preOrder(root-&gt;left, result, path, sum, cur_sum);</span><br><span class="line">        preOrder(root-&gt;right, result, path, sum, cur_sum);</span><br><span class="line">        // 左右子树都遍历完成后，在路径中删除当前值</span><br><span class="line">        path.pop_back();</span><br><span class="line">        cur_sum -= root-&gt;val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-leetcode-236-二叉树的最近公共祖先"><a href="#二-leetcode-236-二叉树的最近公共祖先" class="headerlink" title="二. leetcode 236 二叉树的最近公共祖先"></a>二. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode 236 二叉树的最近公共祖先</a></h2></li>
<li>分别以题目给出的两个结点为目标，对二叉树进行前序遍历，直到找到该目标，并且记录路径；</li>
<li>从头到尾对比两个路径，遇到的最后一个相同的即为最近公共祖先。</li>
</ol>
<h2 id="三-leetcode-114-二叉树展开为链表"><a href="#三-leetcode-114-二叉树展开为链表" class="headerlink" title="三. leetcode 114 二叉树展开为链表"></a>三. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">leetcode 114 二叉树展开为链表</a></h2><p>递归主要讨论的是左子树与右子树都拉直后的连接过程，忽略具体拉直过程，每个递归返回的有用信息是该树右子树的最后一个结点指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void preOrder(TreeNode* node, TreeNode* &amp;last) &#123;</span><br><span class="line">        if (!node) return;</span><br><span class="line">        // 判断该结点是否为叶子结点</span><br><span class="line">        // 是则为该子树的最后一个结点</span><br><span class="line">        // 返回</span><br><span class="line">        if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">            last = node;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = node-&gt;left;</span><br><span class="line">        TreeNode* right = node-&gt;right;</span><br><span class="line">        TreeNode* left_last = NULL;</span><br><span class="line">        TreeNode* right_last = NULL; // 左右子树的最后一个结点</span><br><span class="line">        // 前序遍历左子树</span><br><span class="line">        if (left) &#123;</span><br><span class="line">            preOrder(left, left_last);</span><br><span class="line">            node-&gt;left = NULL;</span><br><span class="line">            node-&gt;right = left;</span><br><span class="line">            last = left_last;</span><br><span class="line">        &#125;</span><br><span class="line">        // 前序遍历右子树</span><br><span class="line">        if (right) &#123;</span><br><span class="line">            preOrder(right, right_last);</span><br><span class="line">            if (left_last) // 没有该判断 报错！last没有初始化，为空</span><br><span class="line">                last-&gt;right = right;</span><br><span class="line">            last = right_last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        TreeNode * last;</span><br><span class="line">        preOrder(root, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="一-leetcode-199-二叉树的右视图"><a href="#一-leetcode-199-二叉树的右视图" class="headerlink" title="一. leetcode 199 二叉树的右视图"></a>一. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/submissions/">leetcode 199 二叉树的右视图</a></h2><p>图的宽度搜索（BFS）：</p>
<ol>
<li>使用队列queue，pair存储结点与层数；</li>
<li>将当前结点的左右结点分别push到队列中，同时记录层数；</li>
<li>按先进先出的顺序访问结点；</li>
<li>不断更新该层的最后一个结点；</li>
<li>得到结果数组。<br>一般代码结构为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans; // 按层遍历的最后一个结点</span><br><span class="line">        queue&lt;pair&lt;TreeNode*, int&gt; &gt; myQueue;</span><br><span class="line">        if (!root)return ans;</span><br><span class="line">        myQueue.push(make_pair(root, 0));</span><br><span class="line">        while (!myQueue.empty()) &#123;</span><br><span class="line">            TreeNode* cur_node = myQueue.front().first;</span><br><span class="line">            int cur_depth = myQueue.front().second;</span><br><span class="line">            myQueue.pop();</span><br><span class="line">            if (ans.size() == cur_depth) &#123; // 首次遇到在cur_depth层的结点 将结点值push到数组中</span><br><span class="line">                ans.push_back(cur_node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // 更新ans[cur_depth]的值</span><br><span class="line">                ans[cur_depth] = cur_node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur_node-&gt;left) &#123; // 存在左子树</span><br><span class="line">                myQueue.push(make_pair(cur_node-&gt;left, cur_depth + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur_node-&gt;right) &#123; // 存在左子树</span><br><span class="line">                myQueue.push(make_pair(cur_node-&gt;right, cur_depth + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二-leetcode-207-课程表"><a href="#二-leetcode-207-课程表" class="headerlink" title="二. leetcode 207 课程表"></a>二. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">leetcode 207 课程表</a></h2><p>两种方法：</p>
<ol>
<li>DFS遍历过程中，没有重复访问正在访问的结点（即存在从该结点返回到初始位置的路径）。<br>DFS的一般代码结构:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool DFS(GraphNode *node, vector&lt;int&gt; &amp;visit) &#123;</span><br><span class="line">       // 标记当前结点值正在访问</span><br><span class="line">       visit[node-&gt;label] = 0; </span><br><span class="line">       // 访问器邻接结点</span><br><span class="line">       for (int i = 0; i &lt; node-&gt;neighbors.size(); i++) &#123;</span><br><span class="line">           // 当前结点未被访问则继续深度遍历</span><br><span class="line">           if (visit[node-&gt;neighbors[i]-&gt;label] == -1) &#123;</span><br><span class="line">               if (!DFS(node-&gt;neighbors[i], visit))</span><br><span class="line">                   return false;</span><br><span class="line">           &#125;</span><br><span class="line">           // 当前结点出现环:访问正在访问的结点</span><br><span class="line">           else if (visit[node-&gt;neighbors[i]-&gt;label] == 0) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        // 标记当前结点值访问过</span><br><span class="line">       visit[node-&gt;label] = 1;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>BFS遍历后，无环：所有入度减少为0；有环：存在不为0的入度。</li>
</ol>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="一-leetcode-35-搜索插入位置"><a href="#一-leetcode-35-搜索插入位置" class="headerlink" title="一. leetcode 35 搜索插入位置"></a>一. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">leetcode 35 搜索插入位置</a></h2><p>标准二分查找法(重点：分析出未找到target值时，插入位置索引总是begin);<br>一般模板:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int begin = 0, end = nums.size() - 1;</span><br><span class="line">        int mid = 0;</span><br><span class="line">        while (begin &lt;= end) &#123;</span><br><span class="line">            mid = (begin + end) / 2;</span><br><span class="line">            if (target &lt; nums[mid]) &#123;</span><br><span class="line">                end = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (target &gt; nums[mid]) &#123;</span><br><span class="line">                begin = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#二、leetcode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="二、leetcode 34 在排序数组中查找元素的第一个和最后一个位置"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode 34 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>分别找左右边界，二分查找加入相等的处理判断;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 找左边界</span><br><span class="line">        while (begin &lt;= end) &#123;</span><br><span class="line">            mid = (begin + end) / 2;</span><br><span class="line">            // 前半部分</span><br><span class="line">            if (nums[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 后半部分</span><br><span class="line">            else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                begin = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 相等的情况</span><br><span class="line">            // 左边界要么就是mid，要么在前半部分</span><br><span class="line">            else &#123;</span><br><span class="line">                // mid为左边界</span><br><span class="line">                if (mid == 0 || nums[mid - 1] &lt; target) &#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 前半部分还有target值，继续二分查找</span><br><span class="line">                else &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、leetcode-33-搜索旋转排序数组"><a href="#三、leetcode-33-搜索旋转排序数组" class="headerlink" title="三、leetcode 33 搜索旋转排序数组"></a>三、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">leetcode 33 搜索旋转排序数组</a></h2><p>有点窒息的分类,二分查找的框架，每种情况都要清晰地讨论。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int begin = 0, end = nums.size() - 1;</span><br><span class="line">        int mid = 0;</span><br><span class="line">        while (begin &lt;= end) &#123;</span><br><span class="line">            mid = (begin + end ) / 2;</span><br><span class="line">            // 目标小于中间值</span><br><span class="line">            if (target &lt; nums[mid]) &#123;</span><br><span class="line">                // 前半部分为顺序区间，后半部分为旋转区间</span><br><span class="line">                if (nums[begin] &lt;= nums[mid]) &#123; // 注意！！等号表示mid与begin值相同时</span><br><span class="line">                    // 在顺序区间中找</span><br><span class="line">                    // 顺序区间内的最小值&lt;=target，则在顺序区间中找</span><br><span class="line">                    if (nums[begin] &lt;= target) end = mid - 1;</span><br><span class="line">                    // 在旋转区间中找</span><br><span class="line">                    else &#123;</span><br><span class="line">                        begin = mid + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 后半部分为顺序区间，前半部分为旋转区间</span><br><span class="line">                // 后半部分所有值都大于nums[mid] 即大于target</span><br><span class="line">                // target一定在前半部分</span><br><span class="line">                else &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 目标大于中间值</span><br><span class="line">            else if (target &gt; nums[mid]) &#123;</span><br><span class="line">                // 前半部分为顺序区间，后半部分为旋转区间</span><br><span class="line">                // 前半部分所有值都小于nums[mid] 即小于target</span><br><span class="line">                // target一定在后半部分</span><br><span class="line">                if (nums[begin] &lt; nums[mid]) &#123;</span><br><span class="line">                    begin = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                // 后半部分为顺序区间，前半部分为旋转区间</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 在旋转区间中找</span><br><span class="line">                    // nums[end]是顺序区间中最大元素</span><br><span class="line">                    // 该最大元素都比target小的话</span><br><span class="line">                    // 则直接在旋转区间中找</span><br><span class="line">                    if (nums[end] &lt; target) end = mid - 1;</span><br><span class="line">                    // 否则在该顺序区间中找</span><br><span class="line">                    else &#123;</span><br><span class="line">                        begin = mid + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>插入结点代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void BST_insert(TreeNode* root, TreeNode* insert_node) &#123;</span><br><span class="line">        if (root-&gt;val &gt; insert_node-&gt;val) &#123;</span><br><span class="line">            if (root-&gt;left) BST_insert(root-&gt;left, insert_node);</span><br><span class="line">            else root-&gt;left = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (root-&gt;right) BST_insert(root-&gt;right, insert_node);</span><br><span class="line">            else root-&gt;right = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查找结点代码</p>
<h2 id="一、leetcode-449-序列化和反序列化二叉搜索树"><a href="#一、leetcode-449-序列化和反序列化二叉搜索树" class="headerlink" title="一、leetcode 449 序列化和反序列化二叉搜索树"></a>一、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">leetcode 449 序列化和反序列化二叉搜索树</a></h2><h2 id="二、leetcode-315-计算右侧小于当前元素的个数"><a href="#二、leetcode-315-计算右侧小于当前元素的个数" class="headerlink" title="二、leetcode 315 计算右侧小于当前元素的个数"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">leetcode 315 计算右侧小于当前元素的个数</a></h2><p>在插入的过程中计算小于当前结点值的结点数,不是获取当前结点的count_small值（记录的是整棵树中小于当前结点的值，而不是在插入他之前）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 计算右侧小于当前元素的个数</span><br><span class="line">    // 反转数组</span><br><span class="line">    // 将问题转换为：计算左侧小于当前元素的个数</span><br><span class="line">    // 建立二叉搜索树,在建立的过程中，记录</span><br><span class="line">    struct TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode *left;</span><br><span class="line">        TreeNode *right;</span><br><span class="line">        int count_small;</span><br><span class="line">        TreeNode(int x) : val(x), left(NULL), right(NULL), count_small(0) &#123;&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">    </span><br><span class="line">    void BST_insert(TreeNode* node, TreeNode* insert_node, int &amp; count) &#123;</span><br><span class="line">        if (node-&gt;val &gt;= insert_node-&gt;val) &#123;</span><br><span class="line">            node-&gt;count_small++;</span><br><span class="line">            if (node-&gt;left) BST_insert(node-&gt;left, insert_node, count);</span><br><span class="line">            else node-&gt;left = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            count += node-&gt;count_small + 1;</span><br><span class="line">            if (node-&gt;right) BST_insert(node-&gt;right, insert_node, count);</span><br><span class="line">            else node-&gt;right = insert_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if (nums.size() == 0) return ans;</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        TreeNode* root = new TreeNode(nums[0]);</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            TreeNode * newNode =  new TreeNode(nums[i]);</span><br><span class="line">            int count_small = 0;</span><br><span class="line">            BST_insert(root, newNode, count_small);</span><br><span class="line">            ans.push_back(count_small);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="一、-leetcode-409-最长回文串"><a href="#一、-leetcode-409-最长回文串" class="headerlink" title="一、 leetcode 409 最长回文串"></a>一、 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindrome/">leetcode 409 最长回文串</a></h2><ol>
<li>哈希表存放字符串s中各个不同的字母出现的次数；</li>
<li>遍历哈希表,根据出现次数的偶数/奇数，结合回文串的性质，得出最长回文串。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestPalindrome(string s) &#123;</span><br><span class="line">        map&lt;char, int&gt; mp;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            mp[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;char, int&gt;::iterator it;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        for (it = mp.begin(); it != mp.end(); it++) &#123;</span><br><span class="line">            if (it-&gt;second % 2 == 0) &#123; // 该字母出现次数为偶数次</span><br><span class="line">                sum += it-&gt;second; // 可构成回文</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // 该字母出现次数为奇数次</span><br><span class="line">                if (flag) &#123; // 已存在中间值</span><br><span class="line">                    sum += it-&gt;second - 1; // 除掉中间值外 其他可构成回文</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    sum += it-&gt;second;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、leetcode-290-单词规律"><a href="#二、leetcode-290-单词规律" class="headerlink" title="二、leetcode 290 单词规律"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-pattern/">leetcode 290 单词规律</a></h2><p>分析字符串与模式字母的正确匹配情况与错误情况：</p>
<ol>
<li>map&lt;string, char&gt; mp; // 存储字符串对应的模式字母<br>bool used[128] = {0}; // 标记模式字母是否出现过</li>
<li>模式字母未出现过：当前字符串却曾经出现过，则有字符串对应了多个模式字母，错误；<br>模式字母出现过：当前字符串不曾出现，或者当前字符串不对应相应模式字母，错误；</li>
</ol>
<h2 id="三、leetcode-49-字母异位词分组"><a href="#三、leetcode-49-字母异位词分组" class="headerlink" title="三、leetcode 49 字母异位词分组"></a>三、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">leetcode 49 字母异位词分组</a></h2><ol>
<li>map&lt;string, int&gt; mp; // 哈希表：基础字符串，对应在结果中的索引<br>vector&lt;vector<string> &gt; res; // 结果数组</li>
<li>字符串排序,作为map的key.</li>
</ol>
<h2 id="四、leetcode-3-无重复字符的最长子串"><a href="#四、leetcode-3-无重复字符的最长子串" class="headerlink" title="四、leetcode 3 无重复字符的最长子串"></a>四、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">leetcode 3 无重复字符的最长子串</a></h2><p>滑动窗口法：</p>
<ol>
<li>确定左边界，遍历右边界，数组存储字母在该窗口中是否出现过；</li>
<li>当遍历过程中遇到出现过的字母，则右移左边界，直到找到该字母的位置;</li>
<li>当遍历过程中遇到出现过的字母，更新最大无重复子串长度。<h2 id="五、leetcode-187-重复的DNA序列"><a href="#五、leetcode-187-重复的DNA序列" class="headerlink" title="五、leetcode 187 重复的DNA序列"></a>五、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-dna-sequences/">leetcode 187 重复的DNA序列</a></h2>ACGT四种情况，即二进制两位数可表示这4种不同的字母；<br>不同的DNA序列可转化为对应不同的二进制数;<br>使用哈希表存储出现的次数。<h2 id="六、leetcode-76-最小覆盖子串"><a href="#六、leetcode-76-最小覆盖子串" class="headerlink" title="六、leetcode 76 最小覆盖子串"></a>六、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">leetcode 76 最小覆盖子串</a></h2>滑动窗口法+哈希表:<br>根据条件更新左边界：当前S窗口s_map[begin_str] &lt; T字符串中的t_map[begin_str]；或出现T字符串中没有的字母；<br>遍历右边界，在每次遍历完成后，判断该窗口是否符合要求。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool is_window_ok(int x[], int y[], vector&lt;int&gt; vec) &#123;</span><br><span class="line">        for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            if (x[vec[i]] &gt; y[vec[i]]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        int t_map[128] = &#123;0&#125;; // 记录t字符串中各字母出现的次数</span><br><span class="line">        int s_map[128] = &#123;0&#125;; // 记录s字符串窗口中各字母出现的次数</span><br><span class="line">        vector&lt;int&gt; charvec; // 记录t中出现过的字母</span><br><span class="line">        for (int i = 0; i &lt; t.length(); i++) &#123;</span><br><span class="line">            if (t_map[t[i]] == 0) charvec.push_back(t[i]);</span><br><span class="line">            t_map[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int begini = 0; // 窗口左边界</span><br><span class="line">        int min_len = s.length() + 1; // 结果字符串长度</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        // 遍历右边界</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            s_map[s[i]]++;</span><br><span class="line">            while (begini &lt; i) &#123;</span><br><span class="line">                if (t_map[s[begini]] == 0) &#123; // 窗口首字母在t字符串中不存在</span><br><span class="line">                    begini++;</span><br><span class="line">                &#125;// 窗口首字母在窗口字符串中出现次数&gt;在t字符串出现次数</span><br><span class="line">                else if (s_map[s[begini]] &gt; t_map[s[begini]]) &#123;</span><br><span class="line">                    s_map[s[begini]]--;</span><br><span class="line">                    begini++;</span><br><span class="line">                &#125;</span><br><span class="line">                else break;</span><br><span class="line">            &#125;</span><br><span class="line">            // cout&lt;&lt;s.substr(begini, i - begini + 1)&lt;&lt;endl;</span><br><span class="line">            if (is_window_ok(t_map, s_map, charvec)) &#123;</span><br><span class="line">                int cur_len = i - begini + 1;</span><br><span class="line">                if (res == &quot;&quot; || cur_len &lt; min_len) &#123;</span><br><span class="line">                    min_len = cur_len;</span><br><span class="line">                    res = s.substr(begini, cur_len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="一、-leetcode-78-子集"><a href="#一、-leetcode-78-子集" class="headerlink" title="一、 leetcode 78 子集"></a>一、 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">leetcode 78 子集</a></h2>不考虑递归过程，直接根据结果来实现程序。<br>求子集：</li>
<li>考虑当前元素是否应该加到子集中：加或不加，分别递归；</li>
<li>递归结束条件是：index&gt;=nums.size()。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void generate (int i, vector&lt;int&gt; nums, vector&lt;int&gt; items, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123;</span><br><span class="line">        if (i &gt;= nums.size()) &#123; // 当索引超出nums边界</span><br><span class="line">            res.push_back(items);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        items.push_back(nums[i]); // 当前子集选择nums[i]</span><br><span class="line">        generate (i + 1, nums, items, res); // 进行下一步递归</span><br><span class="line">        items.pop_back(); // 当前子集不选择nums[i]</span><br><span class="line">        generate (i + 1, nums, items, res); // 进行下一步递归</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        vector&lt;int&gt; items;</span><br><span class="line">        generate (0, nums, items, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-90-子集-II"><a href="#二、leetcode-90-子集-II" class="headerlink" title="二、leetcode 90 子集 II"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">leetcode 90 子集 II</a></h2>先对nums排序，使用set&lt;vector<int>&gt;对一致的子集去重。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (res_set.find(items) == res_set.end()) &#123;</span><br><span class="line">                res.push_back(items);</span><br><span class="line">                res_set.insert(items);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、leetcode-40-组合总和-II"><a href="#三、leetcode-40-组合总和-II" class="headerlink" title="三、leetcode 40 组合总和 II"></a>三、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">leetcode 40 组合总和 II</a></h2>典型的递归题：</li>
<li>以开始位置start索引遍历候选数组，当当前索引未加入到路径中，并且加入候选值不会大于target值，则选择该索引位置的值，并进行下一步的递归；</li>
<li>递归结束条件是path值==target值，并且当前path首次出现(排序 set约束)。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 递归函数</span><br><span class="line">    // 候选数组，开始位置，目标数值，结果数组，当前子集</span><br><span class="line">    void backtracking(vector&lt;int&gt; candidates, int start, int target, vector&lt;vector&lt;int&gt; &gt;&amp; res, vector&lt;int&gt;&amp; path, bool help[], set&lt;vector&lt;int&gt; &gt;&amp; res_set) &#123;</span><br><span class="line">        // 达到目标</span><br><span class="line">        if ( target == 0 &amp;&amp; res_set.find(path) == res_set.end()) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            res_set.insert(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt; candidates.size() &amp;&amp; target-candidates[i] &gt;= 0; i++)&#123;</span><br><span class="line">            // 满足条件：当前值未使用 并且 子集和仍然小于target</span><br><span class="line">            if (!help[i] &amp;&amp; target - candidates[i] &gt;= 0) &#123;</span><br><span class="line">                path.push_back(candidates[i]); // 将当前值放入子集中</span><br><span class="line">                help[i] = true;</span><br><span class="line">                backtracking(candidates, i+1, target - candidates[i], res, path, help, res_set);</span><br><span class="line">                path.pop_back(); // 取出该值，进行新一轮选择</span><br><span class="line">                help[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    sort(candidates.begin(),candidates.end()); // 将数组排序</span><br><span class="line">    backtracking(candidates, 0, target, res, path, help, res_set);</span><br><span class="line">    */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四、leetcode-22-括号生成"><a href="#四、leetcode-22-括号生成" class="headerlink" title="四、leetcode 22. 括号生成"></a>四、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">leetcode 22. 括号生成</a></h2>典型递归题：<br>给出n对左右括号的合理摆放顺序。</li>
<li>每一步有2种选择：’(‘或’)’，对两种选择分别进行下一步递归；</li>
<li>递归结束条件为：目标字符串长度到达2*n；</li>
<li>剪枝：去除不必要的递归步骤：只有n个左括号与n个右括号，超出的直接不做处理；左括号数不大于右括号数的，不可再选择’)’。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void generate(string item, int left, int right, vector&lt;string&gt;&amp; res) &#123;</span><br><span class="line">        if (left == 0 &amp;&amp; right == 0) &#123; // 当字符串成功放置n个左括号与n个右括号</span><br><span class="line">            res.push_back(item);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &gt; 0) // 当左括号尚未完成</span><br><span class="line">            generate(item + &#x27;(&#x27;, left - 1, right, res);</span><br><span class="line">        if (left &lt; right) // 当左括号数&gt;右括号数</span><br><span class="line">            generate(item + &#x27;)&#x27;, left, right - 1, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        generate(&quot;&quot;, n, n, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="五、leetcode-51-N皇后"><a href="#五、leetcode-51-N皇后" class="headerlink" title="五、leetcode 51. N皇后"></a>五、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">leetcode 51. N皇后</a></h2>N皇后问题，典型的递归回溯法：<br>关键点在于在递归之前，对当前mark标记数组与location结果状态的保存，以便在回溯阶段对状态进行复原，以进行下一步的递归。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dir[8][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, // 上下左右</span><br><span class="line">                    &#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;; // 左上 右上 左下 右下</span><br><span class="line">    // 在(x,y)位置放置queue</span><br><span class="line">    // 在(x,y)位置的八个方向延伸出去 都标志为-1 表示不可放置queue</span><br><span class="line">    void put_down_the_queue(int x, int y, vector&lt;vector&lt;int&gt; &gt;&amp; mark) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; mark.size(); j++) &#123;</span><br><span class="line">                int index_x = x + dir[i][0] * j;</span><br><span class="line">                int index_y = y + dir[i][1] * j;</span><br><span class="line">                if (index_x &lt; 0 || index_x &gt;= mark.size()) continue;</span><br><span class="line">                if (index_y &lt; 0 || index_y &gt;= mark[0].size()) continue;</span><br><span class="line">                mark[index_x][index_y] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递归函数</span><br><span class="line">    // k：完成k个皇后的放置</span><br><span class="line">    // n：共n个皇后</span><br><span class="line">    // location：当前摆放结果</span><br><span class="line">    // res：最终结果</span><br><span class="line">    // mark：标记数组</span><br><span class="line">    void generate(int k, int n, vector&lt;string&gt;&amp; location, vector&lt;vector&lt;string&gt; &gt;&amp; res, vector&lt;vector&lt;int&gt; &gt;&amp; mark) &#123;</span><br><span class="line">        if (k == n) &#123;</span><br><span class="line">            res.push_back(location);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (mark[k][i] == 0) &#123;</span><br><span class="line">                vector&lt;vector&lt;int&gt; &gt; temp_mark = mark; // 存储当前的mark数组(在递归过程中会改变)</span><br><span class="line">                put_down_the_queue(k, i, mark);</span><br><span class="line">                location[k][i] = &#x27;Q&#x27;;</span><br><span class="line">                generate(k + 1, n, location, res, mark); // 递归</span><br><span class="line">                mark = temp_mark; // 返回原本mark数组</span><br><span class="line">                location[k][i] = &#x27;.&#x27;;  // 返回原本的location</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; res; // 存储最终结果</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; mark; // 标记棋盘是否可以放置皇后的二维数组</span><br><span class="line">        vector&lt;string&gt; location; // 存储某个摆放结果</span><br><span class="line">        // 初始化</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            mark.push_back((vector&lt;int&gt;()));</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                mark[i].push_back(0);</span><br><span class="line">            &#125;</span><br><span class="line">            location.push_back(&quot;&quot;);</span><br><span class="line">            location[i].append(n, &#x27;.&#x27;); // location初始化为n个&quot;.&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        generate(0, n, location, res, mark);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="六、leetcode-315-计算右侧小于当前元素的个数"><a href="#六、leetcode-315-计算右侧小于当前元素的个数" class="headerlink" title="六、leetcode 315 计算右侧小于当前元素的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">六、leetcode 315 计算右侧小于当前元素的个数</a></h2>归并排序思想：<br>在merge两个子数组的同时，更新counts数组：<br>当插入前半部分区间值sub_vec1[x]时，表示后半部分 y之前的所有值都已放置在vec中，<br>则证明y之前都小于sub_vec1[x],因此对应值索引位置更新+y。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge_two_vec(vector&lt;pair&lt;int, int&gt; &gt; sub_vec1, vector&lt;pair&lt;int, int&gt; &gt; sub_vec2, vector&lt;pair&lt;int, int&gt; &gt;&amp; vec, vector&lt;int&gt;&amp; ans) &#123;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        while (x &lt; sub_vec1.size() &amp;&amp; y &lt; sub_vec2.size()) &#123;</span><br><span class="line">            // 此时插入前半部分区间值sub_vec1[x]</span><br><span class="line">            // y之前的所有值都已放置在vec中</span><br><span class="line">            // 证明都小于sub_vec1[x]</span><br><span class="line">            // 因此更新+y</span><br><span class="line">            if (sub_vec1[x].first &lt;= sub_vec2[y].first) &#123;</span><br><span class="line">                ans[sub_vec1[x].second] += y; // 对应索引位置更新</span><br><span class="line">                vec.push_back(sub_vec1[x]);</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 此时插入后半部分区间值sub_vec2[x]</span><br><span class="line">            else &#123;</span><br><span class="line">                vec.push_back(sub_vec2[y]);</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理剩余元素</span><br><span class="line">        while (x &lt; sub_vec1.size()) &#123;</span><br><span class="line">            ans[sub_vec1[x].second] += y; // 对应索引位置更新</span><br><span class="line">            vec.push_back(sub_vec1[x]);</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (y &lt; sub_vec2.size()) &#123;</span><br><span class="line">            vec.push_back(sub_vec2[y]);</span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void merge_sort(vector&lt;pair&lt;int, int&gt; &gt;&amp; vec, vector&lt;int&gt;&amp; ans) &#123;</span><br><span class="line">        if (vec.size() &lt; 2) return; // 当拆分后的数组大小&lt;=1，则直接返回</span><br><span class="line">        // 拆分为2个数组</span><br><span class="line">        int mid = vec.size() / 2;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; sub_vec1;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; sub_vec2;</span><br><span class="line">        for (int i = 0; i &lt; mid; i++) &#123;</span><br><span class="line">            sub_vec1.push_back(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = mid; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            sub_vec2.push_back(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        merge_sort(sub_vec1, ans);</span><br><span class="line">        merge_sort(sub_vec2, ans);</span><br><span class="line">        vec.clear(); // 清空 以存放归并后的数组</span><br><span class="line">        merge_two_vec(sub_vec1, sub_vec2, vec, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if (nums.size() == 0) return ans;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; vec;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            ans.push_back(0); // 初始化结果数组</span><br><span class="line">            vec.push_back(make_pair(nums[i], i)); // 存储nums[i]与对应索引i</span><br><span class="line">        &#125;</span><br><span class="line">        merge_sort(vec, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="一、-leetcode-200-岛屿数量"><a href="#一、-leetcode-200-岛屿数量" class="headerlink" title="一、 leetcode 200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">一、 leetcode 200. 岛屿数量</a></h2>基础DFS解法:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// DFS找到从（x,y）出发连接的&#x27;1&#x27;，即一个岛屿</span><br><span class="line">void DFS(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt; &gt;&amp; seen, int x, int y) &#123;</span><br><span class="line">    seen[x][y] = 1;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int next_x = x + dirs[i][0];</span><br><span class="line">        int next_y = y + dirs[i][1];</span><br><span class="line">        // 超出边界</span><br><span class="line">        if (next_x &lt; 0 || next_x &gt;= grid.size() || next_y &lt; 0 || next_y &gt;= grid[0].size()) </span><br><span class="line">            continue;</span><br><span class="line">        // 已访问过</span><br><span class="line">        if (seen[next_x][next_y]) continue;</span><br><span class="line">        // 是岛屿 继续DFS</span><br><span class="line">        if (grid[next_x][next_y] == &#x27;1&#x27;) &#123;</span><br><span class="line">            DFS(grid, seen, next_x, next_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
基础BFS解法:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// BFS找到从（x,y）出发连接的&#x27;1&#x27;，即一个岛屿</span><br><span class="line">    void BFS(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt; &gt;&amp; seen, int x, int y) &#123;</span><br><span class="line">    queue&lt;pair&lt;int, int&gt; &gt; mq;</span><br><span class="line">    mq.push(make_pair(x, y));</span><br><span class="line">    seen[x][y] = 1; // 入队标志</span><br><span class="line">    while (!mq.empty()) &#123;</span><br><span class="line">        int cur_x = mq.front().first;</span><br><span class="line">        int cur_y = mq.front().second;</span><br><span class="line">        mq.pop();</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int next_x = cur_x + dirs[i][0];</span><br><span class="line">            int next_y = cur_y + dirs[i][1];</span><br><span class="line">            // 超出边界</span><br><span class="line">            if (next_x &lt; 0 || next_x &gt;= grid.size() || next_y &lt; 0 || next_y &gt;= grid[0].size()) </span><br><span class="line">                continue;</span><br><span class="line">            // 是岛屿 继续DFS</span><br><span class="line">            if (!seen[next_x][next_y] &amp;&amp; grid[next_x][next_y] == &#x27;1&#x27;) &#123;</span><br><span class="line">                mq.push(make_pair(next_x, next_y)); // 入队</span><br><span class="line">                seen[next_x][next_y] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-127-单词接龙"><a href="#二、leetcode-127-单词接龙" class="headerlink" title="二、leetcode 127. 单词接龙"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">leetcode 127. 单词接龙</a></h2></li>
<li>建立图关系：差一个字母的单词有关系；</li>
<li>BFS<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 建立单词间关系图：相差一个字母的单词为一组</span><br><span class="line">    void construct_graph(map&lt;string, vector&lt;string&gt; &gt;&amp; graph, vector&lt;string&gt;&amp; wordList, int len) &#123;</span><br><span class="line">        // 初始化graph</span><br><span class="line">        for (int i = 0; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                string temp = wordList[i];</span><br><span class="line">                temp[j] = &#x27;*&#x27;; // 替换为‘*’,作为key</span><br><span class="line">                if (graph.count(temp) == 0) &#123;</span><br><span class="line">                    vector&lt;string&gt; vec;</span><br><span class="line">                    vec.push_back(wordList[i]);</span><br><span class="line">                    graph[temp] = vec;</span><br><span class="line">                &#125;</span><br><span class="line">                else graph[temp].push_back(wordList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        int len = beginWord.length();</span><br><span class="line">        map&lt;string, vector&lt;string&gt; &gt; graph; // 单词，相差一个字母的其他单词表</span><br><span class="line">        wordList.push_back(beginWord); // 也需考虑beginWord</span><br><span class="line">        construct_graph(graph, wordList, len);</span><br><span class="line">        // 进行BFS</span><br><span class="line">        queue&lt;pair&lt;string, int&gt; &gt; q; // 队列(单词，当前步数)</span><br><span class="line">        set&lt;string&gt; visit; // 是否访问过</span><br><span class="line">        q.push(make_pair(beginWord, 1));</span><br><span class="line">        visit.insert(beginWord);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            string cur_s = q.front().first;</span><br><span class="line">            int cur_step = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            if (cur_s == endWord) &#123;</span><br><span class="line">                return cur_step;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123; // 替换每个字母为&#x27;*&#x27;, 都存在路径</span><br><span class="line">                string temp_s = cur_s;</span><br><span class="line">                temp_s[i] = &#x27;*&#x27;;</span><br><span class="line">                vector&lt;string&gt; neighbors = graph[temp_s];</span><br><span class="line">                for (int j = 0; j &lt; neighbors.size(); j++) &#123;</span><br><span class="line">                    if (visit.find(neighbors[j]) == visit.end()) &#123;</span><br><span class="line">                        q.push(make_pair(neighbors[j], cur_step + 1));</span><br><span class="line">                        visit.insert(neighbors[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="升级leetcode-126-单词接龙-II"><a href="#升级leetcode-126-单词接龙-II" class="headerlink" title="升级leetcode 126. 单词接龙 II"></a>升级<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/">leetcode 126. 单词接龙 II</a></h3>记录单词接龙的路径：</li>
<li>使用vector<Qitem>作为BFS数组，建立Qitem数据结构，同时存储(word, step, parent_pos);</li>
<li>map&lt;string, int&gt; visit 记录到某单词的最短路径;</li>
</ol>
<h2 id="三、leetcode-473-火柴拼正方形"><a href="#三、leetcode-473-火柴拼正方形" class="headerlink" title="三、leetcode 473. 火柴拼正方形"></a>三、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/matchsticks-to-square/">leetcode 473. 火柴拼正方形</a></h2><p>DFS会超时，可使用二进制法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() &lt; 4) return false; // 个数不足4</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 4 != 0) return false; // 和不为4的倍数</span><br><span class="line">        int target = sum / 4;</span><br><span class="line">        vector&lt;int&gt; ok_subset;</span><br><span class="line">        vector&lt;int&gt; ok_half;</span><br><span class="line">        int all = 1 &lt;&lt; nums.size();</span><br><span class="line">        for (int i = 0; i &lt; all; i++) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = 0; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                if (i &amp; (1 &lt;&lt; j)) &#123; // i代表的集合中存在第j个元素</span><br><span class="line">                    sum += nums[j]; // 求该集合的和</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sum == target) ok_subset.push_back(i); // 和 = target，保存i集合</span><br><span class="line">        &#125;</span><br><span class="line">        // 使4条边两两结合</span><br><span class="line">        for (int i = 0; i &lt; ok_subset.size(); i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; ok_subset.size(); j++) &#123;</span><br><span class="line">                if ((ok_subset[i] &amp; ok_subset[j]) == 0) &#123; // 子集中存在的值不重合</span><br><span class="line">                    ok_half.push_back((ok_subset[i] | ok_subset[j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 使两部分两两结合 组成正方形</span><br><span class="line">        for (int i = 0; i &lt; ok_half.size(); i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; ok_half.size(); j++) &#123;</span><br><span class="line">                if ((ok_half[i] &amp; ok_half[j]) == 0) &#123; // 子集中存在的值不重合</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="一、leetcode-70-爬楼梯"><a href="#一、leetcode-70-爬楼梯" class="headerlink" title="一、leetcode 70. 爬楼梯"></a>一、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">leetcode 70. 爬楼梯</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        // dp状态数组：dp[i]表示到达i级阶梯有多少方法</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        // 初始化</span><br><span class="line">        dp[0] = 1; // 爬一个台阶</span><br><span class="line">        dp[1] = 2; // 爬2个台阶或分别爬1个台阶</span><br><span class="line">        // 状态转移</span><br><span class="line">        // dp[i]的值为dp[i - 1]再爬1个 + dp[i - 2]爬2个</span><br><span class="line">        for (int i = 2; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - 2] + dp[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-198-打家劫舍"><a href="#二、leetcode-198-打家劫舍" class="headerlink" title="二、leetcode 198. 打家劫舍"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">leetcode 198. 打家劫舍</a></h2><p>dp[i]表示 <strong>[0, i]范围内</strong>的最高金额;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return 0;</span><br><span class="line">        if (nums.size() == 1) return nums[0];</span><br><span class="line">        // dp状态数组</span><br><span class="line">        // dp[i]表示[0, i]的最高金额</span><br><span class="line">        vector&lt;int&gt; dp(nums.size());</span><br><span class="line">        // 初始化</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        // 状态转移</span><br><span class="line">        // i-1被偷，则不能偷i</span><br><span class="line">        // i-2被偷，可以偷i</span><br><span class="line">        for (int i = 2; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[nums.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三-leetcode-53-最大子序和"><a href="#三-leetcode-53-最大子序和" class="headerlink" title="三 leetcode 53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">三 leetcode 53. 最大子序和</a></h2><p>dp[i]:<strong>以nums[i]为结尾</strong>的最大子序和;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return 0;</span><br><span class="line">        // dp状态数组</span><br><span class="line">        // dp[i]:以nums[i]为结尾的最大子序和</span><br><span class="line">        vector&lt;int&gt; dp(nums.size());</span><br><span class="line">        // 初始化</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int res = dp[0];</span><br><span class="line">        // 状态转移</span><br><span class="line">        // dp[i]的值是以i-1为结尾的最大子序和+当前nums[i] 或者 以当前nums[i]开头</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 1] + nums[i], nums[i]);</span><br><span class="line">            if (res &lt; dp[i]) &#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四、leetcode-322-零钱兑换"><a href="#四、leetcode-322-零钱兑换" class="headerlink" title="四、leetcode 322. 零钱兑换"></a>四、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">leetcode 322. 零钱兑换</a></h2><p>dp[i]:i元时需要的最少硬币数</p>
<h2 id="五、120-三角形最小路径和"><a href="#五、120-三角形最小路径和" class="headerlink" title="五、120. 三角形最小路径和"></a>五、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h2><p><strong>自底向上</strong>；<br>triangle直接作为状态数组，triangle[i][j]表示从底部到当前位置的最短路径长度；<br>状态转移方程为triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);<br>最终结果为triangle[0][0].</p>
<h2 id="六、300-最长上升子序列"><a href="#六、300-最长上升子序列" class="headerlink" title="六、300. 最长上升子序列"></a>六、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></h2><p>dp[i]:<strong>以nums[i]为结尾</strong>的最长上升子序列，结尾需要遍历dp，得出最大长度.</p>
<h2 id="七、64-最小路径和"><a href="#七、64-最小路径和" class="headerlink" title="七、64. 最小路径和"></a>七、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h2><p><strong>自底向上</strong>；<br>grid[i][j]只可能从右侧或者下方回来，<br>状态转移方程：grid[i][j] += min(grid[i][j + 1], grid[i + 1][j]);</p>
<h2 id="八、leetcode-174-地下城游戏"><a href="#八、leetcode-174-地下城游戏" class="headerlink" title="八、leetcode 174. 地下城游戏"></a>八、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dungeon-game/">leetcode 174. 地下城游戏</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;</span><br><span class="line">        int m = dungeon.size();</span><br><span class="line">        if (m == 0) return 0;</span><br><span class="line">        int n = dungeon[0].size();</span><br><span class="line">        // dp[i][j]：从该位置到P 所需的初始点数</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));</span><br><span class="line">        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);</span><br><span class="line">        // 初始化</span><br><span class="line">        // 最后一列</span><br><span class="line">        for (int i = m - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 当后一个所需血量可以被当前房间内抵消时，初始血量设置为1</span><br><span class="line">            // 否则计算出相差血量，作为该位置的初始血量(dp[i][n - 1])</span><br><span class="line">            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后一行</span><br><span class="line">        for (int j = n - 2; j &gt;= 0; j--) &#123;</span><br><span class="line">            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = m - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = n - 2; j &gt;= 0; j--) &#123;</span><br><span class="line">                int dp_min = min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">                dp[i][j] = max(1, dp_min - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Trie树-字典树"><a href="#Trie树-字典树" class="headerlink" title="Trie树(字典树)"></a>Trie树(字典树)</h1><p>模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># define TRIE_MAX_CHAR_NUM 26</span><br><span class="line">struct TrieNode &#123;</span><br><span class="line">    TrieNode * child[TRIE_MAX_CHAR_NUM]; // 孩子数组 后续26个字母</span><br><span class="line">    bool is_end; // 单词结束标志</span><br><span class="line">    TrieNode(): is_end(false) &#123; // 构造函数 初始化</span><br><span class="line">        for (int i = 0; i &lt; TRIE_MAX_CHAR_NUM; i++) &#123;</span><br><span class="line">            child[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class TrieTree &#123;</span><br><span class="line">private:</span><br><span class="line">    TrieNode _root;</span><br><span class="line">    vector&lt;TrieNode *&gt; _node_vec; // 为了析构</span><br><span class="line">    TrieNode * new_node() &#123;</span><br><span class="line">        TrieNode * node = new TrieNode();</span><br><span class="line">        _node_vec.push_back(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TrieTree() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~TrieTree() &#123;</span><br><span class="line">        for (int i = 0; i &lt; _node_Vec.size(); i++) &#123;</span><br><span class="line">            delete _node_vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入一个单词</span><br><span class="line">    void insert(const char *word) &#123;</span><br><span class="line">        TrieNode *ptr = &amp;_root; // 获取Trie树根节点</span><br><span class="line">        while (*word) &#123; // 直到到达单词尾部</span><br><span class="line">            int pos = *word - &#x27;a&#x27;;</span><br><span class="line">            if (!ptr-&gt;child[pos]) &#123; // 空 新建</span><br><span class="line">                ptr-&gt;child[pos] = new_node();</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;child[pos]; // 到达子节点位置</span><br><span class="line">            word++; // word位置递增</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;is_end = true; // 标记单词结束</span><br><span class="line">    &#125;</span><br><span class="line">    // 搜索单词是否存在</span><br><span class="line">    bool search(const char *word) &#123;</span><br><span class="line">        TrieNode* ptr = &amp;_root;</span><br><span class="line">        while (*word) &#123;</span><br><span class="line">            if (!ptr-&gt;child[*word - &#x27;a&#x27;]) return false;</span><br><span class="line">            ptr = ptr-&gt;child[*word - &#x27;a&#x27;];</span><br><span class="line">            word++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ptr-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断是否存在该前缀</span><br><span class="line">    bool startsWith(const char *prefix) &#123;</span><br><span class="line">        TrieNode* ptr = &amp;_root;</span><br><span class="line">        while (*prefix) &#123;</span><br><span class="line">            if (!ptr-&gt;child[*prefix - &#x27;a&#x27;]) return false;</span><br><span class="line">            ptr = ptr-&gt;child[*prefix - &#x27;a&#x27;];</span><br><span class="line">            prefix++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、leetcode-208-实现-Trie-前缀树"><a href="#一、leetcode-208-实现-Trie-前缀树" class="headerlink" title="一、leetcode 208. 实现 Trie (前缀树)"></a>一、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">leetcode 208. 实现 Trie (前缀树)</a></h2><p>经典insert、search、startswith</p>
<h2 id="二、leetcode-211-添加与搜索单词-数据结构设计"><a href="#二、leetcode-211-添加与搜索单词-数据结构设计" class="headerlink" title="二、leetcode 211. 添加与搜索单词 - 数据结构设计"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">leetcode 211. 添加与搜索单词 - 数据结构设计</a></h2><p>DFS查找带有“.”的字符串在字典树中是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool dfs_search(TrieNode* ptr, string word, int i) &#123;</span><br><span class="line">        if (i &gt;= word.length()) &#123;</span><br><span class="line">            if (ptr-&gt;is_end) return true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (word[i] != &#x27;.&#x27;) &#123;  </span><br><span class="line">            if (ptr-&gt;child[word[i] - &#x27;a&#x27;]) &#123; // 匹配并且下一步为true</span><br><span class="line">                if (dfs_search(ptr-&gt;child[word[i] - &#x27;a&#x27;], word, i + 1)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 点字符 可匹配任意后续字母</span><br><span class="line">            // 遍历后续字母 dfs</span><br><span class="line">            for (int j = 0; j &lt; TRIE_MAX_CHAR_NUM; j++) &#123;</span><br><span class="line">                if (ptr-&gt;child[j]) &#123;  // 每一个可能的后续字符</span><br><span class="line">                    if (dfs_search(ptr-&gt;child[j], word, i + 1)) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="一、leetcode-547-朋友圈"><a href="#一、leetcode-547-朋友圈" class="headerlink" title="一、leetcode 547. 朋友圈"></a>一、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friend-circles/">leetcode 547. 朋友圈</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; friends;</span><br><span class="line">    vector&lt;int&gt; _size; // 各子树规模</span><br><span class="line">    int findfather(int x) &#123;</span><br><span class="line">        while (friends[x] != x) &#123;</span><br><span class="line">            friends[x] = friends[friends[x]]; // 路径压缩</span><br><span class="line">            x = friends[x];</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    void union_two(int a, int b) &#123;</span><br><span class="line">        int a_father = findfather(a);</span><br><span class="line">        int b_father = findfather(b);</span><br><span class="line">        if (a_father == b_father) return;</span><br><span class="line">        if (_size[a_father] &lt; _size[b_father]) &#123; // 小的向大的合并 以减小查询复杂度</span><br><span class="line">            friends[a_father] = b_father;</span><br><span class="line">            _size[b_father] += _size[a_father];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            friends[b_father] = a_father;</span><br><span class="line">            _size[a_father] += _size[b_father];</span><br><span class="line">        &#125;</span><br><span class="line">        /*for (int i = 0; i &lt; friends.size(); i++) &#123; // 更新所有以b_father为父母的friends值</span><br><span class="line">            if (friends[i] == b_father) &#123;</span><br><span class="line">                friends[i] = a_father; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line">    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123;</span><br><span class="line">        int n = M.size();</span><br><span class="line">        // 并查集初始化</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            friends.push_back(i);</span><br><span class="line">            _size.push_back(1); // 本身大小1</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (M[i][j]) &#123;</span><br><span class="line">                    union_two(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找不同father总数</span><br><span class="line">        map&lt;int, int&gt; mp;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (mp.find(findfather(friends[i])) == mp.end()) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                mp[findfather(friends[i])] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/seg/#_4">参考链接</a></p>
<h2 id="leetcode-307-区域和检索-数组可修改"><a href="#leetcode-307-区域和检索-数组可修改" class="headerlink" title="leetcode 307. 区域和检索 - 数组可修改"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-mutable/">leetcode 307. 区域和检索 - 数组可修改</a></h2><p>求数组区间和：建立/更新/查询线段树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class NumArray &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; _values; // 线段树数组</span><br><span class="line">    int _right_end; // 保存右边界</span><br><span class="line">public:</span><br><span class="line">    /// 构建线段树</span><br><span class="line">    // value：线段树数组(存储区间和)</span><br><span class="line">    // nums：用来构建线段树的数组(已知)</span><br><span class="line">    // pos：在线段树数组value中的当前位置</span><br><span class="line">    // left,right：nums数组中的区间左右边界</span><br><span class="line">    void build_segment_tree(vector&lt;int&gt;&amp; value, vector&lt;int&gt;&amp; nums, int pos, int left, int right) &#123;</span><br><span class="line">        if (left == right) &#123;</span><br><span class="line">            value[pos] = nums[left];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        build_segment_tree(value, nums, 2 * pos + 1, left, mid); // 构建左子树</span><br><span class="line">        build_segment_tree(value, nums, 2 * pos + 2, mid + 1, right); // 构建右子树</span><br><span class="line">        value[pos] = value[2 * pos + 1] + value[2 * pos + 2]; // 合并</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 线段树求和</span><br><span class="line">    // value:线段树数组</span><br><span class="line">    // pos：在value中的下标位置</span><br><span class="line">    // left,right：nums数组的当前区间范围</span><br><span class="line">    // qleft,qright：待查询区间</span><br><span class="line">    // [left,right]因递归不断在缩小，[qleft,qright]不变</span><br><span class="line">    int sum_range_segment_tree(vector&lt;int&gt;&amp; value, int pos, int left, int right, int qleft, int qright) &#123;</span><br><span class="line">        if (qleft &gt; right || qright &lt; left) &#123; // 区间不相交</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (qleft &lt;= left &amp;&amp; qright &gt;= right) &#123; // 区间有重叠部分</span><br><span class="line">            return value[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        return sum_range_segment_tree(value, 2 * pos + 1, left, mid, qleft, qright) + sum_range_segment_tree(value, 2 * pos + 2, mid + 1, right, qleft, qright);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    /// 线段树更新</span><br><span class="line">    // value:线段树数组</span><br><span class="line">    // pos：在value中的下标位置</span><br><span class="line">    // left,right：nums数组的当前区间范围</span><br><span class="line">    // index：nums更新的下标值</span><br><span class="line">    // new_val</span><br><span class="line">    void updata_segment_tree(vector&lt;int&gt;&amp; value, int pos, int left, int right, int index, int new_value) &#123;</span><br><span class="line">        if (index == left &amp;&amp; index == right) &#123; // 当前区间为待更新点</span><br><span class="line">            value[pos] = new_value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (mid &gt;= index) updata_segment_tree(value, 2 * pos + 1, left, mid, index, new_value);</span><br><span class="line">        else updata_segment_tree(value, 2 * pos + 2, mid + 1, right, index, new_value);</span><br><span class="line">        value[pos] = value[2 * pos + 1] + value[2 * pos + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return;</span><br><span class="line">        int n = nums.size() * 4; // 一般线段树大小是原数组大小长度的4倍</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            _values.push_back(0);</span><br><span class="line">        &#125;</span><br><span class="line">        _right_end = nums.size() - 1;</span><br><span class="line">        build_segment_tree(_values, nums, 0, 0, _right_end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void update(int i, int val) &#123;</span><br><span class="line">        updata_segment_tree(_values, 0, 0, _right_end, i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sumRange(int i, int j) &#123;</span><br><span class="line">        return sum_range_segment_tree(_values, 0, 0, _right_end, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your NumArray object will be instantiated and called as such:</span><br><span class="line"> * NumArray* obj = new NumArray(nums);</span><br><span class="line"> * obj-&gt;update(i,val);</span><br><span class="line"> * int param_2 = obj-&gt;sumRange(i,j);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-1157-子数组中占绝大多数的元素"><a href="#二、leetcode-1157-子数组中占绝大多数的元素" class="headerlink" title="二、leetcode 1157. 子数组中占绝大多数的元素"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/online-majority-element-in-subarray/">leetcode 1157. 子数组中占绝大多数的元素</a></h2><p>线段树中存储 在当前区间中，通过打擂法胜出的值；<br>在query过程中，找到查询区间中，出现次数最多的值x；<br>哈希表indices_map存储值与对应的索引数组；<br>在索引数组中找到在[left, right]区间内的个数，判断是否符合要求即可。</p>
<h2 id="三、leetcode-218-天际线问题"><a href="#三、leetcode-218-天际线问题" class="headerlink" title="三、leetcode 218. 天际线问题"></a>三、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-skyline-problem/">leetcode 218. 天际线问题</a></h2><p>tree线段树数组存储 离散化x值数组各区间内的高度最大值;<br>使用懒下传。</p>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>在每一步做出在当前来看的最优选择。</p>
<h2 id="一、leetcode-455-分发饼干"><a href="#一、leetcode-455-分发饼干" class="headerlink" title="一、leetcode 455. 分发饼干"></a>一、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">leetcode 455. 分发饼干</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // g:需求因子数组</span><br><span class="line">    // s:糖果数组</span><br><span class="line">    // 贪心思想：用最小的饼干量满足需求</span><br><span class="line">    // 双指针：child cookie</span><br><span class="line">    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        int child = 0, cookie = 0;</span><br><span class="line">        while (child &lt; g.size() &amp;&amp; cookie &lt; s.size()) &#123;</span><br><span class="line">            if (g[child] &lt;= s[cookie]) &#123; // 当前饼干量满足孩子需求</span><br><span class="line">                child++;</span><br><span class="line">                cookie++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前饼干量无法满足孩子需求 则也无法满足后续孩子需求</span><br><span class="line">            // 是个废饼干</span><br><span class="line">            else &#123;</span><br><span class="line">                cookie++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、leetcode-376-摆动序列"><a href="#二、leetcode-376-摆动序列" class="headerlink" title="二、leetcode 376. 摆动序列"></a>二、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">leetcode 376. 摆动序列</a></h2><p>状态机 + 贪心：从左到右的遍历过程中，若持续下降/上升，选取最右边界作为摆动序列的一部分，以使摆动序列最长；</p>
<h2 id="三、leetcode-402-移掉K位数字"><a href="#三、leetcode-402-移掉K位数字" class="headerlink" title="三、leetcode 402. 移掉K位数字"></a>三、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-k-digits/">leetcode 402. 移掉K位数字</a></h2><p>栈 + 贪心：从左到右遍历（高位到低位）,如果对应数字大于下一位数字，则应该把该数字去掉，以取得最小数</p>
<h2 id="四、leetcode-55-跳跃游戏"><a href="#四、leetcode-55-跳跃游戏" class="headerlink" title="四、leetcode 55. 跳跃游戏"></a>四、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">leetcode 55. 跳跃游戏</a></h2><p>当前位置cur_pos,当前可以到达的范围nums[cur_pos] + cur_pos,找到该范围中可以到达最远位置的下标值，作为跳跃目标。<br>升级题:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-ii/">leetcode 45. 跳跃游戏 II</a></p>
<h2 id="五、leetcode-452-用最少数量的箭引爆气球"><a href="#五、leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="五、leetcode 452. 用最少数量的箭引爆气球"></a>五、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">leetcode 452. 用最少数量的箭引爆气球</a></h2><h2 id="六、leetcode-871-最低加油次数"><a href="#六、leetcode-871-最低加油次数" class="headerlink" title="六、leetcode 871. 最低加油次数"></a>六、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/">leetcode 871. 最低加油次数</a></h2><p>贪心+最大堆（有点跳跃游戏的思想：你尽管走，不够了就加）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 贪心：在不得不加的时候加最多的油，使加油次数最少</span><br><span class="line">    // station:0:距离起点的位置；1:油站所拥有的油量</span><br><span class="line">    int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; Q; // 存储油量的最大堆</span><br><span class="line">        int res = 0; </span><br><span class="line">        vector&lt;int&gt; temp(2);</span><br><span class="line">        temp[0] = 0;</span><br><span class="line">        temp[1] = startFuel;</span><br><span class="line">        stations.push_back(temp);</span><br><span class="line">        temp[0] = target;</span><br><span class="line">        temp[1] = 0;</span><br><span class="line">        stations.push_back(temp);</span><br><span class="line">        sort(stations.begin(), stations.end()); // 从起点到终点</span><br><span class="line">        int fuel = startFuel;</span><br><span class="line">        for (int i = 1; i &lt; stations.size(); i++) &#123;</span><br><span class="line">            int dis = stations[i][0] - stations[i - 1][0]; // 此次需要走的距离</span><br><span class="line">            while (!Q.empty() &amp;&amp; fuel &lt; dis) &#123; // 当前油量无法满足 则从最大堆中选取最大油量来加</span><br><span class="line">                fuel += Q.top();</span><br><span class="line">                Q.pop();</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Q.empty() &amp;&amp; fuel &lt; dis) return -1; // 加满油也无法前进dis</span><br><span class="line">            fuel -= dis;</span><br><span class="line">            Q.push(stations[i][1]); // 将油量放入最大堆</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode 122 买卖股票的最佳时机 II</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/boats-to-save-people/">leetcode 881 救生艇</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicate-letters/">leetcode 316. 去除重复字母</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">leetcode 435. 无重叠区间</a><br>贪心(区间调度):优先选择end小的(首先根据end升序排序)，使剩下的区间最多，则移除区间最少，与452类似.<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/">leetcode 659. 分割数组为连续子序列</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">leetcode 861. 翻转矩阵后的得分</a><br>（难）321/330/757</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/01/2020%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" data-id="ckxpsvc420012dowb4zmd0qd3" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2020/09/09/%E5%B0%8F%E7%82%B9/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      小点
      
    </div>
  </a>
  
  
  <a href="/2020/05/07/%E9%9D%A2%E7%BB%8F/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">面经</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Cecyci &copy; 2021</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Cecyci"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>