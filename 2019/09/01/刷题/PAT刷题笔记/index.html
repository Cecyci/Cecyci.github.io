<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="前端 Python 机器学习">
  
  
  <meta name="description" content="2021.12.28建的博客 看看我能坚持多久">
  
  <title>
    PAT刷题笔记 |
    
    Cecyci
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-刷题/PAT刷题笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  PAT刷题笔记
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2019/09/01/%E5%88%B7%E9%A2%98/PAT%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-09-01T10:15:14.000Z" itemprop="datePublished">2019-09-01</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h2 id="1001-Public-Bike-Management"><a href="#1001-Public-Bike-Management" class="headerlink" title="1001:Public Bike Management"></a>1001:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4324">Public Bike Management</a></h2><p>题目大意：自行车数量管理，有一问题站点，解决问题求路径最短，并且让图中每一个站点的自行车数量都为c/2，outbikes最小，inbikes最小；</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**************************</span><br><span class="line">*  Public Bike Management </span><br><span class="line">总体思路：</span><br><span class="line">深搜可以求出两点间的所有可达路径</span><br><span class="line">只要在找到可行路径时判断当前路径是否是更优路径即可。注意回溯*</span><br><span class="line">**************************/</span><br><span class="line"></span><br><span class="line">int c,n,s,m;//最大承载bike量&lt;=100</span><br><span class="line">            //站点数&lt;=500</span><br><span class="line">            //问题站点</span><br><span class="line">            //路径数</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; edge;//存放路径（注意空格）</span><br><span class="line">vector&lt;bool&gt;vis;//访问标记</span><br><span class="line">vector&lt;int&gt;bikes;//各站点bike数量</span><br><span class="line">vector&lt;int&gt;path,res_path;</span><br><span class="line">int cost=2,res_inbikes,res_outbikes,res_len=0;</span><br><span class="line">int res_cost=99999999;</span><br><span class="line">//使用vector防止内存溢出</span><br><span class="line"></span><br><span class="line">void DFS(int e,int index)</span><br><span class="line">&#123;</span><br><span class="line">    //到达终点，判断该路径是否最优</span><br><span class="line">    if(index==e)&#123;</span><br><span class="line">        //计算in/outbikes</span><br><span class="line">        int in=0,out=0;</span><br><span class="line">       /* for(int i=0;i&lt;path.size();i++)&#123;</span><br><span class="line">            cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;*/</span><br><span class="line">        for(int i=0;i&lt;path.size();i++)&#123;</span><br><span class="line">            if(bikes[path[i]]&gt;=c/2)&#123;</span><br><span class="line">                in+=bikes[path[i]]-c/2;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if((c/2-bikes[path[i]])&lt;=in)&#123;//bug1</span><br><span class="line">                    in-=(c/2-bikes[path[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    out+=(c/2-bikes[path[i]])-in;</span><br><span class="line">                   // cout&lt;&lt;in&lt;&lt;&quot; &quot;&lt;&lt;out&lt;&lt;endl;</span><br><span class="line">                    in=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //比较</span><br><span class="line">        if(cost!=res_cost)&#123;</span><br><span class="line">            if(cost&lt;res_cost)&#123;</span><br><span class="line">                res_cost=cost;</span><br><span class="line">                res_inbikes=in;</span><br><span class="line">                res_outbikes=out;</span><br><span class="line">                res_path=path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(out!=res_outbikes)&#123;</span><br><span class="line">                if(out&lt;res_outbikes)&#123;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_inbikes=in;</span><br><span class="line">                    res_outbikes=out;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(in&lt;res_inbikes)&#123;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_inbikes=in;</span><br><span class="line">                    res_outbikes=out;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(edge[index][i]!=0&amp;&amp;!vis[i])&#123;</span><br><span class="line">                vis[i]=1;</span><br><span class="line">                cost+=edge[index][i];</span><br><span class="line">                path.push_back(i);</span><br><span class="line">                DFS(e,i);</span><br><span class="line">                vis[i]=0;</span><br><span class="line">                cost-=edge[index][i];</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;c&gt;&gt;n&gt;&gt;s&gt;&gt;m;</span><br><span class="line">    bikes.resize(n+1,0);</span><br><span class="line">    vis.resize(n+1,0);</span><br><span class="line">    edge.resize(n+1,vector&lt;int&gt;(n+1,0));</span><br><span class="line">    int si,sj,t;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;bikes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;si&gt;&gt;sj&gt;&gt;t;</span><br><span class="line">        edge[si][sj]=t;</span><br><span class="line">        edge[sj][si]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[0]=1;</span><br><span class="line">    DFS(s,0);</span><br><span class="line">    cout&lt;&lt;res_outbikes&lt;&lt;&quot; 0&quot;;</span><br><span class="line">    for(int i=0;i&lt;res_path.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;res_path[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot; &quot;&lt;&lt;res_inbikes&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1002-All-Roads-Lead-to-Rome"><a href="#1002-All-Roads-Lead-to-Rome" class="headerlink" title="1002:All Roads Lead to Rome"></a>1002:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4315">All Roads Lead to Rome</a></h2><p>和前面一题一样的思路，图的DFS确定所有可以到目的地的路线，按照一定规则选取最优路径，并存储；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,k;//城市数，路径数</span><br><span class="line">string start_city;</span><br><span class="line"></span><br><span class="line">map&lt;string,int&gt; mapcity;//记录城市信息</span><br><span class="line">map&lt;int,string&gt; mapcity2;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; roads;//记录路径</span><br><span class="line">vector&lt;int&gt; happiness;//记录幸福</span><br><span class="line">vector&lt;bool&gt; vis;</span><br><span class="line">vector&lt;int&gt;path,res_path;</span><br><span class="line">int cost=0,res_cost=999999999,res_hsum=0,res_havg=0,roadnum=0;</span><br><span class="line">int nowh_sum=0,nowh_avg=0;</span><br><span class="line"></span><br><span class="line">void DFS(int index,int e)</span><br><span class="line">&#123;</span><br><span class="line">    //走到罗马了</span><br><span class="line">    if(index==e)&#123;</span><br><span class="line">        nowh_avg=nowh_sum/(path.size()-1);</span><br><span class="line">        //判断cost与幸福总值与均值</span><br><span class="line">        if(cost!=res_cost)&#123;</span><br><span class="line">            if(cost&lt;res_cost)&#123;</span><br><span class="line">                res_path=path;</span><br><span class="line">                res_cost=cost;</span><br><span class="line">                res_hsum=nowh_sum;</span><br><span class="line">                res_havg=nowh_avg;</span><br><span class="line">                roadnum=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            roadnum++;</span><br><span class="line">            if(nowh_sum!=res_hsum)&#123;</span><br><span class="line">                if(nowh_sum&gt;res_hsum)&#123;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_hsum=nowh_sum;</span><br><span class="line">                    res_havg=nowh_avg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if(nowh_avg&gt;res_havg)&#123;</span><br><span class="line">                    res_path=path;</span><br><span class="line">                    res_cost=cost;</span><br><span class="line">                    res_hsum=nowh_sum;</span><br><span class="line">                    res_havg=nowh_avg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            if(roads[index][i]!=0&amp;&amp;!vis[i])&#123;</span><br><span class="line">                vis[i]=1;</span><br><span class="line">                path.push_back(i);</span><br><span class="line">                cost+=roads[index][i];</span><br><span class="line">                nowh_sum+=happiness[i];</span><br><span class="line">                DFS(i,e);</span><br><span class="line">                vis[i]=0;</span><br><span class="line">                path.pop_back();</span><br><span class="line">                cost-=roads[index][i];</span><br><span class="line">                nowh_sum-=happiness[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;start_city;</span><br><span class="line">    string cityname;</span><br><span class="line">    int h,end_index=0;</span><br><span class="line"></span><br><span class="line">    vis.resize(n,0);</span><br><span class="line">    roads.resize(n,vector&lt;int&gt;(n,0));</span><br><span class="line">    happiness.resize(n,0);</span><br><span class="line"></span><br><span class="line">    mapcity[start_city]=0;</span><br><span class="line">    mapcity2[0]=start_city;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;cityname&gt;&gt;h;</span><br><span class="line">        if(cityname==&quot;ROM&quot;)end_index=i;</span><br><span class="line">        mapcity[cityname]=i;</span><br><span class="line">        happiness[i]=h;</span><br><span class="line">        mapcity2[i]=cityname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string city1,city2;</span><br><span class="line">    int cost;</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;city1&gt;&gt;city2&gt;&gt;cost;</span><br><span class="line">        int x=mapcity[city1];</span><br><span class="line">        int y=mapcity[city2];</span><br><span class="line">        roads[x][y]=cost;</span><br><span class="line">        roads[y][x]=cost;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[0]=1;</span><br><span class="line">    path.push_back(0);</span><br><span class="line">    DFS(0,end_index);</span><br><span class="line">    cout&lt;&lt;roadnum&lt;&lt;&quot; &quot;&lt;&lt;res_cost&lt;&lt;&quot; &quot;&lt;&lt;res_hsum&lt;&lt;&quot; &quot;&lt;&lt;res_havg&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i &lt; res_path.size();i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line">        cout&lt;&lt;mapcity2[res_path[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1003：Highest-Price-in-Supply-Chain"><a href="#1003：Highest-Price-in-Supply-Chain" class="headerlink" title="1003：Highest Price in Supply Chain"></a>1003：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4316">Highest Price in Supply Chain</a></h2><p>刚开始没有理解题意，题意是分别输入以0-N-1为下标的父母结点的下标；<br>解题思路：按照输入建树，求层数；<br>使用一个向量数组存放当前结点的子节点：vector<int> tree[100010];用树的DFS求层数；<br>注意树的DFS不需要vis标记访问，因为从根节点到达某一结点有且只有一条路径；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; tree[100010];</span><br><span class="line">int N;</span><br><span class="line">double P,r;</span><br><span class="line">int root;//记录根节点位置</span><br><span class="line">int routes=0,maxdepth=0;</span><br><span class="line"></span><br><span class="line">void dfs(int index,int step)</span><br><span class="line">&#123;</span><br><span class="line">    if(tree[index].size()==0)&#123;//到达树的子结点</span><br><span class="line">        if(step&gt;maxdepth)&#123;</span><br><span class="line">            maxdepth=step;</span><br><span class="line">            routes=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(step==maxdepth)routes++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;tree[index].size();i++)&#123;</span><br><span class="line">        dfs(tree[index][i],step+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%lf%lf&quot;,&amp;N,&amp;P,&amp;r);</span><br><span class="line">    r=r/100+1;</span><br><span class="line">    int parent;</span><br><span class="line">    //输入i的父母结点</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;parent;</span><br><span class="line">        //将i存为parent的子结点</span><br><span class="line">        if(parent==-1)&#123;</span><br><span class="line">            root=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            tree[parent].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //dfs确定树的深度</span><br><span class="line">    dfs(root,1);</span><br><span class="line">    double tmp=1;</span><br><span class="line">    for(int i=0;i&lt;maxdepth-1;i++)tmp*=r;</span><br><span class="line">    printf(&quot;%.2lf %d&quot;,tmp*P,routes);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1004-Acute-Stroke"><a href="#1004-Acute-Stroke" class="headerlink" title="1004:Acute Stroke"></a>1004:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4317">Acute Stroke</a></h2><p>三维的BFS，用DFS时间复杂度过大；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int M,N,L,T;//矩阵的高&lt;1286</span><br><span class="line">            //矩阵的宽&lt;128</span><br><span class="line">            //slice数&lt;=60</span><br><span class="line">int arr[65][1290][130];</span><br><span class="line">int res=0;</span><br><span class="line">int dir[6][3]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;1,0,0&#125;,&#123;-1,0,0&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;0,0,-1&#125;,&#123;0,0,1&#125;</span><br><span class="line">&#125;;//6个方向：上下前后左右</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    node(int _x, int _y, int _z)&#123;</span><br><span class="line">		x=_x; y=_y; z=_z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void BFS(int i,int j,int k)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(i,j,k));</span><br><span class="line">    arr[i][j][k]=0;</span><br><span class="line">    int sum=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node n=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">            int x=n.x+dir[i][0];</span><br><span class="line">            int y=n.y+dir[i][1];</span><br><span class="line">            int z=n.z+dir[i][2];</span><br><span class="line">            //cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">            if(x&lt;L&amp;&amp;x&gt;=0&amp;&amp;y&lt;M&amp;&amp;y&gt;=0&amp;&amp;z&lt;N&amp;&amp;z&gt;=0)&#123;</span><br><span class="line">            if(arr[x][y][z]==1)&#123;</span><br><span class="line">                q.push(node(x,y,z));</span><br><span class="line">                arr[x][y][z]=0;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    if(sum&gt;=T)res+=sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;L&gt;&gt;T;</span><br><span class="line">    int thickness=0;</span><br><span class="line">    for(int i=0;i&lt;L;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;k++)&#123;</span><br><span class="line">                cin&gt;&gt;thickness;</span><br><span class="line">                arr[i][j][k]=thickness;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;L;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;k++)&#123;</span><br><span class="line">                    //cout&lt;&lt;arr[i][j][k];</span><br><span class="line">                if(arr[i][j][k])BFS(i,j,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-The-Largest-Generation"><a href="#1005-The-Largest-Generation" class="headerlink" title="1005:The Largest Generation"></a>1005:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4318">The Largest Generation</a></h2><p>家谱树问题，求结点最多的一层的结点数与层数；思路：使用vector数组保存每个结点的孩子，构建成家谱树，然后使用BFS计算每层结点数，过程中维护家谱树每一层的level，使用一个数组记录各层结点数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; child;</span><br><span class="line">    int level;</span><br><span class="line">&#125;members[101];</span><br><span class="line">int vis[101];//访问标记</span><br><span class="line">int N,M;//总人数，有孩子的人数</span><br><span class="line">int gen=0;</span><br><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    que.push(members[1]);</span><br><span class="line">    vis[1]=1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        node n=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i=0;i&lt;n.child.size();i++)&#123;</span><br><span class="line">            int index=n.child[i];</span><br><span class="line">            vis[n.level+1]++;</span><br><span class="line">            members[index].level=n.level+1;</span><br><span class="line">            que.push(members[index]);</span><br><span class="line">            if(gen!=n.level)gen=n.level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int id,K;</span><br><span class="line">    //输入构建家谱树</span><br><span class="line">    for(int i=0;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int c;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;K;</span><br><span class="line">        for(int j=0;j&lt;K;j++)&#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            members[id].child.push_back(c);</span><br><span class="line">            if(c==1)members[id].level=1;</span><br><span class="line">            else members[id].level=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BFS();</span><br><span class="line">    int res=0,res_i=0;</span><br><span class="line">    for(int i=1;i&lt;gen;i++)&#123;</span><br><span class="line">        if(vis[i]&gt;res)&#123;</span><br><span class="line">            res=vis[i];</span><br><span class="line">            res_i=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;&quot; &quot;&lt;&lt;res_i+1&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1006-Cars-on-Campus"><a href="#1006-Cars-on-Campus" class="headerlink" title="1006:Cars on Campus"></a>1006:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4319">Cars on Campus</a></h2><p>题目意思是给出一组车进出记录，给定时刻，算出状态还未in的车的数量，并且求出一天中停留时间最长的车牌号与时间；<br>题目不难，在理解题意上花了一点时间，主要是pat惯用的需要建立一个专用的数据结构node存储记录；<br>数据量较大，容易超时，刚开始用char type[4]来存储记录的状态，因此每次都需要调用strcmp函数对字符串进行比较，后改为bool字段，直接在输入时判断为in(true)/out(false)，没有超时；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int time;</span><br><span class="line">    char name[8];</span><br><span class="line">    bool type;</span><br><span class="line">&#125;record[10001],valid[10001];</span><br><span class="line"></span><br><span class="line">int timeToInt(int h,int m,int s)</span><br><span class="line">&#123;</span><br><span class="line">    return h*3600+m*60+s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp1(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    int x=strcmp(a.name,b.name);</span><br><span class="line">    if(x)return x&lt;0;</span><br><span class="line">    return a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp2(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    int hh,mm,ss;</span><br><span class="line">    //存储每辆车的停留时间</span><br><span class="line">    map&lt;string,int&gt;parkTime;</span><br><span class="line">    int maxTime=0;</span><br><span class="line">    char t[4];</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s %d:%d:%d %s&quot;,record[i].name,&amp;hh,&amp;mm,&amp;ss,t);</span><br><span class="line">        if(!strcmp(t,&quot;in&quot;))record[i].type=true;</span><br><span class="line">        else record[i].type=false;</span><br><span class="line">        record[i].time=timeToInt(hh,mm,ss);</span><br><span class="line">    &#125;</span><br><span class="line">    //按照name与time从小到大排序</span><br><span class="line">    sort(record,record+n,cmp1);</span><br><span class="line">    int num=0;</span><br><span class="line">    //筛选有效记录,并求出最长停留时间</span><br><span class="line">    for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">       // printf(&quot;%s %d %s\n&quot;,record[i].name,record[i].time,record[i].type);</span><br><span class="line">        if(!strcmp(record[i].name,record[i+1].name)&amp;&amp;</span><br><span class="line">           record[i].type&amp;&amp;!record[i+1].type)&#123;</span><br><span class="line">                valid[num++]=record[i];</span><br><span class="line">                valid[num++]=record[i+1];</span><br><span class="line">                int time=record[i+1].time-record[i].time;</span><br><span class="line">                if(parkTime.count(record[i].name)==0)&#123;</span><br><span class="line">                    parkTime[record[i].name]=0;</span><br><span class="line">                &#125;</span><br><span class="line">                parkTime[record[i].name]+=time;</span><br><span class="line">                if(maxTime&lt;parkTime[record[i].name])&#123;</span><br><span class="line">                    maxTime=parkTime[record[i].name];</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    ans.push_back(record[i].name);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(maxTime==parkTime[record[i].name])&#123;</span><br><span class="line">                    ans.push_back(record[i].name);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //按照time从小到大排序</span><br><span class="line">    sort(valid,valid+num,cmp2);</span><br><span class="line">    //输入搜索时间，从记录中选择计算</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">       scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);</span><br><span class="line">        int sum=0;</span><br><span class="line">        int temp=timeToInt(hh,mm,ss);</span><br><span class="line">        for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line"></span><br><span class="line">            if(valid[j].time&gt;temp)break;</span><br><span class="line">            if(valid[j].type)sum++;</span><br><span class="line">            else sum--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /*map&lt;string,int&gt;::iterator it;</span><br><span class="line">    for(it=parkTime.begin();it!=parkTime.end();it++)&#123;</span><br><span class="line">        if(it-&gt;second==maxTime)printf(&quot;%s &quot;,it-&gt;first.c_str());</span><br><span class="line">    &#125;*/</span><br><span class="line">    for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%02d:%02d:%02d\n&quot;, maxTime / 3600, maxTime % 3600 / 60, maxTime % 60);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1007-Consecutive-Factors"><a href="#1007-Consecutive-Factors" class="headerlink" title="1007:Consecutive Factors"></a>1007:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4320">Consecutive Factors</a></h2><p>题目大意：求一个数的最长的连续因数串；<br>思路：从1到sqrt(n)的范围内循环，计算从当前i开始能够被n整除的最长子串，保存比较长度，最后得出最长；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; ans,temp;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int tempn=(int)sqrt(n);</span><br><span class="line">    //cout&lt;&lt;tempn&lt;&lt;endl;</span><br><span class="line">    int x=1,num=0,res=0;</span><br><span class="line">    for(int i=2;i&lt;=tempn;i++)&#123;</span><br><span class="line">        x*=i;</span><br><span class="line">        int t=i;</span><br><span class="line">        while(n%x==0&amp;&amp;t&lt;=tempn)&#123;</span><br><span class="line">            temp.push_back(t);</span><br><span class="line">            t++;</span><br><span class="line">            x*=t;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp.size()&gt;ans.size())&#123;</span><br><span class="line">            ans=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        x=1;</span><br><span class="line">        temp.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans.size()==0)&#123;</span><br><span class="line">        cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout&lt;&lt;ans.size()&lt;&lt;endl;</span><br><span class="line">        for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i];</span><br><span class="line">            if(i!=ans.size()-1)cout&lt;&lt;&quot;*&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1008-Deduplication-on-a-Linked-List"><a href="#1008-Deduplication-on-a-Linked-List" class="headerlink" title="1008:Deduplication on a Linked List "></a>1008:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4321">Deduplication on a Linked List </a></h2><p>题目大意：将链表式数组中绝对值重复的值取出来，放入一个新的数组中，需要输入当前地址，值，以及下一个地址值；<br>我的思路：</p>
<ol>
<li>使用特定数据结构存储add,value,next,初始化按照链表顺序排好序；</li>
<li>从表头结点开始遍历，判断下一个结点的值是否出现过，flag[10001]表示是否出现过标记；</li>
<li>出现过则需要改变当前结点的next值，同时把重复结点赋予新数组，改变新数组的前一个结点的next值；<br>超时了！主要时间复杂度在排序O(n^2)!<br>不超时思路：</li>
<li>空间换取时间，直接在当前地址存储value/next,inList[add].value=v;inList[add].next=n;</li>
<li>从起始地址开始，判断当前value是否访问过，removeList[] 与 outList[]存放最终结果<strong>各个结点的地址</strong>；</li>
<li>遍历输出List[i],inList[List [i]].value,List[i+1];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int num,first;</span><br><span class="line">/*</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int add,value,next;</span><br><span class="line">    bool sign;</span><br><span class="line">&#125;List[100001],removeList[100001];</span><br><span class="line">int flag[10001];</span><br><span class="line">int s_index;</span><br><span class="line">void InitNode()</span><br><span class="line">&#123;</span><br><span class="line">    int nnum=1;</span><br><span class="line">    List[0]=removeList[s_index];</span><br><span class="line">    int n=removeList[s_index].next;</span><br><span class="line">    while(n!=-1)&#123;</span><br><span class="line">        for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line">            if(removeList[j].add==n)&#123;</span><br><span class="line">                List[nnum++]=removeList[j];</span><br><span class="line">                n=removeList[j].next;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int removenum=0;</span><br><span class="line">    cin&gt;&gt;first&gt;&gt;num;</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;removeList[i].add&gt;&gt;removeList[i].value&gt;&gt;removeList[i].next;</span><br><span class="line">        if(removeList[i].add==first)s_index=i;</span><br><span class="line">    &#125;</span><br><span class="line">    InitNode();</span><br><span class="line">    flag[abs(List[0].value)]=1;</span><br><span class="line">    for(int i=0;i&lt;num-1;i++)&#123;</span><br><span class="line">        int v=abs(List[i+1].value);</span><br><span class="line">        //发生重复</span><br><span class="line">        if(flag[v]!=0)&#123;</span><br><span class="line">            //从链表中去除结点</span><br><span class="line">            List[i].next=List[i+1].next;</span><br><span class="line">            //加入到remove链表中</span><br><span class="line">            if(removenum==0)removeList[removenum++]=List[i+1];</span><br><span class="line">            else &#123;</span><br><span class="line">                removeList[removenum-1].next=List[i+1].add;</span><br><span class="line">                removeList[removenum++]=List[i+1];</span><br><span class="line">            &#125;</span><br><span class="line">            List[i+1].sign=true;</span><br><span class="line">        &#125;</span><br><span class="line">        else flag[v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    int t=0,f=0;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        if(!List[i].sign)&#123;</span><br><span class="line">            if(t==num-removenum-1)&#123;</span><br><span class="line">                printf(&quot;%05d %d %d\n&quot;,List[i].add,List[i].value,-1);break;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%05d %d %05d\n&quot;,List[i].add,List[i].value,List[i].next);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;removenum;i++)&#123;</span><br><span class="line">        if(i==removenum-1)</span><br><span class="line">             printf(&quot;%05d %d %d\n&quot;,removeList[i].add,removeList[i].value,-1);</span><br><span class="line">        else printf(&quot;%05d %d %05d\n&quot;,removeList[i].add,removeList[i].value,removeList[i].next);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;*/</span><br><span class="line">#define MAX 100001</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int value,next;</span><br><span class="line">&#125;inList[MAX];</span><br><span class="line">int outList[MAX],removeList[MAX];</span><br><span class="line">bool flag[10001]=&#123;0&#125;;</span><br><span class="line">int s_index=0;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;first,&amp;num);</span><br><span class="line">    int add;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;add;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;inList[add].value,&amp;inList[add].next);</span><br><span class="line">        if(add==first)s_index=add;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp=s_index;</span><br><span class="line">    int p=0,q=0;</span><br><span class="line">    int rfirst=0;</span><br><span class="line">    while(temp!=-1)&#123;</span><br><span class="line">        int v=abs(inList[temp].value);</span><br><span class="line">        //发生冲突</span><br><span class="line">        if(flag[v])&#123;</span><br><span class="line">            if(q==0)rfirst=inList[temp].value;</span><br><span class="line">            removeList[q++]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            outList[p++]=temp;</span><br><span class="line">            flag[v]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=inList[temp].next;</span><br><span class="line">    &#125;</span><br><span class="line">    //输出</span><br><span class="line">    for(int i=0;i&lt;p;i++)&#123;</span><br><span class="line">        if(i!=p-1)&#123;</span><br><span class="line">            //printf(&quot;%05d %d %05d\n&quot;,outList[i].value,outList[i+1].value);</span><br><span class="line">            printf(&quot;%05d %d %05d\n&quot;,outList[i],inList[outList[i]].value,outList[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;%05d %d %d\n&quot;,outList[i],inList[outList[i]].value,-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;q;i++)&#123;</span><br><span class="line">        if(i!=q-1)&#123;</span><br><span class="line">            printf(&quot;%05d %d %05d\n&quot;,removeList[i],inList[removeList[i]].value,removeList[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        else  printf(&quot;%05d %d %d\n&quot;,removeList[i],inList[removeList[i]].value,-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1009-Insertion-or-Heap-Sort"><a href="#1009-Insertion-or-Heap-Sort" class="headerlink" title="1009:Insertion or Heap Sort "></a>1009:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4322">Insertion or Heap Sort </a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num[101];</span><br><span class="line">int num2[101];</span><br><span class="line">int res[101];</span><br><span class="line">int Heap_Size=0;</span><br><span class="line">bool flag=false;</span><br><span class="line">bool isSame(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(arr[i]!=res[i])return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void out_put(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//插入排序</span><br><span class="line">bool Insert_Sort(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;len;i++)&#123;</span><br><span class="line">        int temp=arr[i];</span><br><span class="line">        int j;</span><br><span class="line">        for(j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">            if(arr[j]&gt;temp)&#123;</span><br><span class="line">                arr[j+1]=arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+1]=temp;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            out_put(arr,len);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(isSame(arr,len))&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Insertion Sort&quot;&lt;&lt;endl;</span><br><span class="line">            flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Max_Heap(int arr[],int i)</span><br><span class="line">&#123;</span><br><span class="line">    int l=2*(i+1)-1;</span><br><span class="line">    int r=2*(i+1);</span><br><span class="line">    int largeset=i;</span><br><span class="line">    if(arr[l]&gt;arr[i]&amp;&amp;l&lt;Heap_Size)&#123;</span><br><span class="line">        largeset=l;</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr[r]&gt;arr[largeset]&amp;&amp;r&lt;Heap_Size)&#123;</span><br><span class="line">        largeset=r;</span><br><span class="line">    &#125;</span><br><span class="line">    if(largeset!=i)&#123;</span><br><span class="line">        swap(arr[largeset],arr[i]);</span><br><span class="line">        Max_Heap(arr,largeset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//建最大堆</span><br><span class="line">void Build_Max_Heap(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    //从第一个非叶子结点开始</span><br><span class="line">    for(int i=len/2-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Max_Heap(arr,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Heap_Sort(int arr[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    Heap_Size=len;</span><br><span class="line">    Build_Max_Heap(arr,len);</span><br><span class="line">    for(int i=0;i&lt;len-1;i++)&#123;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            out_put(arr,len);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(isSame(arr,len))&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Heap Sort&quot;&lt;&lt;endl;</span><br><span class="line">            flag=true;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[Heap_Size-1],arr[0]);</span><br><span class="line">        Heap_Size--;</span><br><span class="line">        Build_Max_Heap(arr,Heap_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        num2[i]=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(!Insert_Sort(num,n))</span><br><span class="line">        Heap_Sort(num2,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1010-Build-A-Binary-Search-Tree"><a href="#1010-Build-A-Binary-Search-Tree" class="headerlink" title="1010:Build A Binary Search Tree"></a>1010:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4323">Build A Binary Search Tree</a></h2>根据输入构造二叉树，利用二叉搜索树的排序特点，将key[]从小到大排序后，就是BST的中序遍历的顺序，因此可以为BST直接赋值，再用queue层次遍历，实际上就是树的BFS；<br>刚开始还想要按照传统方法输入建树，也太蠢了吧！<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">struct treeNode</span><br><span class="line">&#123;</span><br><span class="line">    int left;</span><br><span class="line">    int right;</span><br><span class="line">    int value;</span><br><span class="line">&#125;Tree[101];</span><br><span class="line">int key[101];</span><br><span class="line">int index=0;</span><br><span class="line"></span><br><span class="line">//中序遍历</span><br><span class="line">void mid(int t)</span><br><span class="line">&#123;</span><br><span class="line">    if(t==-1)return;</span><br><span class="line">    mid(Tree[t].left);</span><br><span class="line">    Tree[t].value=key[index++];</span><br><span class="line">    mid(Tree[t].right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//层次遍历</span><br><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">    bool flag=false;</span><br><span class="line">    queue&lt;treeNode&gt;q;</span><br><span class="line">    q.push(Tree[0]);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        treeNode n=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(flag)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        flag=true;</span><br><span class="line">        cout&lt;&lt;n.value;</span><br><span class="line">        if(n.left!=-1)q.push(Tree[n.left]);</span><br><span class="line">        if(n.right!=-1)q.push(Tree[n.right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Tree[i].left&gt;&gt;Tree[i].right;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cin&gt;&gt;key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(key,key+num);</span><br><span class="line">    //for(int i=0;i&lt;num;i++)cout&lt;&lt;key[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    mid(0);</span><br><span class="line">    BFS();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1011-Forwards-on-Weibo"><a href="#1011-Forwards-on-Weibo" class="headerlink" title="1011:Forwards on Weibo"></a>1011:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4306">Forwards on Weibo</a></h2>太感动了，思路都是自己想出来的！<br>挺切合实际的，</li>
<li>用vector二维数组保存微博关注者；</li>
<li>使用queue保存每一level转发者；注意保存的是自己设定的node，其中包括level，保证转发层次在一定范围内；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector &lt;int&gt; &gt; User;</span><br><span class="line">int flag[1001];//标记是否转发过</span><br><span class="line">int N=0;//user数&lt;=1000</span><br><span class="line">int level=0;//follow层数&lt;=6</span><br><span class="line">int qnum=0;//查询次数</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int index;</span><br><span class="line">    int Lev;</span><br><span class="line">    node(int _index, int _lev)&#123;</span><br><span class="line">		index=_index;</span><br><span class="line">		Lev=_lev;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;level;</span><br><span class="line">    int num;//关注人数</span><br><span class="line">    int follow;//关注人的下标值</span><br><span class="line">    User.resize(N+1);</span><br><span class="line">    //输入,记录关注者</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        for(int j=0;j&lt;num;j++)&#123;</span><br><span class="line">            cin&gt;&gt;follow;</span><br><span class="line">            User[follow].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   /* cout&lt;&lt;&quot;------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;User[i].size();j++)&#123;</span><br><span class="line">            cout&lt;&lt;User[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;*/</span><br><span class="line">    cin&gt;&gt;qnum;</span><br><span class="line">    int k;</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=0;i&lt;qnum;i++)&#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        queue&lt;node&gt; q;</span><br><span class="line">        memset(flag,0,sizeof(flag));</span><br><span class="line">        sum=0;</span><br><span class="line">        flag[k]=1;</span><br><span class="line">        q.push(node(k,0));</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            node temp=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">           //cout&lt;&lt;temp.index&lt;&lt;&quot; &quot;&lt;&lt;temp.Lev&lt;&lt;endl;</span><br><span class="line">            int now_level=temp.Lev;</span><br><span class="line">            if(now_level&gt;=level)break;</span><br><span class="line">            for(int j=0;j&lt;User[temp.index].size();j++)&#123;</span><br><span class="line">                if(!flag[User[temp.index][j]])&#123;</span><br><span class="line">                    sum+=1;</span><br><span class="line">                    q.push(node(User[temp.index][j],now_level+1));</span><br><span class="line">                    flag[User[temp.index][j]]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">       // cout&lt;&lt;&quot;------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1012-Kuchiguse"><a href="#1012-Kuchiguse" class="headerlink" title="1012:Kuchiguse"></a>1012:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4307">Kuchiguse</a></h2>char str[101][256]字符数组的输入：scanf(“%s”,&amp;str[i])  /  string str[101]字符串输入：cin&gt;&gt;str[i],以<strong>空格</strong>为分割字符串；<br>简单题，求N个字符串的最长公共后缀，思路：以第一个字符串为基准，遍历另外N-1个字符串，判断从后往前的同样位置字符是否相等；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">string str[101];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    getchar();</span><br><span class="line">    for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        getline(cin,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    bool flag=false;</span><br><span class="line">    int res=0;</span><br><span class="line">   for(int i=0;i&lt;str[0].length();i++)&#123;</span><br><span class="line">        char temp=str[0][str[0].length()-i-1];</span><br><span class="line">        for(int j=1;j&lt;num;j++)&#123;</span><br><span class="line">            char x=str[j][str[j].length()-i-1];</span><br><span class="line">            if(x!=temp)&#123;</span><br><span class="line">                res=i;</span><br><span class="line">                flag=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(res==0&amp;&amp;flag)//bugcout&lt;&lt;&quot;nai&quot;&lt;&lt;endl;</span><br><span class="line">    else if(res==0)&#123;</span><br><span class="line">        for(int i=0;i&lt;str[0].length();i++)cout&lt;&lt;str[0][i];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    for(int i=str[0].length()-res;i&lt;str[0].length();i++)cout&lt;&lt;str[0][i];</span><br><span class="line">   /* for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">        cout&lt;&lt;str[i]&lt;&lt;endl;</span><br><span class="line">    &#125;*/</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1013-Hashing"><a href="#1013-Hashing" class="headerlink" title="1013:Hashing"></a>1013:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4308">Hashing</a></h2>Hash+平方探测法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isPrime(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==1)return false;</span><br><span class="line">    if(x==2)return true;</span><br><span class="line">    int temp=sqrt(x);</span><br><span class="line">    for(int i=2;i&lt;=temp;i++)&#123;</span><br><span class="line">        if(x%i==0)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到比x大的最近一个质数</span><br><span class="line">int Find_Prime(int x)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        if(isPrime(x))return x;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int MSize,N;</span><br><span class="line">    bool flag[10001];</span><br><span class="line">    int input[10001];</span><br><span class="line">    bool ff=false,fff=false;</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    cin&gt;&gt;MSize&gt;&gt;N;</span><br><span class="line">    int table_size;</span><br><span class="line">    //if(MSize==1)table_size=2;</span><br><span class="line">    table_size=Find_Prime(MSize);</span><br><span class="line">    int num;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        int num=input[i];</span><br><span class="line">        int a=num%table_size;</span><br><span class="line">        if(ff)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        if(!flag[a])&#123;</span><br><span class="line">            cout&lt;&lt;a;</span><br><span class="line">            flag[a]=1;</span><br><span class="line">            fff=true;</span><br><span class="line">        &#125;</span><br><span class="line">        //平方探测法</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int x=1;x&lt;table_size;x++)&#123;//bug</span><br><span class="line">                int t=(x*x+a)%table_size;</span><br><span class="line">                if(!flag[t])&#123;</span><br><span class="line">                    cout&lt;&lt;t;</span><br><span class="line">                    fff=true;</span><br><span class="line">                    flag[t]=1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fff)cout&lt;&lt;&quot;-&quot;;</span><br><span class="line">        ff=true;</span><br><span class="line">        fff=false;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1014-Total-Sales-of-Supply-Chain"><a href="#1014-Total-Sales-of-Supply-Chain" class="headerlink" title="1014:Total Sales of Supply Chain"></a>1014:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4309">Total Sales of Supply Chain</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double sum=0;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; tree;</span><br><span class="line">int N;//结点总数</span><br><span class="line">double P,r;//根结点的原始值，rate</span><br><span class="line">int flag[100001];//标记子节点的产品值</span><br><span class="line"></span><br><span class="line">void DFS(int index,int level)</span><br><span class="line">&#123;</span><br><span class="line">    //说明为叶子结点</span><br><span class="line">    //可结合产品数量计算金额</span><br><span class="line">    if(tree[index].size()==0)&#123;</span><br><span class="line">        //这儿存在bug，一个超时，一个错误</span><br><span class="line">        //改用pow函数即可</span><br><span class="line">        /*double t=r;</span><br><span class="line">        for(int k=0;k&lt;level-1;k++)&#123;</span><br><span class="line">            t=r*t;</span><br><span class="line">        &#125;*/</span><br><span class="line">        sum+=pow(r,level)*P*flag[index];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;tree[index].size();i++)&#123;</span><br><span class="line">        DFS(tree[index][i],level+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d %lf %lf&quot;,&amp;N,&amp;P,&amp;r);</span><br><span class="line">    r=(double)1+r/100;</span><br><span class="line">    tree.resize(N);</span><br><span class="line">    int childnum;</span><br><span class="line">    //输入</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;childnum);</span><br><span class="line">        if(childnum!=0)&#123;</span><br><span class="line">            int child;</span><br><span class="line">            //记录各个结点的子节点</span><br><span class="line">            for(int j=0;j&lt;childnum;j++)&#123;</span><br><span class="line">                cin&gt;&gt;child;</span><br><span class="line">                tree[i].push_back(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            int products;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;products);</span><br><span class="line">            flag[i]=products;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DFS求出遍历所有路径</span><br><span class="line">    DFS(0,0);</span><br><span class="line">    printf(&quot;%.1lf&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1015Graduate-Admission"><a href="#1015Graduate-Admission" class="headerlink" title="1015Graduate Admission"></a>1015<a target="_blank" rel="noopener" href="https://www.nowcoder.com/pat/5/problem/4310">Graduate Admission</a></h2>优先队列,pop(),push(),top(),没法遍历；</li>
</ol>
<ul>
<li>自定义优先级<br>struct cmp{<br>  operator bool(int x,int y){return x&gt;y;}<br>}<br>priority_queue&lt;int,vector<int>,cmp&gt;</li>
<li>结构体声明方式<br>struct node{<br>  int x,y;<br>  friend bool operator &lt; (node a, node b)<br>　　{<br>　　　　return a.x &gt; b.x;    //结构体中，x小的优先级高<br>　　}<br>}<br>priority_queue<node>q;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int nums,schools,chs;//毕业人数&lt;=40000，</span><br><span class="line">                    //院校数&lt;=100，</span><br><span class="line">                    //志愿数&lt;=5</span><br><span class="line">vector&lt;int&gt;quotas;//院校招生限额</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int index;</span><br><span class="line">    int GE;</span><br><span class="line">    int GT;</span><br><span class="line">    vector&lt;int&gt;choices;</span><br><span class="line">&#125;Students[40001];</span><br><span class="line">vector&lt;node&gt;SchoolsStu[101];//院校招生学生</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    //两个double！！！</span><br><span class="line">    double x=(double)(a.GE+a.GT)/2;</span><br><span class="line">    double y=(double)(b.GE+b.GT)/2;</span><br><span class="line">    if(x!=y)return x&gt;y;</span><br><span class="line">    else return a.GE&gt;b.GE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp2(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.index&lt;b.index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isEqual(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    //两个double！！！</span><br><span class="line">    double x=(double)(a.GE+a.GT)/2;</span><br><span class="line">    double y=(double)(b.GE+b.GT)/2;</span><br><span class="line">    if(x==y&amp;&amp;a.GE==b.GE)return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //输入</span><br><span class="line">    cin&gt;&gt;nums&gt;&gt;schools&gt;&gt;chs;</span><br><span class="line">    int quo;</span><br><span class="line">    for(int i=0;i&lt;schools;i++)&#123;</span><br><span class="line">        cin&gt;&gt;quo;</span><br><span class="line">        quotas.push_back(quo);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;nums;i++)&#123;</span><br><span class="line">        Students[i].index=i;</span><br><span class="line">        Students[i].choices.resize(chs);</span><br><span class="line">        cin&gt;&gt;Students[i].GE&gt;&gt;Students[i].GT;</span><br><span class="line">        int temp;</span><br><span class="line">        for(int j=0;j&lt;chs;j++)&#123;</span><br><span class="line">            cin&gt;&gt;temp;</span><br><span class="line">            Students[i].choices[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算</span><br><span class="line">    sort(Students,Students+nums,cmp);</span><br><span class="line">    for(int i=0;i&lt;nums;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;chs;j++)&#123;</span><br><span class="line">            int tempc=Students[i].choices[j];</span><br><span class="line">            if(quotas[tempc]&gt;SchoolsStu[tempc].size())&#123;</span><br><span class="line">                SchoolsStu[tempc].push_back(Students[i]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //无需用循环！</span><br><span class="line">                //用循环复杂度极高，实际上只要对比新加入的最菜的那个学生即可</span><br><span class="line">                if(isEqual(SchoolsStu[tempc].back(),Students[i]))&#123;</span><br><span class="line">                    SchoolsStu[tempc].push_back(Students[i]);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //输出</span><br><span class="line">    /*cout&lt;&lt;&quot;=============================&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;nums;i++)&#123;</span><br><span class="line">        cout&lt;&lt;Students[i].GE&lt;&lt;&quot; &quot;&lt;&lt;Students[i].GT&lt;&lt;&quot; &quot;;</span><br><span class="line">        for(int j=0;j&lt;Students[i].choices.size();j++)&#123;</span><br><span class="line">            int xx=Students[i].choices[j];</span><br><span class="line">            cout&lt;&lt;xx&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;=============================&quot;&lt;&lt;endl;*/</span><br><span class="line">    for(int i=0;i&lt;schools;i++)&#123;</span><br><span class="line">        //vector的排序方式</span><br><span class="line">        sort(SchoolsStu[i].begin(),SchoolsStu[i].end(),cmp2);</span><br><span class="line">        for(int j=0;j&lt;SchoolsStu[i].size();j++)&#123;</span><br><span class="line">            if(j!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">            cout&lt;&lt;SchoolsStu[i][j].index;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1021"><a href="#1021" class="headerlink" title="1021"></a>1021</h2><p>一开始题目看错，用空间换取时间，出现段错误，因为数组越界；<br>使用了<img src="https://blog.csdn.net/sevenjoin/article/details/81943864" alt="map"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;int,int&gt; myMap[55];</span><br><span class="line">int flag[55];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //N集合数&lt;=50</span><br><span class="line">    //K每个集合的整数个数&lt;=10^4,在[0,10^9]内</span><br><span class="line">    //Q查询数</span><br><span class="line">    //想用Set[55][110000000]空间换取时间，根本不ok</span><br><span class="line">    //换个思路</span><br><span class="line">    int N,K,Q,data;</span><br><span class="line">    map&lt;int,int&gt;::iterator it;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;K;</span><br><span class="line">        for(int j=0;j&lt;K;j++)&#123;</span><br><span class="line">            cin&gt;&gt;data;</span><br><span class="line">            it=myMap[i].find(data);</span><br><span class="line">            if(it==myMap[i].end())&#123;</span><br><span class="line">                myMap[i][data]=1;</span><br><span class="line">               // flag[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                myMap[i][data]++;</span><br><span class="line">            &#125;</span><br><span class="line">            //可直接myMap[i][data]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    int set1,set2;</span><br><span class="line">    for(int i=0;i&lt;Q;i++)&#123;</span><br><span class="line">        int NC=0,NT=0;</span><br><span class="line">        double ret=0;</span><br><span class="line">        cin&gt;&gt;set1&gt;&gt;set2;</span><br><span class="line">        map&lt;int,int&gt;::iterator iit;</span><br><span class="line">        for(iit=myMap[set1-1].begin();iit!=myMap[set1-1].end();iit++)&#123;</span><br><span class="line">            int temp=iit-&gt;first;</span><br><span class="line">            it=myMap[set2-1].find(temp);</span><br><span class="line">            if(it!=myMap[set2-1].end())&#123;</span><br><span class="line">                //找到了</span><br><span class="line">                NC++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       // cout&lt;&lt;NC&lt;&lt;&quot; &quot;&lt;&lt;flag[set1-1]+flag[set2-1]-NC&lt;&lt;endl;</span><br><span class="line">        ret=(double)NC*100/(myMap[set1-1].size()+myMap[set2-1].size()-NC);</span><br><span class="line">        printf(&quot;%.1lf%%\n&quot;,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/01/%E5%88%B7%E9%A2%98/PAT%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" data-id="ckxq1azto000keswb8vwz1gu4" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2019/09/06/%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      操作系统复习
      
    </div>
  </a>
  
  
  <a href="/2019/08/31/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">查找与排序</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Cecyci &copy; 2021</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Cecyci"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>