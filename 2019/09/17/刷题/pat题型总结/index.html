<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="前端 Python 机器学习">
  
  
  <meta name="description" content="2021.12.28建的博客 看看我能坚持多久">
  
  <title>
    pat题型总结 |
    
    Cecyci
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-刷题/pat题型总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  pat题型总结
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2019/09/17/%E5%88%B7%E9%A2%98/pat%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2019-09-17T14:32:31.000Z" itemprop="datePublished">2019-09-17</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <hr>
<h1 id="窗口排队模拟"><a href="#窗口排队模拟" class="headerlink" title="窗口排队模拟"></a>窗口排队模拟</h1><h2 id="eg1-1017-Queueing-at-Bank-25-分"><a href="#eg1-1017-Queueing-at-Bank-25-分" class="headerlink" title="eg1. 1017 Queueing at Bank (25 分)"></a>eg1. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805491530579968">1017 Queueing at Bank (25 分)</a></h2><p> <strong>题意</strong>：给出顾客数与窗口数，以及顾客的到达时间和处理时间；Bank的工作时间在8.-17.；在8.前到达需要等到8.后才开始办理，17.点及之后不办理，88了；计算平均等待时间；<br> <span id="more"></span><br> <strong>思路</strong>：</p>
<ol>
<li>输入； </li>
<li>按照到达时间排序；</li>
<li>先将空窗口填满（入队列）：<strong>即到即办理，或者等到8点</strong>，计算结束时间和等待时间；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在8.以前到达</span><br><span class="line">            if(Start&gt;Customer[i].arr_time)&#123;</span><br><span class="line">                Customer[i].wait_time=Start-Customer[i].arr_time;</span><br><span class="line">                Customer[i].finish_time=Customer[i].p_time;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                Customer[i].wait_time=0;</span><br><span class="line">                Customer[i].finish_time=Customer[i].arr_time+Customer[i].p_time-Start;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li>
<li>然后选取办理时间最早结束的出队列：它的结束时间与下一个候选顾客的到达时间作比较，<strong>到达之后就有空位置即办理，或者等到最先结束的完成后,</strong> 计算结束时间和等待时间；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//等待时间为前一个结束时间-到达时间</span><br><span class="line">            //或者直接有空窗口，无需等待</span><br><span class="line">            int temp=n.finish_time+Start-Customer[i].arr_time;</span><br><span class="line">            if(temp&gt;0)&#123;</span><br><span class="line">                Customer[i].wait_time=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else Customer[i].wait_time=0;</span><br></pre></td></tr></table></figure></li>
<li>3、4步维护总等待时间，当当前顾客到达时间&gt;=17.，结束啦！</li>
</ol>
<p> <strong>注意点</strong>：</p>
<ol>
<li>时间以s统一界定，以免逻辑上把自己给绕晕；</li>
<li>构造数据结构node，存放每个顾客的到达时间，等待时间，结束时间，以及处理时间；</li>
<li>构造优先队列priority_queue,重载&lt;号，结束时间早的优先；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int arr_time;</span><br><span class="line">    int wait_time;//以s计算的等待时间</span><br><span class="line">    int finish_time,p_time;//以s计算的结束时间与处理时间</span><br><span class="line"></span><br><span class="line">    friend bool operator &lt;(const node&amp;a,const node&amp;b)&#123;</span><br><span class="line">        return a.finish_time&gt;b.finish_time;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;Customer[10005];</span><br><span class="line">priority_queue &lt;node&gt; Lines;</span><br></pre></td></tr></table></figure>
<h2 id="eg2-1014-Waiting-in-Line-30-分"><a href="#eg2-1014-Waiting-in-Line-30-分" class="headerlink" title="eg2.1014 Waiting in Line (30 分)"></a>eg2.<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936">1014 Waiting in Line (30 分)</a></h2></li>
</ol>
<p> <strong>题意</strong>：输入窗口数，黄线内每个队伍的最大人数，顾客数与查询数；输入顾客的处理时间，8.开始处理，17.后不接受处理，计算每个顾客处理结束的时间；<br> <strong>思路</strong>：</p>
<ol>
<li>构造顾客数据结构，存放处理时间与结束时间；</li>
<li>queue<node>[i]作为窗口，存放在黄线内的顾客；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int pro_time;</span><br><span class="line">    int fin_time;</span><br><span class="line">    node(int _p,int _f)</span><br><span class="line">    &#123;</span><br><span class="line">        pro_time=_p;</span><br><span class="line">        fin_time=_f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; Lines[25];</span><br></pre></td></tr></table></figure></li>
<li>flag_time[25]数组表示每个窗口队首的结束时间，wf_time[1005]存放K个顾客的结束时间；</li>
<li>填满黄线内窗口空位M*N，一旦进入黄线，结束顾客结束时间确定，即队列顾客back的结束时间+当前顾客的处理时间，更新flag_time与wf_time;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool ff=true;</span><br><span class="line">    for(int i=0;i&lt;M&amp;&amp;ff;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">            int temp_time;</span><br><span class="line">            if(Lines[j].size()==0)temp_time=0;</span><br><span class="line">            else temp_time=Lines[j].back().fin_time;</span><br><span class="line">            Lines[j].push(node(p_time[index],p_time[index]+temp_time));</span><br><span class="line">            flag_time[j]=Lines[j].front().fin_time;</span><br><span class="line">            if(temp_time&gt;=540)wf_time[index]=-1;//开始的时间在17.及之后</span><br><span class="line">            else wf_time[index]=p_time[index]+temp_time;</span><br><span class="line">            index++;</span><br><span class="line">            if(index&gt;K)&#123;</span><br><span class="line">                    ff=false;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>黄线外顾客进入队列,首先找到flag_time[]中的最小值，因为最小即该队列最先会有人结束，记录窗口值，队首顾客出队，下一个顾客进队，更新flag_time与wf_time;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for(int i=index;i&lt;K;i++)&#123;</span><br><span class="line">        //找到flag_time中的最小值</span><br><span class="line">        int Min=flag_time[0];</span><br><span class="line">        int Min_index=0;</span><br><span class="line">        for(int w=1;w&lt;N;w++)&#123;</span><br><span class="line">            if(flag_time[w]&lt;Min)&#123;</span><br><span class="line">                Min=flag_time[w];</span><br><span class="line">                Min_index=w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //第Min_index个窗口最先处理完</span><br><span class="line">        int temp_time=Lines[Min_index].back().fin_time;</span><br><span class="line">           // cout&lt;&lt;temp_time&lt;&lt;&quot; &quot;&lt;&lt;p_time[index]&lt;&lt;endl;</span><br><span class="line">        Lines[Min_index].pop();</span><br><span class="line">        Lines[Min_index].push(node(p_time[index],p_time[index]+temp_time));</span><br><span class="line">        flag_time[Min_index]=Lines[Min_index].front().fin_time;</span><br><span class="line">        if(temp_time&gt;=540)wf_time[index]=-1;//开始的时间在17.及之后</span><br><span class="line">        else wf_time[index]=p_time[index]+temp_time;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <strong>注意点</strong>：</p>
<ol>
<li>if-else，当顾客的开始处理时间在17.及之后，直接忽略了；<h2 id="eg3-1026-Table-Tennis-30-分"><a href="#eg3-1026-Table-Tennis-30-分" class="headerlink" title="eg3. 1026 Table Tennis (30 分)"></a>eg3. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560">1026 Table Tennis (30 分)</a></h2></li>
</ol>
<hr>
<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="eg1-1002-A-B-for-Polynomials-25-分"><a href="#eg1-1002-A-B-for-Polynomials-25-分" class="headerlink" title="eg1. 1002 A+B for Polynomials (25 分)"></a>eg1. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000">1002 A+B for Polynomials (25 分)</a></h2><h2 id="eg2-1009-Product-of-Polynomials-25-分"><a href="#eg2-1009-Product-of-Polynomials-25-分" class="headerlink" title="eg2. 1009 Product of Polynomials (25 分)"></a>eg2. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344">1009 Product of Polynomials (25 分)</a></h2><p> <strong>题意</strong>：输入指数与系数，求两个多项式的和（或乘积）；按指数从大到小输出非零项；<br> <strong>思路</strong>：map&lt;int,double&gt;a,b作为输入的A、B多项式；map&lt;int,double,greater<int> &gt;作为结果（加入greater表示按key值从大到小排列）；<br> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvchaoshun/p/7769003.html">pair用法</a>:make_pair(x,y);pair-&gt;first<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/sevenjoin/article/details/81943864">map用法</a>:每个key在map中只能出现一次；mp.insert(pair);mp.erase(iter);mp.size();</p>
<h1 id="计算树的叶子结点"><a href="#计算树的叶子结点" class="headerlink" title="计算树的叶子结点"></a>计算树的叶子结点</h1><h2 id="eg1-1004-Counting-Leaves-30-分"><a href="#eg1-1004-Counting-Leaves-30-分" class="headerlink" title="eg1. 1004 Counting Leaves (30 分)"></a>eg1. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184">1004 Counting Leaves (30 分)</a></h2><p> <strong>题意</strong>：家谱树，计算每层没有孩子的成员，即计算树的每层叶子结点树；输入树中结点总数N，以及叶子结点数M；输出M个非叶子结点的K个孩子；输出各层叶子结点的个数；<br> <strong>思路</strong>：</p>
<ol>
<li>数据结构树的结点使用vector存放孩子列表，层数以及当前index；</li>
<li>树的BFS queue;依次将树结点压入队列，同一层的拥有一样的父母结点，都会挤在一起；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Layer_Tra()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    int leavenum=0;</span><br><span class="line">    q.push(Family[1]);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node n=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(n.children.size()==0)&#123;</span><br><span class="line">            leaves[n.level]++;</span><br><span class="line">        &#125;</span><br><span class="line">        now_level=n.level;</span><br><span class="line">       // cout&lt;&lt;now_level&lt;&lt;endl;</span><br><span class="line">        for(int i=0;i&lt;n.children.size();i++)&#123;</span><br><span class="line">            Family[n.children[i]].level=n.level+1;</span><br><span class="line">            //node temp=Family[n.children[i]];</span><br><span class="line">            q.push(Family[n.children[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eg2-1094-The-Largest-Generation-25-分"><a href="#eg2-1094-The-Largest-Generation-25-分" class="headerlink" title="eg2. 1094 The Largest Generation (25 分)"></a>eg2. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048">1094 The Largest Generation (25 分)</a></h2></li>
</ol>
<p> <strong>题意</strong>：同上题，计算的是有最多成员的成员值以及层数；<br> <strong>思路</strong>：同样是使用BFS，用level更新孩子们所在层数，同时用数组[parent.level+1]来维护该层结点的个数；</p>
<h1 id="计算最佳路径（图的DFS）"><a href="#计算最佳路径（图的DFS）" class="headerlink" title="计算最佳路径（图的DFS）"></a>计算最佳路径（图的DFS）</h1><h2 id="eg1-1003-Emergency-25-分"><a href="#eg1-1003-Emergency-25-分" class="headerlink" title="eg1. 1003 Emergency (25 分)"></a>eg1. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003 Emergency (25 分)</a></h2><p> <strong>题意</strong>：输入城市数N、路径数M、in and save city,N个城市的rescue数，M条路径；找出最短路径的长度，以及在路上可以收集的最大rescue teams；输出最短路径的数量以及最大值；<br> <strong>思路</strong>：</p>
<ol>
<li>构建一张有权无向图，求路径最短及节点上值和最大的路径；</li>
<li>DFS(start,end)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if(index==End)&#123;</span><br><span class="line">    ...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">                if(Map[index][i]!=0&amp;&amp;flag[i]==false)&#123;</span><br><span class="line">                    flag[i]=true;</span><br><span class="line">                    length+=Map[index][i];</span><br><span class="line">                    rescueSum+=rescueNum[i];</span><br><span class="line">                    DFS(i,End);</span><br><span class="line">                    flag[i]=false;</span><br><span class="line">                    length-=Map[index][i];</span><br><span class="line">                    rescueSum-=rescueNum[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <strong>注意点</strong>：<br> 1.在进入DFS函数前初始化，将起点flag[C1]置为true等：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rescueSum+=rescueNum[C1];</span><br><span class="line">flag[C1]=1;</span><br><span class="line">DFS(C1,C2);</span><br></pre></td></tr></table></figure></p>
<h1 id="时间的比较"><a href="#时间的比较" class="headerlink" title="时间的比较"></a>时间的比较</h1><h2 id="eg-1006-Sign-In-and-Sign-Out-25-分"><a href="#eg-1006-Sign-In-and-Sign-Out-25-分" class="headerlink" title="eg. 1006 Sign In and Sign Out (25 分)"></a>eg. <a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805516654460928">1006 Sign In and Sign Out (25 分)</a></h2><p><strong>题意</strong>：输入记录：ID+到达时间+离开时间，分别找到最早到与最晚离开的同学，输出ID；<br><strong>思路</strong>：<br>pair的妙用:first存时间，second存学号；max与min比较的是first字段；时间字符串直接按字典序比较；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;string,string&gt; tlog;</span><br><span class="line">tlog ear = tlog(b,a),las = tlog(c,a); </span><br><span class="line">	for (int i=1;i&lt;n;i++)</span><br><span class="line">	  &#123;</span><br><span class="line">	  	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	    ear = min(ear,tlog(b,a));//# include &lt;algorithm&gt;</span><br><span class="line">	    las = max(las,tlog(c,a));</span><br><span class="line">	  &#125;</span><br><span class="line">cout &lt;&lt; ear.second &lt;&lt; &#x27; &#x27; &lt;&lt; las.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="大数-二分查找"><a href="#大数-二分查找" class="headerlink" title="大数+二分查找"></a>大数+二分查找</h1><p><strong>题意</strong>：输入2个数以及其中一个数的进制，找到使这两个数相等的另一个数的进制；<br><strong>思路</strong>：</p>
<ol>
<li>字符串输入，转换成10进制比较；</li>
<li>二分查找；</li>
</ol>
<p><strong>注意点</strong>：</p>
<ol>
<li>转换成10进制时，有可能溢出，需要判断；</li>
<li>二分查找的范围是当前值各个位数中的最大值+1，已知进制值的这个数+1（不可能比这个数更大了，因为这时表示为10）；<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944">1051 Pop Sequence (25 分)</a><br>判断pop序列是否正确</li>
</ol>
<p><strong>思路</strong>:</p>
<ol>
<li>模拟1~N的入栈，以current指向序列首位；遇到相同的则出栈，current后移；</li>
<li>当超出栈容量或者全入栈后，current不为N时，则序列不正确；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int M,N,K;// stack的最大容量，push长度，数量</span><br><span class="line">    vector&lt;int&gt; popList;// pop序列</span><br><span class="line">    vector&lt;int&gt; myStack;// 栈</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;K);</span><br><span class="line">    while(K--)&#123;</span><br><span class="line">        int num;</span><br><span class="line">        popList.clear();</span><br><span class="line">        myStack.clear();</span><br><span class="line">        // 输入pop序列</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">            popList.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        int current=0;// 指向popList当前位置</span><br><span class="line">        bool flag=true;// 标记</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            myStack.push_back(i);// 入栈</span><br><span class="line">            // 超过最大容量</span><br><span class="line">            if(myStack.size()&gt;M)&#123;</span><br><span class="line">                flag=false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当发现当前栈元素与popList头部元素相似</span><br><span class="line">            while(!myStack.empty()&amp;&amp;myStack.back()==popList[current])&#123;</span><br><span class="line">                myStack.pop_back();</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当popList没有遍历完全或者超出最大容量</span><br><span class="line">        if(current!=N||flag==false)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805419468242944">1056 Mice and Rice (25 分)</a></li>
</ol>
<p><strong>思路</strong>:</p>
<ol>
<li>题目看了很久才理解;</li>
<li>使用一个队列存放参赛者名单，pop首部来模拟小组比赛，将获胜者push到队列尾巴，知道队列中只剩一个笑到最后的玩家;</li>
<li>注意在模拟每一局比赛时，固定初始队列大小，而不是动态获取；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX=1010;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int Weight;</span><br><span class="line">    int Rank;</span><br><span class="line">    int Pos;</span><br><span class="line">&#125;Input[MAX];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int NP,NG;//参赛者数，小组人数</span><br><span class="line">    queue&lt;node&gt; mice;// 存放参加比赛的老鼠</span><br><span class="line">    cin&gt;&gt;NP&gt;&gt;NG;</span><br><span class="line">    for(int i=0;i&lt;NP;i++)&#123;</span><br><span class="line">        cin&gt;&gt;Input[i].Weight;</span><br><span class="line">        Input[i].Pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    //将初始比赛序列放入队列</span><br><span class="line">    int p;</span><br><span class="line">    for(int i=0;i&lt;NP;i++)&#123;</span><br><span class="line">        cin&gt;&gt;p;</span><br><span class="line">        mice.push(Input[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    while(!mice.empty())&#123;</span><br><span class="line">        //当队列中只剩一个</span><br><span class="line">        if(mice.size()==1)&#123;</span><br><span class="line">            node temp=mice.front();</span><br><span class="line">            Input[temp.Pos].Rank=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int groupNum=mice.size()/NG;//比赛数</span><br><span class="line">        if(mice.size()%NG!=0)groupNum+=1;//剩余的归于一组</span><br><span class="line">        int oneTimeNum=mice.size();//记录本轮参与者数量</span><br><span class="line">                                   //直接使用mice.size()会在一组比赛结束后发生变化(得到获胜者，插入到队列中后</span><br><span class="line">        for(int i=0;i&lt;groupNum;i++)&#123;</span><br><span class="line">            int winPosition;</span><br><span class="line">            int maxW=-1;</span><br><span class="line">            int memberNum=NG;</span><br><span class="line">            // 最后一组特殊情况考虑</span><br><span class="line">            if(i==groupNum-1&amp;&amp;oneTimeNum%NG!=0)&#123;</span><br><span class="line">                memberNum=oneTimeNum%NG;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=0;j&lt;memberNum;j++)&#123;</span><br><span class="line">                node temp=mice.front();</span><br><span class="line">                mice.pop();</span><br><span class="line">                if(maxW&lt;temp.Weight)&#123;</span><br><span class="line">                    maxW=temp.Weight;</span><br><span class="line">                    winPosition=temp.Pos;</span><br><span class="line">                &#125;</span><br><span class="line">                Input[temp.Pos].Rank=groupNum+1;</span><br><span class="line">            &#125;</span><br><span class="line">            mice.push(Input[winPosition]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出</span><br><span class="line">    for(int i=0;i&lt;NP;i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;Input[i].Rank;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464">1052 Linked List Sorting (25 分)</a></li>
</ol>
<p><strong>思路</strong>：</p>
<ol>
<li>按order排序，按序输出；</li>
<li>有效node的order为key值，无效node的order设为最大值，则在排序时会排到后面去；</li>
<li>注意：需要对原链表遍历处理，清除无效结点；当有效结点值为空的输出；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX = 100010;</span><br><span class="line">struct node &#123;</span><br><span class="line">    int add,key,next;</span><br><span class="line">    int order;</span><br><span class="line"></span><br><span class="line">&#125;myList[MAX];</span><br><span class="line">int N,head;</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.order&lt;b.order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 初始化，使空结点值排到后面</span><br><span class="line">    for(int i=0;i&lt;MAX;i++)&#123;</span><br><span class="line">        myList[i].order=MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N,&amp;head);</span><br><span class="line">    // 输入N个结点</span><br><span class="line">    int address,key,nextadd;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;address,&amp;key,&amp;nextadd);</span><br><span class="line">        myList[address].add=address;</span><br><span class="line">        myList[address].key=key;</span><br><span class="line">        myList[address].next=nextadd;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp=head;</span><br><span class="line">    int vaild=0;</span><br><span class="line">    while(temp!=-1)&#123;</span><br><span class="line">        vaild++;</span><br><span class="line">        myList[temp].order=myList[temp].key;</span><br><span class="line">        temp=myList[temp].next;</span><br><span class="line">    &#125;</span><br><span class="line">    N=vaild;</span><br><span class="line">    if(N==0)&#123;</span><br><span class="line">        printf(&quot;%d %d\n&quot;,N,-1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(myList,myList+MAX,cmp);</span><br><span class="line">    printf(&quot;%d %05d\n&quot;,N,myList[0].add);</span><br><span class="line">    for(int i=0;i&lt;N-1;i++)&#123;</span><br><span class="line">        printf(&quot;%05d %d %05d\n&quot;,myList[i].add,myList[i].key,myList[i+1].add);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%05d %d %0d\n&quot;,myList[N-1].add,myList[N-1].key,-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805458722734080">1033 To Fill or Not to Fill (25 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const double MAX=10000000000;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    double price;</span><br><span class="line">    double dis;</span><br><span class="line">&#125;gasStation[505];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.dis&lt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double Cmax,D,Davg;//车的最大储油量</span><br><span class="line">                      //出发地与目标地之间的距离</span><br><span class="line">                      //每单位油可走的距离</span><br><span class="line">    int N;//N个gas station</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%lf%lf%lf%d&quot;,&amp;Cmax,&amp;D,&amp;Davg,&amp;N);</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;gasStation[i].price,&amp;gasStation[i].dis);</span><br><span class="line">    &#125;</span><br><span class="line">    gasStation[N].dis=D;</span><br><span class="line">    gasStation[N].price=0;</span><br><span class="line">    sort(gasStation,gasStation+N+1,cmp);</span><br><span class="line">    /*for(int i=0;i&lt;=N;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;gasStation[i].dis&lt;&lt;&quot; &quot;&lt;&lt;gasStation[i].price&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;*********************&quot;&lt;&lt;endl;*/</span><br><span class="line">    //贪心策略</span><br><span class="line">    //在每一油站判断</span><br><span class="line">    //找到比当前油站price更小的最近可达的油站，加油加到刚好到达该站即可；</span><br><span class="line">    //否则在该站加满油,然后前往可达范围内油价最低的油站；</span><br><span class="line">    double maxLen=Cmax*Davg;//满油状态下的最大里程</span><br><span class="line">    int pos=0;//车到达位置</span><br><span class="line">    double nowGas=0;//当前油量</span><br><span class="line">    double totalPrice=0;//总油价</span><br><span class="line">    double totalLen=0;//总里程</span><br><span class="line">    //当起点没有油站时</span><br><span class="line">    if(gasStation[0].dis!=0)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;The maximum travel distance = 0.00&quot;&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(pos&lt;N)&#123;</span><br><span class="line">        double lowPrice=MAX;</span><br><span class="line">        int i,tempPos=pos;</span><br><span class="line">        bool flag=false;</span><br><span class="line">        for(i=pos+1;i&lt;=N &amp;&amp; gasStation[i].dis-gasStation[pos].dis&lt;=maxLen;i++)&#123;</span><br><span class="line">            if (gasStation[i].price &lt; gasStation[pos].price) &#123;//发现可达范围内存在比当前油价低的油站</span><br><span class="line">                double needGas=(gasStation[i].dis-gasStation[pos].dis)/Davg;</span><br><span class="line">                if(nowGas&gt;=needGas)&#123;//本来剩余油可达，无需加油啦</span><br><span class="line">                    nowGas-=needGas;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    totalPrice+=(needGas-nowGas)*gasStation[pos].price;</span><br><span class="line">                    nowGas=0;</span><br><span class="line">                &#125;</span><br><span class="line">                pos=i;//去往i油站</span><br><span class="line">                totalLen=gasStation[pos].dis;</span><br><span class="line">                flag=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(gasStation[i].price &lt; lowPrice)&#123;</span><br><span class="line">                lowPrice=gasStation[i].price;</span><br><span class="line">                tempPos=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(gasStation[pos+1].dis-gasStation[pos].dis&gt;maxLen)&#123;//满油也无法到达最近的油站</span><br><span class="line">            printf(&quot;The maximum travel distance = %.2lf&quot;,totalLen+maxLen);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==false)&#123;//说明可达范围内没有比当前更便宜的了，充满</span><br><span class="line">            totalPrice+=(Cmax-nowGas)*gasStation[pos].price;</span><br><span class="line">            nowGas=Cmax-(gasStation[tempPos].dis-gasStation[pos].dis)/Davg;</span><br><span class="line">            pos=tempPos;</span><br><span class="line">            totalLen=gasStation[pos].dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%.2lf&quot;,totalPrice);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805403651522560">1067 Sort with Swap(0, i) (25 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int N;</span><br><span class="line">vector&lt;int&gt;permutation;</span><br><span class="line">void outPut()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cout&lt;&lt;permutation[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    map&lt;int,int&gt;myMap;//存储值与位置关系</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    int input;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;input;</span><br><span class="line">        permutation.push_back(input);</span><br><span class="line">        myMap[input]=i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int num=0;</span><br><span class="line">    int j=1;//将j提到前面来，避免不必要的循环判断</span><br><span class="line">    //贪心</span><br><span class="line">    //0当前在哪个位置上，就去找最终应该在这个位置上的值，swap</span><br><span class="line">    while(true&amp;&amp;N!=0)&#123;</span><br><span class="line">        int pos=myMap[0];</span><br><span class="line">        //当0在0位置上时，实际上序列还没有完成排序</span><br><span class="line">        //与第一个未呆在正确位置的值swap</span><br><span class="line">        if(pos==0)&#123;</span><br><span class="line">            for(j;j&lt;N;j++)&#123;//从左到右找到第一个不在本位的值</span><br><span class="line">                if(permutation[j]!=j)&#123;</span><br><span class="line">                       // cout&lt;&lt;j;</span><br><span class="line">                    swap(permutation[j],permutation[0]);</span><br><span class="line">                    myMap[0]=j;</span><br><span class="line">                    myMap[permutation[0]]=0;//0与j已交换</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j==N)break;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            swap(permutation[myMap[0]],permutation[myMap[pos]]);</span><br><span class="line">            myMap[0]=myMap[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        //outPut();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072">1020 Tree Traversals (25 分)</a><br><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024">1086 Tree Traversals Again (25 分)</a><br>已知树的中序遍历、后序(先序)遍历，建树；<br><strong>思路</strong>：(以先序为例)</p>
<ol>
<li>先序遍历的首位结点为当前数的根结点;</li>
<li>在中序遍历中找到首位结点的位置，将该树分为左子树与右子树2部分;</li>
<li>递归求左右子树，直到当前结点为空;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt;preOrder,inOrder,tempOrder,postOrder;</span><br><span class="line">int N;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* CreateTree(int prel,int prer,int inl,int inr)</span><br><span class="line">&#123;</span><br><span class="line">    if(prel&lt;=prer)&#123;</span><br><span class="line">        int k;</span><br><span class="line">        //postr即为当前根节点值</span><br><span class="line">        //找到中序排列中根节点的位置</span><br><span class="line">        for(k=inl;k&lt;=inr;k++)&#123;</span><br><span class="line">            if(inOrder[k]==preOrder[prel])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //左子树的结点值</span><br><span class="line">        int numLeft=k-inl;</span><br><span class="line">        node* root=new node;</span><br><span class="line">        root-&gt;data=inOrder[k];</span><br><span class="line">        root-&gt;left=CreateTree(prel+1,prel+numLeft,inl,k-1);</span><br><span class="line">        root-&gt;right=CreateTree(prel+numLeft+1,prer,k+1,inr);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后序遍历</span><br><span class="line">void postTraversals(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)return;</span><br><span class="line">    postTraversals(root-&gt;left);</span><br><span class="line">    postTraversals(root-&gt;right);</span><br><span class="line">    postOrder.push_back(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int input;</span><br><span class="line">    char oper[5];</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int i=0;i&lt;2*N;i++)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;oper);</span><br><span class="line">        if(!strcmp(oper,&quot;Push&quot;))&#123;</span><br><span class="line">            cin&gt;&gt;input;</span><br><span class="line">            preOrder.push_back(input);</span><br><span class="line">            tempOrder.push_back(input);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            int in=tempOrder.back();</span><br><span class="line">            tempOrder.pop_back();</span><br><span class="line">            inOrder.push_back(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root=CreateTree(0,N-1,0,N-1);</span><br><span class="line">    postTraversals(root);</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;postOrder[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805388447170560">1079 Total Sales of Supply Chain (25 分)</a></li>
</ol>
<p><strong>思路</strong>:<strong>DFS</strong></p>
<ol>
<li>求供应链中产品从供应商到零售商流动后，得到最终的总价格；</li>
<li>即DFS遍历求每个叶子结点的深度；<br><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805376476626944">1090 Highest Price in Supply Chain (25 分)</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int products;</span><br><span class="line">    vector&lt;int&gt; child;</span><br><span class="line">&#125;supplyChain[100001];</span><br><span class="line"></span><br><span class="line">int N;//结点数</span><br><span class="line">double P,r;//根节点的初始价格，每层增加的百分比</span><br><span class="line">double sum=0;</span><br><span class="line"></span><br><span class="line">void DFS(int root,int level)</span><br><span class="line">&#123;</span><br><span class="line">    if(supplyChain[root].child.size()==0)&#123;//到达根节点</span><br><span class="line">        sum+=pow(r,level)*supplyChain[root].products*P;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;supplyChain[root].child.size();i++)&#123;</span><br><span class="line">        DFS(supplyChain[root].child[i],level+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%lf%lf&quot;,&amp;N,&amp;P,&amp;r);</span><br><span class="line">    r=(double)1+r/100;</span><br><span class="line">    int k,input;</span><br><span class="line">    //输入</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        if(k==0)&#123;</span><br><span class="line">            cin&gt;&gt;supplyChain[i].products;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int j=0;j&lt;k;j++)&#123;</span><br><span class="line">                cin&gt;&gt;input;</span><br><span class="line">                supplyChain[i].child.push_back(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //DFS求层数</span><br><span class="line">    DFS(0,0);</span><br><span class="line">    printf(&quot;%.1lf&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048">The Largest Generation (25 分)</a><br>求拥有最大结点数的level<br><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184">1004 Counting Leaves (30 分)</a><br>求树的每层叶子结点数,可用DFS或BFS；</li>
</ol>
<p><strong>思路</strong>:（BFS）</p>
<ol>
<li>使用一个queue做BFS，一个level[i]数组存储i结点所在的层数,一个res[i]数组存储i层的叶子节点数;</li>
<li>pop出当前结点;for循环得出当前结点的孩子结点，此时设置孩子结点的level为当前结点level+1;</li>
<li>当当前结点孩子数为空，则为叶子结点，res[level]++;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;//总结点数，非叶子结点数</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; myTree[105];</span><br><span class="line">int res[105]=&#123;0&#125;;</span><br><span class="line">int level[105]=&#123;0&#125;;//各结点所处的层号</span><br><span class="line">int maxlevel=-1;</span><br><span class="line"></span><br><span class="line">void BFS(int root)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt;myQueue;</span><br><span class="line">    myQueue.push(root);</span><br><span class="line">    while(!myQueue.empty())&#123;</span><br><span class="line">        int temp=myQueue.front();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        maxlevel=max(maxlevel,level[temp]);</span><br><span class="line">        if(myTree[temp].size()==0)&#123;</span><br><span class="line">            res[level[temp]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;myTree[temp].size();i++)&#123;</span><br><span class="line">            level[myTree[temp][i]]=level[temp]+1;</span><br><span class="line">            myQueue.push(myTree[temp][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int id,k;//结点id，子节点数</span><br><span class="line">    int input;</span><br><span class="line">    memset(res,0,sizeof(res));</span><br><span class="line">    for(int i=0;i&lt;M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;id&gt;&gt;k;</span><br><span class="line">        for(int j=0;j&lt;k;j++)&#123;</span><br><span class="line">            cin&gt;&gt;input;</span><br><span class="line">            myTree[id].push_back(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    level[1]=1;</span><br><span class="line">    BFS(1);</span><br><span class="line">    for(int i=1;i&lt;=maxlevel;i++)&#123;</span><br><span class="line">        if(i!=1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805440976633856">1043 Is It a Binary Search Tree (25 分)</a><br>判断给定序列是否为BST，或者BST的镜像;</li>
</ol>
<p><strong>思路</strong>:</p>
<ol>
<li>边输入值，边构建二叉搜索树,判断当前插入在root的左子树或右子树;</li>
<li>构建完树后进行先序遍历与镜像先序遍历，判断是否与输入初始序列相同;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line">node* myRoot=NULL;</span><br><span class="line">int original[1005],pre[1005],preMirror[1005],post[1005],postMirror[1005];</span><br><span class="line">int iindex=0;</span><br><span class="line"></span><br><span class="line">void CreatBST(node* &amp;root,int data)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;//当根结点为空</span><br><span class="line">        root=new node;</span><br><span class="line">        root-&gt;data=data;</span><br><span class="line">        root-&gt;left=NULL;</span><br><span class="line">        root-&gt;right=NULL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(data&gt;=root-&gt;data)&#123;//插入到右子树中</span><br><span class="line">        CreatBST(root-&gt;right,data);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;//插入到左子树</span><br><span class="line">        CreatBST(root-&gt;left,data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[iindex++]=root-&gt;data;</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preMirrorOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    preMirror[iindex++]=root-&gt;data;</span><br><span class="line">    preMirrorOrder(root-&gt;right);</span><br><span class="line">    preMirrorOrder(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSame(int a[],int b[])</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        if(a[i]!=b[i])return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void postOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line">    post[iindex++]=root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void postMirrorOrder(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    postMirrorOrder(root-&gt;right);</span><br><span class="line">    postMirrorOrder(root-&gt;left);</span><br><span class="line">    postMirror[iindex++]=root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    int data;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;data;</span><br><span class="line">        CreatBST(myRoot,data);</span><br><span class="line">        original[i]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    //先序遍历</span><br><span class="line">    preOrder(myRoot);</span><br><span class="line">    //镜像BST的先序遍历</span><br><span class="line">    iindex=0;</span><br><span class="line">    preMirrorOrder(myRoot);</span><br><span class="line">    if(isSame(original,pre))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        iindex=0;</span><br><span class="line">        postOrder(myRoot);</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">            cout&lt;&lt;post[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(isSame(original,preMirror))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        iindex=0;</span><br><span class="line">        postMirrorOrder(myRoot);</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            if(i!=0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">            cout&lt;&lt;postMirror[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全二叉排序树CBST"><a href="#完全二叉排序树CBST" class="headerlink" title="完全二叉排序树CBST"></a>完全二叉排序树CBST</h3><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805407749357568">1064 Complete Binary Search Tree (30分)</a><br>构建一棵CBST</li>
</ol>
<p><strong>思路</strong>：CBST的特点：如果使用数组存放完全二叉树（即层序存放的结果），那么对于x结点，其左孩子结点为2x，右孩子结点为2x+1（假设存在）;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int data[1001],tree[1001];</span><br><span class="line">int pos=1;</span><br><span class="line">int N;//N&lt;=1000</span><br><span class="line">//使用中序遍历方法构建CBST</span><br><span class="line">void CreateCBST(int root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&gt;N)return;</span><br><span class="line">    int l=2*root;</span><br><span class="line">    int r=2*root+1;</span><br><span class="line">    CreateCBST(l);</span><br><span class="line">    tree[root]=data[pos++];</span><br><span class="line">    CreateCBST(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(data+1,data+N+1);</span><br><span class="line">    CreateCBST(1);</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        if(i!=1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h3><p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805404939173888">1066 Root of AVL Tree (25 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int N;//结点数</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    int height;//当前结点高度</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//获取以root为根结点的树的高度</span><br><span class="line">int getHeight(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)return 0;</span><br><span class="line">    return root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新高度</span><br><span class="line">void updateHeight(node* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    root-&gt;height=max(getHeight(root-&gt;left),getHeight(root-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取以root为根结点的树的平衡因子</span><br><span class="line">//左子树高度-右子树高度</span><br><span class="line">int getBF(node* root)</span><br><span class="line">&#123;</span><br><span class="line">    return getHeight(root-&gt;left)-getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//左旋(逆时针</span><br><span class="line">void L(node* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    node* temp=root-&gt;right;//temp为旋转后的根结点</span><br><span class="line">    root-&gt;right=temp-&gt;left;//temp结点的左子树放在root结点的右子树位置</span><br><span class="line">    temp-&gt;left=root;//temp的左子树改为root</span><br><span class="line">    //更新高度</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//右旋(顺时针</span><br><span class="line">void R(node* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    node* temp=root-&gt;left;//temp为旋转后根节点</span><br><span class="line">    root-&gt;left=temp-&gt;right;//temp的右子树放在root结点的左子树位置</span><br><span class="line">    temp-&gt;right=root;</span><br><span class="line">    //更新高度</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertNode(node* &amp;root,int data)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==NULL)&#123;</span><br><span class="line">        root=new node;</span><br><span class="line">        root-&gt;data=data;</span><br><span class="line">        root-&gt;left=NULL;</span><br><span class="line">        root-&gt;right=NULL;</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(data&lt;root-&gt;data)&#123;//插入左子树</span><br><span class="line">        insertNode(root-&gt;left,data);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        if(getBF(root)==2)&#123;</span><br><span class="line">            if(getBF(root-&gt;left)==1)&#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(getBF(root-&gt;left)==-1)&#123;</span><br><span class="line">                L(root-&gt;left);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        insertNode(root-&gt;right,data);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        if(getBF(root)==-2)&#123;</span><br><span class="line">            if(getBF(root-&gt;right)==-1)&#123;</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(getBF(root-&gt;right)==1)&#123;</span><br><span class="line">                R(root-&gt;right);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    int data;</span><br><span class="line">    node* myRoot=NULL;</span><br><span class="line">    for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;data;</span><br><span class="line">        insertNode(myRoot,data);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;myRoot-&gt;data;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744">1107 Social Clusters (30 分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int pre[1005];</span><br><span class="line">int hobby[1005];</span><br><span class="line">int isRoot[1005];//每个门派中人数</span><br><span class="line">int N,K;//总人数，爱好数</span><br><span class="line">//初始化,将所有的掌门人设为本身</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">        hobby[i]=0;</span><br><span class="line">        isRoot[i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findRoot(int root)</span><br><span class="line">&#123;</span><br><span class="line">    int son,temp;</span><br><span class="line">    son=root;</span><br><span class="line">    //找到最上层掌门人</span><br><span class="line">    while(root!=pre[root])&#123;</span><br><span class="line">        root=pre[root];</span><br><span class="line">    &#125;</span><br><span class="line">    //路径压缩</span><br><span class="line">    //将这条路上遇到的结点pre[x]都直接设置为root</span><br><span class="line">    while(son!=root)&#123;</span><br><span class="line">        temp=pre[son];</span><br><span class="line">        pre[son]=root;</span><br><span class="line">        son=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int root1=findRoot(a);</span><br><span class="line">    int root2=findRoot(b);</span><br><span class="line">    if(root1!=root2)&#123;</span><br><span class="line">        pre[root1]=root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int h;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    init();</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        scanf(&quot;%d:&quot;,&amp;K);</span><br><span class="line">        for(int j=0;j&lt;K;j++)&#123;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            if(hobby[h]==0)&#123;//目前没有人有这个爱好</span><br><span class="line">                hobby[h]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            Union(i,hobby[h]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //统计属于同一门派的人数</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        isRoot[findRoot(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    //统计门派数量</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        if(isRoot[i]!=0)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    //从大到小排序</span><br><span class="line">    sort(isRoot+1,isRoot+N+1,cmp);</span><br><span class="line">    //输出</span><br><span class="line">    for(int i=1;i&lt;=ans;i++)&#123;</span><br><span class="line">        if(i!=1)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;isRoot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840">1013 Battle Over Cities (25分)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; myMap[1050];// map</span><br><span class="line">int N,M,K;// number of cities &lt; 1000</span><br><span class="line">          // number of remaining highways</span><br><span class="line">          // checked cities</span><br><span class="line">int father[1050];// 存放掌门结点</span><br><span class="line">int rootSet[1050];// 存放i掌门人所处派别人数</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">// 将所有结点的掌门人设为本身</span><br><span class="line">void init(int num)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=num;i++)&#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        rootSet[i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findRoot(int son)</span><br><span class="line">&#123;</span><br><span class="line">    int root=son;</span><br><span class="line">    while(root!=father[root])&#123;</span><br><span class="line">        root=father[root];</span><br><span class="line">    &#125;</span><br><span class="line">    int temp;</span><br><span class="line">    //路径压缩</span><br><span class="line">    while(son!=root)&#123;</span><br><span class="line">        temp=father[son];</span><br><span class="line">        father[son]=root;</span><br><span class="line">        son=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int rootx=findRoot(x);</span><br><span class="line">    int rooty=findRoot(y);</span><br><span class="line">    if(rootx!=rooty)&#123;</span><br><span class="line">        father[rootx]=rooty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 并查集法求连通块数</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    int x,y;</span><br><span class="line">    int block=0;</span><br><span class="line">    for(int i=0;i&lt;M;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        myMap[x].push_back(y);</span><br><span class="line">        myMap[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    int concern;</span><br><span class="line">    for(int index=0;index&lt;K;index++)&#123;</span><br><span class="line">        init(N);</span><br><span class="line">        block=0;</span><br><span class="line">        cin&gt;&gt;concern;</span><br><span class="line">        // 枚举每条边</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;myMap[i].size();j++)&#123;</span><br><span class="line">                if(i==concern||myMap[i][j]==concern)continue;</span><br><span class="line">                Union(i,myMap[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 统计不同的门派人数</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(i==concern)continue;</span><br><span class="line">            rootSet[findRoot(father[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(rootSet[i]!=0)block++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;block-1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>大数+二分查找</li>
</ol>
<p>模拟题:<br>考虑数据结构<br>一般思路：从一般到特殊</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/17/%E5%88%B7%E9%A2%98/pat%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/" data-id="ckxq1b6j3000peswb5nn26js3" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2019/09/30/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/%E4%BF%9D%E7%A0%94%E5%8E%86%E7%A8%8B/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      保研历程
      
    </div>
  </a>
  
  
  <a href="/2019/09/14/%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">软件工程复习</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Cecyci &copy; 2021</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Cecyci"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>